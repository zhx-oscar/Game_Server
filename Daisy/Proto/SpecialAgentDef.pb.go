// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: SpecialAgentDef.proto

package Proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//SpecialAgent 单个特工数据
type SpecialAgent struct {
	Base   *SpecialAgentBase   `protobuf:"bytes,1,opt,name=Base,proto3" json:"Base,omitempty"`
	Talent *SpecialAgentTalent `protobuf:"bytes,2,opt,name=Talent,proto3" json:"Talent,omitempty"`
}

func (m *SpecialAgent) Reset()         { *m = SpecialAgent{} }
func (m *SpecialAgent) String() string { return proto.CompactTextString(m) }
func (*SpecialAgent) ProtoMessage()    {}
func (*SpecialAgent) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{0}
}
func (m *SpecialAgent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialAgent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialAgent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialAgent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialAgent.Merge(m, src)
}
func (m *SpecialAgent) XXX_Size() int {
	return m.Size()
}
func (m *SpecialAgent) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialAgent.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialAgent proto.InternalMessageInfo

func (m *SpecialAgent) GetBase() *SpecialAgentBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *SpecialAgent) GetTalent() *SpecialAgentTalent {
	if m != nil {
		return m.Talent
	}
	return nil
}

//SpecialAgentBase 特工基础数据
type SpecialAgentBase struct {
	ConfigID uint32 `protobuf:"varint,1,opt,name=ConfigID,proto3" json:"ConfigID,omitempty"`
	Exp      uint64 `protobuf:"varint,2,opt,name=Exp,proto3" json:"Exp,omitempty"`
	Level    uint32 `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	GainTime int64  `protobuf:"varint,4,opt,name=GainTime,proto3" json:"GainTime,omitempty"`
}

func (m *SpecialAgentBase) Reset()         { *m = SpecialAgentBase{} }
func (m *SpecialAgentBase) String() string { return proto.CompactTextString(m) }
func (*SpecialAgentBase) ProtoMessage()    {}
func (*SpecialAgentBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{1}
}
func (m *SpecialAgentBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialAgentBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialAgentBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialAgentBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialAgentBase.Merge(m, src)
}
func (m *SpecialAgentBase) XXX_Size() int {
	return m.Size()
}
func (m *SpecialAgentBase) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialAgentBase.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialAgentBase proto.InternalMessageInfo

func (m *SpecialAgentBase) GetConfigID() uint32 {
	if m != nil {
		return m.ConfigID
	}
	return 0
}

func (m *SpecialAgentBase) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *SpecialAgentBase) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SpecialAgentBase) GetGainTime() int64 {
	if m != nil {
		return m.GainTime
	}
	return 0
}

//SpecialAgentTalent 特工天赋数据
type SpecialAgentTalent struct {
	TalentPoint uint32                 `protobuf:"varint,1,opt,name=TalentPoint,proto3" json:"TalentPoint,omitempty"`
	TalentMap   map[uint32]*TalentData `protobuf:"bytes,2,rep,name=TalentMap,proto3" json:"TalentMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SpecialAgentTalent) Reset()         { *m = SpecialAgentTalent{} }
func (m *SpecialAgentTalent) String() string { return proto.CompactTextString(m) }
func (*SpecialAgentTalent) ProtoMessage()    {}
func (*SpecialAgentTalent) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{2}
}
func (m *SpecialAgentTalent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecialAgentTalent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecialAgentTalent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecialAgentTalent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecialAgentTalent.Merge(m, src)
}
func (m *SpecialAgentTalent) XXX_Size() int {
	return m.Size()
}
func (m *SpecialAgentTalent) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecialAgentTalent.DiscardUnknown(m)
}

var xxx_messageInfo_SpecialAgentTalent proto.InternalMessageInfo

func (m *SpecialAgentTalent) GetTalentPoint() uint32 {
	if m != nil {
		return m.TalentPoint
	}
	return 0
}

func (m *SpecialAgentTalent) GetTalentMap() map[uint32]*TalentData {
	if m != nil {
		return m.TalentMap
	}
	return nil
}

//BuildData build信息
type BuildData struct {
	BuildID        string           `protobuf:"bytes,1,opt,name=BuildID,proto3" json:"BuildID,omitempty"`
	Name           string           `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	SpecialAgentID uint32           `protobuf:"varint,3,opt,name=SpecialAgentID,proto3" json:"SpecialAgentID,omitempty"`
	Skill          *BuildSkillData  `protobuf:"bytes,4,opt,name=Skill,proto3" json:"Skill,omitempty"`
	EquipmentMap   map[int32]string `protobuf:"bytes,5,rep,name=EquipmentMap,proto3" json:"EquipmentMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CreateTime     int64            `protobuf:"varint,6,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	FightAttr      *FightAttr       `protobuf:"bytes,7,opt,name=FightAttr,proto3" json:"FightAttr,omitempty"`
}

func (m *BuildData) Reset()         { *m = BuildData{} }
func (m *BuildData) String() string { return proto.CompactTextString(m) }
func (*BuildData) ProtoMessage()    {}
func (*BuildData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{3}
}
func (m *BuildData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildData.Merge(m, src)
}
func (m *BuildData) XXX_Size() int {
	return m.Size()
}
func (m *BuildData) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildData.DiscardUnknown(m)
}

var xxx_messageInfo_BuildData proto.InternalMessageInfo

func (m *BuildData) GetBuildID() string {
	if m != nil {
		return m.BuildID
	}
	return ""
}

func (m *BuildData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BuildData) GetSpecialAgentID() uint32 {
	if m != nil {
		return m.SpecialAgentID
	}
	return 0
}

func (m *BuildData) GetSkill() *BuildSkillData {
	if m != nil {
		return m.Skill
	}
	return nil
}

func (m *BuildData) GetEquipmentMap() map[int32]string {
	if m != nil {
		return m.EquipmentMap
	}
	return nil
}

func (m *BuildData) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *BuildData) GetFightAttr() *FightAttr {
	if m != nil {
		return m.FightAttr
	}
	return nil
}

// BuildSkillData build技能数据
type BuildSkillData struct {
	UltimateSkillID uint32            `protobuf:"varint,1,opt,name=UltimateSkillID,proto3" json:"UltimateSkillID,omitempty"`
	SuperSkill      map[uint32]uint32 `protobuf:"bytes,2,rep,name=SuperSkill,proto3" json:"SuperSkill,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *BuildSkillData) Reset()         { *m = BuildSkillData{} }
func (m *BuildSkillData) String() string { return proto.CompactTextString(m) }
func (*BuildSkillData) ProtoMessage()    {}
func (*BuildSkillData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{4}
}
func (m *BuildSkillData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildSkillData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildSkillData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildSkillData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildSkillData.Merge(m, src)
}
func (m *BuildSkillData) XXX_Size() int {
	return m.Size()
}
func (m *BuildSkillData) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildSkillData.DiscardUnknown(m)
}

var xxx_messageInfo_BuildSkillData proto.InternalMessageInfo

func (m *BuildSkillData) GetUltimateSkillID() uint32 {
	if m != nil {
		return m.UltimateSkillID
	}
	return 0
}

func (m *BuildSkillData) GetSuperSkill() map[uint32]uint32 {
	if m != nil {
		return m.SuperSkill
	}
	return nil
}

// SkillData 技能数据
type SkillData struct {
	SkillMainID uint32 `protobuf:"varint,1,opt,name=SkillMainID,proto3" json:"SkillMainID,omitempty"`
	Lv          uint32 `protobuf:"varint,2,opt,name=Lv,proto3" json:"Lv,omitempty"`
}

func (m *SkillData) Reset()         { *m = SkillData{} }
func (m *SkillData) String() string { return proto.CompactTextString(m) }
func (*SkillData) ProtoMessage()    {}
func (*SkillData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{5}
}
func (m *SkillData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillData.Merge(m, src)
}
func (m *SkillData) XXX_Size() int {
	return m.Size()
}
func (m *SkillData) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillData.DiscardUnknown(m)
}

var xxx_messageInfo_SkillData proto.InternalMessageInfo

func (m *SkillData) GetSkillMainID() uint32 {
	if m != nil {
		return m.SkillMainID
	}
	return 0
}

func (m *SkillData) GetLv() uint32 {
	if m != nil {
		return m.Lv
	}
	return 0
}

// FightAttr 战斗属性
type FightAttr struct {
	MaxHP                         int64   `protobuf:"varint,1,opt,name=MaxHP,proto3" json:"MaxHP,omitempty"`
	RecoverHP                     int64   `protobuf:"varint,2,opt,name=RecoverHP,proto3" json:"RecoverHP,omitempty"`
	Attack                        int64   `protobuf:"varint,3,opt,name=Attack,proto3" json:"Attack,omitempty"`
	HitRate                       float32 `protobuf:"fixed32,4,opt,name=HitRate,proto3" json:"HitRate,omitempty"`
	AttackLucky                   float32 `protobuf:"fixed32,5,opt,name=AttackLucky,proto3" json:"AttackLucky,omitempty"`
	NormalAttackSpeed             float32 `protobuf:"fixed32,6,opt,name=NormalAttackSpeed,proto3" json:"NormalAttackSpeed,omitempty"`
	Defence                       int64   `protobuf:"varint,7,opt,name=Defence,proto3" json:"Defence,omitempty"`
	DodgeRate                     float32 `protobuf:"fixed32,8,opt,name=DodgeRate,proto3" json:"DodgeRate,omitempty"`
	Strength                      float64 `protobuf:"fixed64,9,opt,name=Strength,proto3" json:"Strength,omitempty"`
	Agility                       float64 `protobuf:"fixed64,10,opt,name=Agility,proto3" json:"Agility,omitempty"`
	Intelligence                  float64 `protobuf:"fixed64,11,opt,name=Intelligence,proto3" json:"Intelligence,omitempty"`
	Vitality                      float64 `protobuf:"fixed64,12,opt,name=Vitality,proto3" json:"Vitality,omitempty"`
	SkillPowerLimit               int32   `protobuf:"varint,13,opt,name=SkillPowerLimit,proto3" json:"SkillPowerLimit,omitempty"`
	RecoverUltimateSkillPowerRate float32 `protobuf:"fixed32,14,opt,name=RecoverUltimateSkillPowerRate,proto3" json:"RecoverUltimateSkillPowerRate,omitempty"`
	Lucky                         int32   `protobuf:"varint,15,opt,name=Lucky,proto3" json:"Lucky,omitempty"`
	CritRate                      float32 `protobuf:"fixed32,16,opt,name=CritRate,proto3" json:"CritRate,omitempty"`
	CritDamageRate                float32 `protobuf:"fixed32,17,opt,name=CritDamageRate,proto3" json:"CritDamageRate,omitempty"`
	BlockRate                     float32 `protobuf:"fixed32,18,opt,name=BlockRate,proto3" json:"BlockRate,omitempty"`
	BlockValue                    int64   `protobuf:"varint,19,opt,name=BlockValue,proto3" json:"BlockValue,omitempty"`
	BeDamageNormalDeduct          int64   `protobuf:"varint,20,opt,name=BeDamageNormalDeduct,proto3" json:"BeDamageNormalDeduct,omitempty"`
	ResistancePoison              float32 `protobuf:"fixed32,21,opt,name=ResistancePoison,proto3" json:"ResistancePoison,omitempty"`
	ResistanceFire                float32 `protobuf:"fixed32,22,opt,name=ResistanceFire,proto3" json:"ResistanceFire,omitempty"`
	ResistanceCold                float32 `protobuf:"fixed32,23,opt,name=ResistanceCold,proto3" json:"ResistanceCold,omitempty"`
	ResistanceLightning           float32 `protobuf:"fixed32,24,opt,name=ResistanceLightning,proto3" json:"ResistanceLightning,omitempty"`
	AttackScore                   int32   `protobuf:"varint,25,opt,name=AttackScore,proto3" json:"AttackScore,omitempty"`
	DefenceScore                  int32   `protobuf:"varint,26,opt,name=DefenceScore,proto3" json:"DefenceScore,omitempty"`
	PsychokinesisScore            int32   `protobuf:"varint,27,opt,name=PsychokinesisScore,proto3" json:"PsychokinesisScore,omitempty"`
	TotalScore                    int32   `protobuf:"varint,28,opt,name=TotalScore,proto3" json:"TotalScore,omitempty"`
}

func (m *FightAttr) Reset()         { *m = FightAttr{} }
func (m *FightAttr) String() string { return proto.CompactTextString(m) }
func (*FightAttr) ProtoMessage()    {}
func (*FightAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{6}
}
func (m *FightAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightAttr.Merge(m, src)
}
func (m *FightAttr) XXX_Size() int {
	return m.Size()
}
func (m *FightAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_FightAttr.DiscardUnknown(m)
}

var xxx_messageInfo_FightAttr proto.InternalMessageInfo

func (m *FightAttr) GetMaxHP() int64 {
	if m != nil {
		return m.MaxHP
	}
	return 0
}

func (m *FightAttr) GetRecoverHP() int64 {
	if m != nil {
		return m.RecoverHP
	}
	return 0
}

func (m *FightAttr) GetAttack() int64 {
	if m != nil {
		return m.Attack
	}
	return 0
}

func (m *FightAttr) GetHitRate() float32 {
	if m != nil {
		return m.HitRate
	}
	return 0
}

func (m *FightAttr) GetAttackLucky() float32 {
	if m != nil {
		return m.AttackLucky
	}
	return 0
}

func (m *FightAttr) GetNormalAttackSpeed() float32 {
	if m != nil {
		return m.NormalAttackSpeed
	}
	return 0
}

func (m *FightAttr) GetDefence() int64 {
	if m != nil {
		return m.Defence
	}
	return 0
}

func (m *FightAttr) GetDodgeRate() float32 {
	if m != nil {
		return m.DodgeRate
	}
	return 0
}

func (m *FightAttr) GetStrength() float64 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *FightAttr) GetAgility() float64 {
	if m != nil {
		return m.Agility
	}
	return 0
}

func (m *FightAttr) GetIntelligence() float64 {
	if m != nil {
		return m.Intelligence
	}
	return 0
}

func (m *FightAttr) GetVitality() float64 {
	if m != nil {
		return m.Vitality
	}
	return 0
}

func (m *FightAttr) GetSkillPowerLimit() int32 {
	if m != nil {
		return m.SkillPowerLimit
	}
	return 0
}

func (m *FightAttr) GetRecoverUltimateSkillPowerRate() float32 {
	if m != nil {
		return m.RecoverUltimateSkillPowerRate
	}
	return 0
}

func (m *FightAttr) GetLucky() int32 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func (m *FightAttr) GetCritRate() float32 {
	if m != nil {
		return m.CritRate
	}
	return 0
}

func (m *FightAttr) GetCritDamageRate() float32 {
	if m != nil {
		return m.CritDamageRate
	}
	return 0
}

func (m *FightAttr) GetBlockRate() float32 {
	if m != nil {
		return m.BlockRate
	}
	return 0
}

func (m *FightAttr) GetBlockValue() int64 {
	if m != nil {
		return m.BlockValue
	}
	return 0
}

func (m *FightAttr) GetBeDamageNormalDeduct() int64 {
	if m != nil {
		return m.BeDamageNormalDeduct
	}
	return 0
}

func (m *FightAttr) GetResistancePoison() float32 {
	if m != nil {
		return m.ResistancePoison
	}
	return 0
}

func (m *FightAttr) GetResistanceFire() float32 {
	if m != nil {
		return m.ResistanceFire
	}
	return 0
}

func (m *FightAttr) GetResistanceCold() float32 {
	if m != nil {
		return m.ResistanceCold
	}
	return 0
}

func (m *FightAttr) GetResistanceLightning() float32 {
	if m != nil {
		return m.ResistanceLightning
	}
	return 0
}

func (m *FightAttr) GetAttackScore() int32 {
	if m != nil {
		return m.AttackScore
	}
	return 0
}

func (m *FightAttr) GetDefenceScore() int32 {
	if m != nil {
		return m.DefenceScore
	}
	return 0
}

func (m *FightAttr) GetPsychokinesisScore() int32 {
	if m != nil {
		return m.PsychokinesisScore
	}
	return 0
}

func (m *FightAttr) GetTotalScore() int32 {
	if m != nil {
		return m.TotalScore
	}
	return 0
}

// TalentData 天赋类型
type TalentData struct {
	Unlock bool   `protobuf:"varint,1,opt,name=Unlock,proto3" json:"Unlock,omitempty"`
	Level  uint32 `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	Study  bool   `protobuf:"varint,3,opt,name=Study,proto3" json:"Study,omitempty"`
	GiveUp bool   `protobuf:"varint,5,opt,name=GiveUp,proto3" json:"GiveUp,omitempty"`
}

func (m *TalentData) Reset()         { *m = TalentData{} }
func (m *TalentData) String() string { return proto.CompactTextString(m) }
func (*TalentData) ProtoMessage()    {}
func (*TalentData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9051cee989002594, []int{7}
}
func (m *TalentData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TalentData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TalentData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TalentData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TalentData.Merge(m, src)
}
func (m *TalentData) XXX_Size() int {
	return m.Size()
}
func (m *TalentData) XXX_DiscardUnknown() {
	xxx_messageInfo_TalentData.DiscardUnknown(m)
}

var xxx_messageInfo_TalentData proto.InternalMessageInfo

func (m *TalentData) GetUnlock() bool {
	if m != nil {
		return m.Unlock
	}
	return false
}

func (m *TalentData) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *TalentData) GetStudy() bool {
	if m != nil {
		return m.Study
	}
	return false
}

func (m *TalentData) GetGiveUp() bool {
	if m != nil {
		return m.GiveUp
	}
	return false
}

func init() {
	proto.RegisterType((*SpecialAgent)(nil), "SpecialAgent")
	proto.RegisterType((*SpecialAgentBase)(nil), "SpecialAgentBase")
	proto.RegisterType((*SpecialAgentTalent)(nil), "SpecialAgentTalent")
	proto.RegisterMapType((map[uint32]*TalentData)(nil), "SpecialAgentTalent.TalentMapEntry")
	proto.RegisterType((*BuildData)(nil), "BuildData")
	proto.RegisterMapType((map[int32]string)(nil), "BuildData.EquipmentMapEntry")
	proto.RegisterType((*BuildSkillData)(nil), "BuildSkillData")
	proto.RegisterMapType((map[uint32]uint32)(nil), "BuildSkillData.SuperSkillEntry")
	proto.RegisterType((*SkillData)(nil), "SkillData")
	proto.RegisterType((*FightAttr)(nil), "FightAttr")
	proto.RegisterType((*TalentData)(nil), "TalentData")
}

func init() { proto.RegisterFile("SpecialAgentDef.proto", fileDescriptor_9051cee989002594) }

var fileDescriptor_9051cee989002594 = []byte{
	// 959 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0x41, 0x6f, 0xe2, 0x46,
	0x14, 0x8e, 0x21, 0x24, 0xf8, 0x91, 0x90, 0x64, 0xc2, 0x6e, 0x5d, 0x9a, 0xb2, 0x14, 0x69, 0x2b,
	0xd4, 0x56, 0x56, 0x95, 0x5e, 0xaa, 0x4a, 0xab, 0xdd, 0x10, 0x67, 0x37, 0x91, 0xc8, 0x0a, 0x0d,
	0xc9, 0x1e, 0x7a, 0x9b, 0x35, 0x13, 0x32, 0xc2, 0xd8, 0xd4, 0x0c, 0x74, 0xf9, 0x17, 0xfd, 0x3d,
	0xbd, 0xf6, 0xd2, 0x63, 0x2e, 0x95, 0x7a, 0xac, 0x92, 0x1f, 0xd0, 0xbf, 0x50, 0xcd, 0x1b, 0x63,
	0x8f, 0x01, 0xf5, 0x36, 0xdf, 0xf7, 0xbe, 0x79, 0xef, 0xcd, 0x37, 0x6f, 0x0c, 0xf0, 0xac, 0x3f,
	0xe1, 0xbe, 0x60, 0xc1, 0xd9, 0x90, 0x87, 0xd2, 0xe3, 0x77, 0xee, 0x24, 0x8e, 0x64, 0xd4, 0xfa,
	0x08, 0x7b, 0x66, 0x80, 0xbc, 0x84, 0xed, 0x0e, 0x9b, 0x72, 0xc7, 0x6a, 0x5a, 0xed, 0xca, 0xe9,
	0x91, 0x6b, 0x06, 0x55, 0x80, 0x62, 0x98, 0x7c, 0x0b, 0x3b, 0x37, 0x2c, 0xe0, 0xa1, 0x74, 0x0a,
	0x28, 0x3c, 0xce, 0x09, 0x75, 0x88, 0x26, 0x92, 0x56, 0x0c, 0x87, 0xab, 0x69, 0x48, 0x1d, 0xca,
	0xe7, 0x51, 0x78, 0x27, 0x86, 0x57, 0x1e, 0xd6, 0xda, 0xa7, 0x29, 0x26, 0x87, 0x50, 0xbc, 0xf8,
	0x34, 0xc1, 0xcc, 0xdb, 0x54, 0x2d, 0x49, 0x0d, 0x4a, 0x5d, 0x3e, 0xe7, 0x81, 0x53, 0x44, 0xa9,
	0x06, 0x2a, 0xc7, 0x3b, 0x26, 0xc2, 0x1b, 0x31, 0xe6, 0xce, 0x76, 0xd3, 0x6a, 0x17, 0x69, 0x8a,
	0x5b, 0x7f, 0x58, 0x40, 0xd6, 0x5b, 0x22, 0x4d, 0xa8, 0xe8, 0x55, 0x2f, 0x12, 0xa1, 0x4c, 0x2a,
	0x9b, 0x14, 0x79, 0x03, 0xb6, 0x86, 0xd7, 0x4c, 0xb5, 0x50, 0x6c, 0x57, 0x4e, 0x5b, 0x1b, 0x0e,
	0xe7, 0xa6, 0xa2, 0x8b, 0x50, 0xc6, 0x0b, 0x9a, 0x6d, 0xaa, 0x5f, 0x41, 0x35, 0x1f, 0x54, 0x07,
	0x1a, 0xf1, 0x45, 0x52, 0x4d, 0x2d, 0xc9, 0x57, 0x50, 0x9a, 0xb3, 0x60, 0xc6, 0x13, 0xfb, 0x2a,
	0x49, 0x3a, 0x8f, 0x49, 0x46, 0x75, 0xe4, 0xa7, 0xc2, 0x8f, 0x56, 0xeb, 0xaf, 0x02, 0xd8, 0x9d,
	0x99, 0x08, 0x06, 0x2a, 0x40, 0x1c, 0xd8, 0x45, 0x90, 0x58, 0x66, 0xd3, 0x25, 0x24, 0x04, 0xb6,
	0xdf, 0xb3, 0xb1, 0xce, 0x66, 0x53, 0x5c, 0x93, 0xaf, 0xa1, 0x6a, 0xb6, 0x7d, 0xe5, 0x25, 0xe6,
	0xad, 0xb0, 0xe4, 0x25, 0x94, 0xfa, 0x23, 0x11, 0x04, 0x68, 0x61, 0xe5, 0xf4, 0xc0, 0xc5, 0xa4,
	0x48, 0xe9, 0x76, 0x70, 0x49, 0xde, 0xc0, 0xde, 0xc5, 0x2f, 0x33, 0x31, 0x19, 0x27, 0xd6, 0x94,
	0xd0, 0x9a, 0x13, 0x37, 0x6d, 0xcf, 0x35, 0xc3, 0xda, 0x94, 0xdc, 0x0e, 0xd2, 0x00, 0x38, 0x8f,
	0x39, 0x93, 0x1c, 0x2f, 0x6c, 0x07, 0x2f, 0xcc, 0x60, 0x48, 0x1b, 0xec, 0xb7, 0x62, 0x78, 0x2f,
	0xcf, 0xa4, 0x8c, 0x9d, 0x5d, 0x6c, 0x06, 0xdc, 0x94, 0xa1, 0x59, 0xb0, 0xfe, 0x1a, 0x8e, 0xd6,
	0x8a, 0x99, 0x26, 0x97, 0xb4, 0xc9, 0x35, 0xd3, 0x64, 0xdb, 0xf4, 0xf5, 0x77, 0x0b, 0xaa, 0xf9,
	0x63, 0x92, 0x36, 0x1c, 0xdc, 0x06, 0x52, 0x8c, 0x99, 0xe4, 0x48, 0xa6, 0x73, 0xb9, 0x4a, 0x93,
	0xd7, 0x00, 0xfd, 0xd9, 0x84, 0xc7, 0xda, 0x35, 0x3d, 0x22, 0x2f, 0x56, 0x5c, 0x73, 0x33, 0x85,
	0xb6, 0xc2, 0xd8, 0x52, 0x7f, 0x05, 0x07, 0x2b, 0xe1, 0x0d, 0x13, 0x92, 0x6b, 0x7e, 0xdf, 0x6c,
	0xfe, 0x15, 0xd8, 0x59, 0xdb, 0x4d, 0xa8, 0x20, 0xb8, 0x66, 0x22, 0x4c, 0x5b, 0x36, 0x29, 0x52,
	0x85, 0x42, 0x77, 0x9e, 0x64, 0x29, 0x74, 0xe7, 0xad, 0x7f, 0x77, 0x0d, 0x9f, 0x55, 0x99, 0x6b,
	0xf6, 0xe9, 0xb2, 0x87, 0x3b, 0x8b, 0x54, 0x03, 0x72, 0x02, 0x36, 0xe5, 0x7e, 0x34, 0xe7, 0xf1,
	0x65, 0x0f, 0xb7, 0x16, 0x69, 0x46, 0x90, 0xe7, 0xb0, 0x73, 0x26, 0x25, 0xf3, 0x47, 0x38, 0x51,
	0x45, 0x9a, 0x20, 0x35, 0x9f, 0x97, 0x42, 0x52, 0x26, 0xf5, 0x73, 0x2c, 0xd0, 0x25, 0x54, 0x5d,
	0x6a, 0x4d, 0x77, 0xe6, 0x8f, 0x16, 0x4e, 0x09, 0xa3, 0x26, 0x45, 0xbe, 0x83, 0xa3, 0xf7, 0x51,
	0x3c, 0x66, 0x81, 0x26, 0xfb, 0x13, 0xce, 0x07, 0x38, 0x23, 0x05, 0xba, 0x1e, 0x50, 0x95, 0x3c,
	0x7e, 0xc7, 0x43, 0x9f, 0xe3, 0xa0, 0x14, 0xe9, 0x12, 0xaa, 0xce, 0xbd, 0x68, 0x30, 0xe4, 0xd8,
	0x45, 0x19, 0xf7, 0x67, 0x84, 0xfa, 0x62, 0xf4, 0x65, 0xcc, 0xc3, 0xa1, 0xbc, 0x77, 0xec, 0xa6,
	0xd5, 0xb6, 0x68, 0x8a, 0x55, 0xce, 0xb3, 0xa1, 0x08, 0x84, 0x5c, 0x38, 0x80, 0xa1, 0x25, 0x24,
	0x2d, 0xd8, 0xbb, 0x0a, 0x25, 0x0f, 0x02, 0x31, 0xc4, 0x92, 0x15, 0x0c, 0xe7, 0x38, 0x95, 0xf9,
	0x83, 0x90, 0x0c, 0xb7, 0xef, 0xe9, 0xcc, 0x4b, 0xac, 0x46, 0x0b, 0x2f, 0xa4, 0x17, 0xfd, 0xca,
	0xe3, 0xae, 0x18, 0x0b, 0xe9, 0xec, 0xe3, 0x94, 0xae, 0xd2, 0xc4, 0x83, 0x2f, 0x13, 0x9b, 0x73,
	0x43, 0x87, 0x0a, 0x3c, 0x51, 0x15, 0x4f, 0xf4, 0xff, 0x22, 0xfc, 0x5a, 0xa2, 0xcf, 0x07, 0x58,
	0x45, 0x03, 0xfc, 0xe2, 0xc6, 0xc9, 0xf5, 0x1c, 0x62, 0x9a, 0x14, 0xab, 0x6f, 0x85, 0x5a, 0x7b,
	0x6c, 0xcc, 0x12, 0xeb, 0x8e, 0x50, 0xb1, 0xc2, 0x2a, 0x77, 0x3b, 0x41, 0xe4, 0x8f, 0x50, 0x42,
	0xb4, 0xbb, 0x29, 0xa1, 0x1e, 0x38, 0x82, 0x0f, 0x38, 0xb7, 0xc7, 0xfa, 0x81, 0x67, 0x0c, 0x39,
	0x85, 0x5a, 0x87, 0xeb, 0x6c, 0xfa, 0x4a, 0x3d, 0x3e, 0x98, 0xf9, 0xd2, 0xa9, 0xa1, 0x72, 0x63,
	0x8c, 0x7c, 0x03, 0x87, 0x94, 0x4f, 0xc5, 0x54, 0xb2, 0xd0, 0xe7, 0xbd, 0x48, 0x4c, 0xa3, 0xd0,
	0x79, 0x86, 0x85, 0xd7, 0x78, 0x75, 0x8a, 0x8c, 0x7b, 0x2b, 0x62, 0xee, 0x3c, 0xd7, 0xa7, 0xc8,
	0xb3, 0x79, 0xdd, 0x79, 0x14, 0x0c, 0x9c, 0xcf, 0x56, 0x75, 0x8a, 0x25, 0xdf, 0xc3, 0x71, 0xc6,
	0x74, 0xd5, 0x93, 0x09, 0x45, 0x38, 0x74, 0x1c, 0x14, 0x6f, 0x0a, 0x65, 0x73, 0xde, 0xf7, 0xa3,
	0x98, 0x3b, 0x9f, 0xa3, 0xff, 0x26, 0xa5, 0x66, 0x29, 0x19, 0x55, 0x2d, 0xa9, 0xa3, 0x24, 0xc7,
	0x11, 0x17, 0x48, 0x6f, 0xba, 0xf0, 0xef, 0xa3, 0x91, 0x08, 0x55, 0x11, 0xad, 0xfc, 0x02, 0x95,
	0x1b, 0x22, 0xca, 0xf7, 0x9b, 0x48, 0xb2, 0x40, 0xeb, 0x4e, 0x50, 0x67, 0x30, 0xad, 0x7b, 0x80,
	0xec, 0xe7, 0x45, 0xbd, 0xde, 0xdb, 0x50, 0x5d, 0x0a, 0x3e, 0xf9, 0x32, 0x4d, 0x50, 0xf6, 0x1b,
	0x5b, 0x30, 0x7f, 0x63, 0x6b, 0x50, 0xea, 0xcb, 0xd9, 0x60, 0x81, 0x4f, 0xbd, 0x4c, 0x35, 0x50,
	0x39, 0xde, 0x89, 0x39, 0xbf, 0x9d, 0xe0, 0x53, 0x2e, 0xd3, 0x04, 0x75, 0x5e, 0xfc, 0xf9, 0xd8,
	0xb0, 0x1e, 0x1e, 0x1b, 0xd6, 0x3f, 0x8f, 0x0d, 0xeb, 0xb7, 0xa7, 0xc6, 0xd6, 0xc3, 0x53, 0x63,
	0xeb, 0xef, 0xa7, 0xc6, 0xd6, 0xcf, 0xa5, 0x9e, 0xfa, 0xbb, 0xf1, 0x71, 0x07, 0xff, 0x75, 0xfc,
	0xf0, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xdb, 0x5f, 0x91, 0x8e, 0x08, 0x00, 0x00,
}

func (m *SpecialAgent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialAgent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialAgent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Talent != nil {
		{
			size, err := m.Talent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecialAgentBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialAgentBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialAgentBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GainTime != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.GainTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Exp != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x10
	}
	if m.ConfigID != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.ConfigID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpecialAgentTalent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecialAgentTalent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecialAgentTalent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TalentMap) > 0 {
		for k := range m.TalentMap {
			v := m.TalentMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSpecialAgentDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TalentPoint != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.TalentPoint))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuildData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FightAttr != nil {
		{
			size, err := m.FightAttr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CreateTime != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EquipmentMap) > 0 {
		for k := range m.EquipmentMap {
			v := m.EquipmentMap[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Skill != nil {
		{
			size, err := m.Skill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SpecialAgentID != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.SpecialAgentID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BuildID) > 0 {
		i -= len(m.BuildID)
		copy(dAtA[i:], m.BuildID)
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(len(m.BuildID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildSkillData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildSkillData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildSkillData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SuperSkill) > 0 {
		for k := range m.SuperSkill {
			v := m.SuperSkill[k]
			baseI := i
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSpecialAgentDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.UltimateSkillID != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.UltimateSkillID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lv != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Lv))
		i--
		dAtA[i] = 0x10
	}
	if m.SkillMainID != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.SkillMainID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FightAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalScore != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.TotalScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.PsychokinesisScore != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.PsychokinesisScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.DefenceScore != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.DefenceScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.AttackScore != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.AttackScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.ResistanceLightning != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceLightning))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if m.ResistanceCold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceCold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.ResistanceFire != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceFire))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.ResistancePoison != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistancePoison))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.BeDamageNormalDeduct != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.BeDamageNormalDeduct))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.BlockValue != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.BlockValue))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.BlockRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BlockRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.CritDamageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CritDamageRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.CritRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CritRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.Lucky != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Lucky))
		i--
		dAtA[i] = 0x78
	}
	if m.RecoverUltimateSkillPowerRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RecoverUltimateSkillPowerRate))))
		i--
		dAtA[i] = 0x75
	}
	if m.SkillPowerLimit != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.SkillPowerLimit))
		i--
		dAtA[i] = 0x68
	}
	if m.Vitality != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Vitality))))
		i--
		dAtA[i] = 0x61
	}
	if m.Intelligence != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Intelligence))))
		i--
		dAtA[i] = 0x59
	}
	if m.Agility != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Agility))))
		i--
		dAtA[i] = 0x51
	}
	if m.Strength != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Strength))))
		i--
		dAtA[i] = 0x49
	}
	if m.DodgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DodgeRate))))
		i--
		dAtA[i] = 0x45
	}
	if m.Defence != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Defence))
		i--
		dAtA[i] = 0x38
	}
	if m.NormalAttackSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NormalAttackSpeed))))
		i--
		dAtA[i] = 0x35
	}
	if m.AttackLucky != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackLucky))))
		i--
		dAtA[i] = 0x2d
	}
	if m.HitRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HitRate))))
		i--
		dAtA[i] = 0x25
	}
	if m.Attack != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Attack))
		i--
		dAtA[i] = 0x18
	}
	if m.RecoverHP != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.RecoverHP))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxHP != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.MaxHP))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TalentData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TalentData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TalentData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GiveUp {
		i--
		if m.GiveUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Study {
		i--
		if m.Study {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintSpecialAgentDef(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Unlock {
		i--
		if m.Unlock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpecialAgentDef(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpecialAgentDef(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SpecialAgent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	if m.Talent != nil {
		l = m.Talent.Size()
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	return n
}

func (m *SpecialAgentBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigID != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.ConfigID))
	}
	if m.Exp != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Exp))
	}
	if m.Level != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Level))
	}
	if m.GainTime != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.GainTime))
	}
	return n
}

func (m *SpecialAgentTalent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TalentPoint != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.TalentPoint))
	}
	if len(m.TalentMap) > 0 {
		for k, v := range m.TalentMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpecialAgentDef(uint64(l))
			}
			mapEntrySize := 1 + sovSpecialAgentDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovSpecialAgentDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BuildData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildID)
	if l > 0 {
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	if m.SpecialAgentID != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.SpecialAgentID))
	}
	if m.Skill != nil {
		l = m.Skill.Size()
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	if len(m.EquipmentMap) > 0 {
		for k, v := range m.EquipmentMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpecialAgentDef(uint64(k)) + 1 + len(v) + sovSpecialAgentDef(uint64(len(v)))
			n += mapEntrySize + 1 + sovSpecialAgentDef(uint64(mapEntrySize))
		}
	}
	if m.CreateTime != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.CreateTime))
	}
	if m.FightAttr != nil {
		l = m.FightAttr.Size()
		n += 1 + l + sovSpecialAgentDef(uint64(l))
	}
	return n
}

func (m *BuildSkillData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UltimateSkillID != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.UltimateSkillID))
	}
	if len(m.SuperSkill) > 0 {
		for k, v := range m.SuperSkill {
			_ = k
			_ = v
			mapEntrySize := 1 + sovSpecialAgentDef(uint64(k)) + 1 + sovSpecialAgentDef(uint64(v))
			n += mapEntrySize + 1 + sovSpecialAgentDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SkillData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SkillMainID != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.SkillMainID))
	}
	if m.Lv != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Lv))
	}
	return n
}

func (m *FightAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxHP != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.MaxHP))
	}
	if m.RecoverHP != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.RecoverHP))
	}
	if m.Attack != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Attack))
	}
	if m.HitRate != 0 {
		n += 5
	}
	if m.AttackLucky != 0 {
		n += 5
	}
	if m.NormalAttackSpeed != 0 {
		n += 5
	}
	if m.Defence != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Defence))
	}
	if m.DodgeRate != 0 {
		n += 5
	}
	if m.Strength != 0 {
		n += 9
	}
	if m.Agility != 0 {
		n += 9
	}
	if m.Intelligence != 0 {
		n += 9
	}
	if m.Vitality != 0 {
		n += 9
	}
	if m.SkillPowerLimit != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.SkillPowerLimit))
	}
	if m.RecoverUltimateSkillPowerRate != 0 {
		n += 5
	}
	if m.Lucky != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Lucky))
	}
	if m.CritRate != 0 {
		n += 6
	}
	if m.CritDamageRate != 0 {
		n += 6
	}
	if m.BlockRate != 0 {
		n += 6
	}
	if m.BlockValue != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.BlockValue))
	}
	if m.BeDamageNormalDeduct != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.BeDamageNormalDeduct))
	}
	if m.ResistancePoison != 0 {
		n += 6
	}
	if m.ResistanceFire != 0 {
		n += 6
	}
	if m.ResistanceCold != 0 {
		n += 6
	}
	if m.ResistanceLightning != 0 {
		n += 6
	}
	if m.AttackScore != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.AttackScore))
	}
	if m.DefenceScore != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.DefenceScore))
	}
	if m.PsychokinesisScore != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.PsychokinesisScore))
	}
	if m.TotalScore != 0 {
		n += 2 + sovSpecialAgentDef(uint64(m.TotalScore))
	}
	return n
}

func (m *TalentData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unlock {
		n += 2
	}
	if m.Level != 0 {
		n += 1 + sovSpecialAgentDef(uint64(m.Level))
	}
	if m.Study {
		n += 2
	}
	if m.GiveUp {
		n += 2
	}
	return n
}

func sovSpecialAgentDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpecialAgentDef(x uint64) (n int) {
	return sovSpecialAgentDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SpecialAgent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialAgent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialAgent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &SpecialAgentBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Talent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Talent == nil {
				m.Talent = &SpecialAgentTalent{}
			}
			if err := m.Talent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialAgentBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialAgentBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialAgentBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigID", wireType)
			}
			m.ConfigID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GainTime", wireType)
			}
			m.GainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GainTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecialAgentTalent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecialAgentTalent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecialAgentTalent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentPoint", wireType)
			}
			m.TalentPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TalentPoint |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TalentMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TalentMap == nil {
				m.TalentMap = make(map[uint32]*TalentData)
			}
			var mapkey uint32
			var mapvalue *TalentData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecialAgentDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TalentData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TalentMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialAgentID", wireType)
			}
			m.SpecialAgentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialAgentID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Skill == nil {
				m.Skill = &BuildSkillData{}
			}
			if err := m.Skill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipmentMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EquipmentMap == nil {
				m.EquipmentMap = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecialAgentDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EquipmentMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FightAttr == nil {
				m.FightAttr = &FightAttr{}
			}
			if err := m.FightAttr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildSkillData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildSkillData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildSkillData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UltimateSkillID", wireType)
			}
			m.UltimateSkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UltimateSkillID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SuperSkill == nil {
				m.SuperSkill = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpecialAgentDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpecialAgentDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSpecialAgentDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SuperSkill[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillMainID", wireType)
			}
			m.SkillMainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillMainID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lv", wireType)
			}
			m.Lv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lv |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHP", wireType)
			}
			m.MaxHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverHP", wireType)
			}
			m.RecoverHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			m.Attack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attack |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HitRate = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLucky", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackLucky = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalAttackSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NormalAttackSpeed = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defence", wireType)
			}
			m.Defence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Defence |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DodgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DodgeRate = float32(math.Float32frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Strength = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agility", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Agility = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intelligence", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Intelligence = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vitality", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Vitality = float64(math.Float64frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPowerLimit", wireType)
			}
			m.SkillPowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillPowerLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverUltimateSkillPowerRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RecoverUltimateSkillPowerRate = float32(math.Float32frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CritRate = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritDamageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CritDamageRate = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BlockRate = float32(math.Float32frombits(v))
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockValue", wireType)
			}
			m.BlockValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageNormalDeduct", wireType)
			}
			m.BeDamageNormalDeduct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeDamageNormalDeduct |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistancePoison", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistancePoison = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceFire", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceFire = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceCold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceCold = float32(math.Float32frombits(v))
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceLightning", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceLightning = float32(math.Float32frombits(v))
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackScore", wireType)
			}
			m.AttackScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefenceScore", wireType)
			}
			m.DefenceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefenceScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PsychokinesisScore", wireType)
			}
			m.PsychokinesisScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PsychokinesisScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScore", wireType)
			}
			m.TotalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TalentData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TalentData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TalentData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unlock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unlock = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Study", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Study = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GiveUp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpecialAgentDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpecialAgentDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpecialAgentDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpecialAgentDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpecialAgentDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpecialAgentDef
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpecialAgentDef
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpecialAgentDef
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpecialAgentDef        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpecialAgentDef          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpecialAgentDef = fmt.Errorf("proto: unexpected end of group")
)
