// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: FightDef.proto

package Proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PawnType_Enum int32

const (
	PawnType_Role PawnType_Enum = 0
	PawnType_Npc  PawnType_Enum = 1
	PawnType_BG   PawnType_Enum = 2
)

var PawnType_Enum_name = map[int32]string{
	0: "Role",
	1: "Npc",
	2: "BG",
}

var PawnType_Enum_value = map[string]int32{
	"Role": 0,
	"Npc":  1,
	"BG":   2,
}

func (x PawnType_Enum) String() string {
	return proto.EnumName(PawnType_Enum_name, int32(x))
}

func (PawnType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{0, 0}
}

type Camp_Enum int32

const (
	Camp_Red  Camp_Enum = 0
	Camp_Blue Camp_Enum = 1
)

var Camp_Enum_name = map[int32]string{
	0: "Red",
	1: "Blue",
}

var Camp_Enum_value = map[string]int32{
	"Red":  0,
	"Blue": 1,
}

func (x Camp_Enum) String() string {
	return proto.EnumName(Camp_Enum_name, int32(x))
}

func (Camp_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{1, 0}
}

type ActionType_Enum int32

const (
	ActionType_MoveBegin           ActionType_Enum = 0
	ActionType_FixMoveData         ActionType_Enum = 1
	ActionType_MoveEnd             ActionType_Enum = 2
	ActionType_UseSkill            ActionType_Enum = 3
	ActionType_BreakSkill          ActionType_Enum = 4
	ActionType_NewAttack           ActionType_Enum = 5
	ActionType_DelAttack           ActionType_Enum = 6
	ActionType_AttackHit           ActionType_Enum = 7
	ActionType_BeHit               ActionType_Enum = 8
	ActionType_AddBuff             ActionType_Enum = 9
	ActionType_RemoveBuff          ActionType_Enum = 10
	ActionType_ChangeAttr          ActionType_Enum = 11
	ActionType_ChangeStat          ActionType_Enum = 12
	ActionType_FightBegin          ActionType_Enum = 13
	ActionType_FightEnd            ActionType_Enum = 14
	ActionType_DebugInfo           ActionType_Enum = 15
	ActionType_ChangeSkillState    ActionType_Enum = 16
	ActionType_CombineSkillEndTime ActionType_Enum = 17
	ActionType_CombineSkillPoint   ActionType_Enum = 18
	ActionType_SetTarget           ActionType_Enum = 19
	ActionType_AttackShowAoe       ActionType_Enum = 20
	ActionType_AttackMoveAoe       ActionType_Enum = 21
	ActionType_SummonPawn          ActionType_Enum = 22
)

var ActionType_Enum_name = map[int32]string{
	0:  "MoveBegin",
	1:  "FixMoveData",
	2:  "MoveEnd",
	3:  "UseSkill",
	4:  "BreakSkill",
	5:  "NewAttack",
	6:  "DelAttack",
	7:  "AttackHit",
	8:  "BeHit",
	9:  "AddBuff",
	10: "RemoveBuff",
	11: "ChangeAttr",
	12: "ChangeStat",
	13: "FightBegin",
	14: "FightEnd",
	15: "DebugInfo",
	16: "ChangeSkillState",
	17: "CombineSkillEndTime",
	18: "CombineSkillPoint",
	19: "SetTarget",
	20: "AttackShowAoe",
	21: "AttackMoveAoe",
	22: "SummonPawn",
}

var ActionType_Enum_value = map[string]int32{
	"MoveBegin":           0,
	"FixMoveData":         1,
	"MoveEnd":             2,
	"UseSkill":            3,
	"BreakSkill":          4,
	"NewAttack":           5,
	"DelAttack":           6,
	"AttackHit":           7,
	"BeHit":               8,
	"AddBuff":             9,
	"RemoveBuff":          10,
	"ChangeAttr":          11,
	"ChangeStat":          12,
	"FightBegin":          13,
	"FightEnd":            14,
	"DebugInfo":           15,
	"ChangeSkillState":    16,
	"CombineSkillEndTime": 17,
	"CombineSkillPoint":   18,
	"SetTarget":           19,
	"AttackShowAoe":       20,
	"AttackMoveAoe":       21,
	"SummonPawn":          22,
}

func (x ActionType_Enum) String() string {
	return proto.EnumName(ActionType_Enum_name, int32(x))
}

func (ActionType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{2, 0}
}

type AttrType_Enum int32

const (
	AttrType_CurHP              AttrType_Enum = 0
	AttrType_MaxHP              AttrType_Enum = 1
	AttrType_HPShield           AttrType_Enum = 2
	AttrType_UltimateSkillPower AttrType_Enum = 3
	AttrType_OverDrivePower     AttrType_Enum = 4
	AttrType_CurBlockBreakValue AttrType_Enum = 5
	AttrType_NormalAttackSpeed  AttrType_Enum = 6
	AttrType_Scale              AttrType_Enum = 7
	AttrType_CollisionRadius    AttrType_Enum = 8
)

var AttrType_Enum_name = map[int32]string{
	0: "CurHP",
	1: "MaxHP",
	2: "HPShield",
	3: "UltimateSkillPower",
	4: "OverDrivePower",
	5: "CurBlockBreakValue",
	6: "NormalAttackSpeed",
	7: "Scale",
	8: "CollisionRadius",
}

var AttrType_Enum_value = map[string]int32{
	"CurHP":              0,
	"MaxHP":              1,
	"HPShield":           2,
	"UltimateSkillPower": 3,
	"OverDrivePower":     4,
	"CurBlockBreakValue": 5,
	"NormalAttackSpeed":  6,
	"Scale":              7,
	"CollisionRadius":    8,
}

func (x AttrType_Enum) String() string {
	return proto.EnumName(AttrType_Enum_name, int32(x))
}

func (AttrType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{3, 0}
}

type StatType_Enum int32

const (
	StatType_Dead      StatType_Enum = 0
	StatType_OverDrive StatType_Enum = 1
	StatType_Break     StatType_Enum = 2
	StatType_Weak      StatType_Enum = 3
)

var StatType_Enum_name = map[int32]string{
	0: "Dead",
	1: "OverDrive",
	2: "Break",
	3: "Weak",
}

var StatType_Enum_value = map[string]int32{
	"Dead":      0,
	"OverDrive": 1,
	"Break":     2,
	"Weak":      3,
}

func (x StatType_Enum) String() string {
	return proto.EnumName(StatType_Enum_name, int32(x))
}

func (StatType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{4, 0}
}

type AttackSrc_Enum int32

const (
	AttackSrc_Skill  AttackSrc_Enum = 0
	AttackSrc_Buff   AttackSrc_Enum = 1
	AttackSrc_Custom AttackSrc_Enum = 2
)

var AttackSrc_Enum_name = map[int32]string{
	0: "Skill",
	1: "Buff",
	2: "Custom",
}

var AttackSrc_Enum_value = map[string]int32{
	"Skill":  0,
	"Buff":   1,
	"Custom": 2,
}

func (x AttackSrc_Enum) String() string {
	return proto.EnumName(AttackSrc_Enum_name, int32(x))
}

func (AttackSrc_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{5, 0}
}

type AttackShapeType_Enum int32

const (
	AttackShapeType_Rect   AttackShapeType_Enum = 0
	AttackShapeType_Circle AttackShapeType_Enum = 1
	AttackShapeType_Fan    AttackShapeType_Enum = 2
)

var AttackShapeType_Enum_name = map[int32]string{
	0: "Rect",
	1: "Circle",
	2: "Fan",
}

var AttackShapeType_Enum_value = map[string]int32{
	"Rect":   0,
	"Circle": 1,
	"Fan":    2,
}

func (x AttackShapeType_Enum) String() string {
	return proto.EnumName(AttackShapeType_Enum_name, int32(x))
}

func (AttackShapeType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{6, 0}
}

type DamageType_Enum int32

const (
	DamageType_Damage          DamageType_Enum = 0
	DamageType_RecoverHP       DamageType_Enum = 1
	DamageType_Crit            DamageType_Enum = 2
	DamageType_Dodge           DamageType_Enum = 3
	DamageType_Block           DamageType_Enum = 4
	DamageType_ExemptionDamage DamageType_Enum = 5
	DamageType_Miss            DamageType_Enum = 6
	DamageType_Invert          DamageType_Enum = 7
)

var DamageType_Enum_name = map[int32]string{
	0: "Damage",
	1: "RecoverHP",
	2: "Crit",
	3: "Dodge",
	4: "Block",
	5: "ExemptionDamage",
	6: "Miss",
	7: "Invert",
}

var DamageType_Enum_value = map[string]int32{
	"Damage":          0,
	"RecoverHP":       1,
	"Crit":            2,
	"Dodge":           3,
	"Block":           4,
	"ExemptionDamage": 5,
	"Miss":            6,
	"Invert":          7,
}

func (x DamageType_Enum) String() string {
	return proto.EnumName(DamageType_Enum_name, int32(x))
}

func (DamageType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{7, 0}
}

type MoveMode_Enum int32

const (
	MoveMode_None       MoveMode_Enum = 0
	MoveMode_Run        MoveMode_Enum = 1
	MoveMode_Fast       MoveMode_Enum = 2
	MoveMode_LookAt     MoveMode_Enum = 3
	MoveMode_LookAtBack MoveMode_Enum = 4
	MoveMode_HitBack    MoveMode_Enum = 5
	MoveMode_Dodge      MoveMode_Enum = 6
)

var MoveMode_Enum_name = map[int32]string{
	0: "None",
	1: "Run",
	2: "Fast",
	3: "LookAt",
	4: "LookAtBack",
	5: "HitBack",
	6: "Dodge",
}

var MoveMode_Enum_value = map[string]int32{
	"None":       0,
	"Run":        1,
	"Fast":       2,
	"LookAt":     3,
	"LookAtBack": 4,
	"HitBack":    5,
	"Dodge":      6,
}

func (x MoveMode_Enum) String() string {
	return proto.EnumName(MoveMode_Enum_name, int32(x))
}

func (MoveMode_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{8, 0}
}

type HitType_Enum int32

const (
	HitType_None       HitType_Enum = 0
	HitType_Hit        HitType_Enum = 1
	HitType_Broken     HitType_Enum = 2
	HitType_Down       HitType_Enum = 3
	HitType_Float      HitType_Enum = 4
	HitType_ReFloat    HitType_Enum = 5
	HitType_Stun       HitType_Enum = 6
	HitType_Block      HitType_Enum = 7
	HitType_BlockBreak HitType_Enum = 8
)

var HitType_Enum_name = map[int32]string{
	0: "None",
	1: "Hit",
	2: "Broken",
	3: "Down",
	4: "Float",
	5: "ReFloat",
	6: "Stun",
	7: "Block",
	8: "BlockBreak",
}

var HitType_Enum_value = map[string]int32{
	"None":       0,
	"Hit":        1,
	"Broken":     2,
	"Down":       3,
	"Float":      4,
	"ReFloat":    5,
	"Stun":       6,
	"Block":      7,
	"BlockBreak": 8,
}

func (x HitType_Enum) String() string {
	return proto.EnumName(HitType_Enum_name, int32(x))
}

func (HitType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{9, 0}
}

type SkillState_Enum int32

const (
	SkillState_Wait     SkillState_Enum = 0
	SkillState_Ready    SkillState_Enum = 1
	SkillState_ShowTime SkillState_Enum = 2
	SkillState_Dashing  SkillState_Enum = 3
	SkillState_Before   SkillState_Enum = 4
	SkillState_Attack   SkillState_Enum = 5
	SkillState_Later    SkillState_Enum = 6
)

var SkillState_Enum_name = map[int32]string{
	0: "Wait",
	1: "Ready",
	2: "ShowTime",
	3: "Dashing",
	4: "Before",
	5: "Attack",
	6: "Later",
}

var SkillState_Enum_value = map[string]int32{
	"Wait":     0,
	"Ready":    1,
	"ShowTime": 2,
	"Dashing":  3,
	"Before":   4,
	"Attack":   5,
	"Later":    6,
}

func (x SkillState_Enum) String() string {
	return proto.EnumName(SkillState_Enum_name, int32(x))
}

func (SkillState_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{10, 0}
}

type SkillBreakReason_Enum int32

const (
	SkillBreakReason_Normal  SkillBreakReason_Enum = 0
	SkillBreakReason_Combo   SkillBreakReason_Enum = 1
	SkillBreakReason_AIPause SkillBreakReason_Enum = 2
)

var SkillBreakReason_Enum_name = map[int32]string{
	0: "Normal",
	1: "Combo",
	2: "AIPause",
}

var SkillBreakReason_Enum_value = map[string]int32{
	"Normal":  0,
	"Combo":   1,
	"AIPause": 2,
}

func (x SkillBreakReason_Enum) String() string {
	return proto.EnumName(SkillBreakReason_Enum_name, int32(x))
}

func (SkillBreakReason_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{11, 0}
}

type SkillEndReason_Enum int32

const (
	SkillEndReason_Normal  SkillEndReason_Enum = 0
	SkillEndReason_Break   SkillEndReason_Enum = 1
	SkillEndReason_AIPause SkillEndReason_Enum = 2
	SkillEndReason_Combo   SkillEndReason_Enum = 3
)

var SkillEndReason_Enum_name = map[int32]string{
	0: "Normal",
	1: "Break",
	2: "AIPause",
	3: "Combo",
}

var SkillEndReason_Enum_value = map[string]int32{
	"Normal":  0,
	"Break":   1,
	"AIPause": 2,
	"Combo":   3,
}

func (x SkillEndReason_Enum) String() string {
	return proto.EnumName(SkillEndReason_Enum_name, int32(x))
}

func (SkillEndReason_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{12, 0}
}

type FightLogType_Enum int32

const (
	FightLogType_Simple     FightLogType_Enum = 0
	FightLogType_Detail     FightLogType_Enum = 1
	FightLogType_Programmer FightLogType_Enum = 2
)

var FightLogType_Enum_name = map[int32]string{
	0: "Simple",
	1: "Detail",
	2: "Programmer",
}

var FightLogType_Enum_value = map[string]int32{
	"Simple":     0,
	"Detail":     1,
	"Programmer": 2,
}

func (x FightLogType_Enum) String() string {
	return proto.EnumName(FightLogType_Enum_name, int32(x))
}

func (FightLogType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{13, 0}
}

type DamageFloatWordType_Enum int32

const (
	DamageFloatWordType_Normal       DamageFloatWordType_Enum = 0
	DamageFloatWordType_CombineSkill DamageFloatWordType_Enum = 1
)

var DamageFloatWordType_Enum_name = map[int32]string{
	0: "Normal",
	1: "CombineSkill",
}

var DamageFloatWordType_Enum_value = map[string]int32{
	"Normal":       0,
	"CombineSkill": 1,
}

func (x DamageFloatWordType_Enum) String() string {
	return proto.EnumName(DamageFloatWordType_Enum_name, int32(x))
}

func (DamageFloatWordType_Enum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{14, 0}
}

// 战斗对象类型
type PawnType struct {
}

func (m *PawnType) Reset()         { *m = PawnType{} }
func (m *PawnType) String() string { return proto.CompactTextString(m) }
func (*PawnType) ProtoMessage()    {}
func (*PawnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{0}
}
func (m *PawnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PawnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PawnType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PawnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PawnType.Merge(m, src)
}
func (m *PawnType) XXX_Size() int {
	return m.Size()
}
func (m *PawnType) XXX_DiscardUnknown() {
	xxx_messageInfo_PawnType.DiscardUnknown(m)
}

var xxx_messageInfo_PawnType proto.InternalMessageInfo

// 势力
type Camp struct {
}

func (m *Camp) Reset()         { *m = Camp{} }
func (m *Camp) String() string { return proto.CompactTextString(m) }
func (*Camp) ProtoMessage()    {}
func (*Camp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{1}
}
func (m *Camp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Camp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Camp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Camp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Camp.Merge(m, src)
}
func (m *Camp) XXX_Size() int {
	return m.Size()
}
func (m *Camp) XXX_DiscardUnknown() {
	xxx_messageInfo_Camp.DiscardUnknown(m)
}

var xxx_messageInfo_Camp proto.InternalMessageInfo

// 动作类型
type ActionType struct {
}

func (m *ActionType) Reset()         { *m = ActionType{} }
func (m *ActionType) String() string { return proto.CompactTextString(m) }
func (*ActionType) ProtoMessage()    {}
func (*ActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{2}
}
func (m *ActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionType.Merge(m, src)
}
func (m *ActionType) XXX_Size() int {
	return m.Size()
}
func (m *ActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ActionType proto.InternalMessageInfo

// 属性类型
type AttrType struct {
}

func (m *AttrType) Reset()         { *m = AttrType{} }
func (m *AttrType) String() string { return proto.CompactTextString(m) }
func (*AttrType) ProtoMessage()    {}
func (*AttrType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{3}
}
func (m *AttrType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrType.Merge(m, src)
}
func (m *AttrType) XXX_Size() int {
	return m.Size()
}
func (m *AttrType) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrType.DiscardUnknown(m)
}

var xxx_messageInfo_AttrType proto.InternalMessageInfo

// 状态类型
type StatType struct {
}

func (m *StatType) Reset()         { *m = StatType{} }
func (m *StatType) String() string { return proto.CompactTextString(m) }
func (*StatType) ProtoMessage()    {}
func (*StatType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{4}
}
func (m *StatType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatType.Merge(m, src)
}
func (m *StatType) XXX_Size() int {
	return m.Size()
}
func (m *StatType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatType.DiscardUnknown(m)
}

var xxx_messageInfo_StatType proto.InternalMessageInfo

// 伤害体来源
type AttackSrc struct {
}

func (m *AttackSrc) Reset()         { *m = AttackSrc{} }
func (m *AttackSrc) String() string { return proto.CompactTextString(m) }
func (*AttackSrc) ProtoMessage()    {}
func (*AttackSrc) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{5}
}
func (m *AttackSrc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackSrc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackSrc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackSrc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackSrc.Merge(m, src)
}
func (m *AttackSrc) XXX_Size() int {
	return m.Size()
}
func (m *AttackSrc) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackSrc.DiscardUnknown(m)
}

var xxx_messageInfo_AttackSrc proto.InternalMessageInfo

// 伤害体形状类型
type AttackShapeType struct {
}

func (m *AttackShapeType) Reset()         { *m = AttackShapeType{} }
func (m *AttackShapeType) String() string { return proto.CompactTextString(m) }
func (*AttackShapeType) ProtoMessage()    {}
func (*AttackShapeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{6}
}
func (m *AttackShapeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackShapeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackShapeType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackShapeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackShapeType.Merge(m, src)
}
func (m *AttackShapeType) XXX_Size() int {
	return m.Size()
}
func (m *AttackShapeType) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackShapeType.DiscardUnknown(m)
}

var xxx_messageInfo_AttackShapeType proto.InternalMessageInfo

// 伤害类型
type DamageType struct {
}

func (m *DamageType) Reset()         { *m = DamageType{} }
func (m *DamageType) String() string { return proto.CompactTextString(m) }
func (*DamageType) ProtoMessage()    {}
func (*DamageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{7}
}
func (m *DamageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DamageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DamageType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DamageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DamageType.Merge(m, src)
}
func (m *DamageType) XXX_Size() int {
	return m.Size()
}
func (m *DamageType) XXX_DiscardUnknown() {
	xxx_messageInfo_DamageType.DiscardUnknown(m)
}

var xxx_messageInfo_DamageType proto.InternalMessageInfo

//移动模式
type MoveMode struct {
}

func (m *MoveMode) Reset()         { *m = MoveMode{} }
func (m *MoveMode) String() string { return proto.CompactTextString(m) }
func (*MoveMode) ProtoMessage()    {}
func (*MoveMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{8}
}
func (m *MoveMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveMode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveMode.Merge(m, src)
}
func (m *MoveMode) XXX_Size() int {
	return m.Size()
}
func (m *MoveMode) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveMode.DiscardUnknown(m)
}

var xxx_messageInfo_MoveMode proto.InternalMessageInfo

// 命中类型
type HitType struct {
}

func (m *HitType) Reset()         { *m = HitType{} }
func (m *HitType) String() string { return proto.CompactTextString(m) }
func (*HitType) ProtoMessage()    {}
func (*HitType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{9}
}
func (m *HitType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HitType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HitType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HitType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HitType.Merge(m, src)
}
func (m *HitType) XXX_Size() int {
	return m.Size()
}
func (m *HitType) XXX_DiscardUnknown() {
	xxx_messageInfo_HitType.DiscardUnknown(m)
}

var xxx_messageInfo_HitType proto.InternalMessageInfo

//技能状态
type SkillState struct {
}

func (m *SkillState) Reset()         { *m = SkillState{} }
func (m *SkillState) String() string { return proto.CompactTextString(m) }
func (*SkillState) ProtoMessage()    {}
func (*SkillState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{10}
}
func (m *SkillState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillState.Merge(m, src)
}
func (m *SkillState) XXX_Size() int {
	return m.Size()
}
func (m *SkillState) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillState.DiscardUnknown(m)
}

var xxx_messageInfo_SkillState proto.InternalMessageInfo

//技能打断原因
type SkillBreakReason struct {
}

func (m *SkillBreakReason) Reset()         { *m = SkillBreakReason{} }
func (m *SkillBreakReason) String() string { return proto.CompactTextString(m) }
func (*SkillBreakReason) ProtoMessage()    {}
func (*SkillBreakReason) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{11}
}
func (m *SkillBreakReason) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillBreakReason) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillBreakReason.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillBreakReason) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillBreakReason.Merge(m, src)
}
func (m *SkillBreakReason) XXX_Size() int {
	return m.Size()
}
func (m *SkillBreakReason) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillBreakReason.DiscardUnknown(m)
}

var xxx_messageInfo_SkillBreakReason proto.InternalMessageInfo

//技能结束原因
type SkillEndReason struct {
}

func (m *SkillEndReason) Reset()         { *m = SkillEndReason{} }
func (m *SkillEndReason) String() string { return proto.CompactTextString(m) }
func (*SkillEndReason) ProtoMessage()    {}
func (*SkillEndReason) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{12}
}
func (m *SkillEndReason) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillEndReason) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillEndReason.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillEndReason) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillEndReason.Merge(m, src)
}
func (m *SkillEndReason) XXX_Size() int {
	return m.Size()
}
func (m *SkillEndReason) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillEndReason.DiscardUnknown(m)
}

var xxx_messageInfo_SkillEndReason proto.InternalMessageInfo

//日志类型
type FightLogType struct {
}

func (m *FightLogType) Reset()         { *m = FightLogType{} }
func (m *FightLogType) String() string { return proto.CompactTextString(m) }
func (*FightLogType) ProtoMessage()    {}
func (*FightLogType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{13}
}
func (m *FightLogType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightLogType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightLogType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightLogType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightLogType.Merge(m, src)
}
func (m *FightLogType) XXX_Size() int {
	return m.Size()
}
func (m *FightLogType) XXX_DiscardUnknown() {
	xxx_messageInfo_FightLogType.DiscardUnknown(m)
}

var xxx_messageInfo_FightLogType proto.InternalMessageInfo

//伤害飘字类型
type DamageFloatWordType struct {
}

func (m *DamageFloatWordType) Reset()         { *m = DamageFloatWordType{} }
func (m *DamageFloatWordType) String() string { return proto.CompactTextString(m) }
func (*DamageFloatWordType) ProtoMessage()    {}
func (*DamageFloatWordType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{14}
}
func (m *DamageFloatWordType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DamageFloatWordType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DamageFloatWordType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DamageFloatWordType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DamageFloatWordType.Merge(m, src)
}
func (m *DamageFloatWordType) XXX_Size() int {
	return m.Size()
}
func (m *DamageFloatWordType) XXX_DiscardUnknown() {
	xxx_messageInfo_DamageFloatWordType.DiscardUnknown(m)
}

var xxx_messageInfo_DamageFloatWordType proto.InternalMessageInfo

// 单场战斗奖励
type FightAwardData struct {
	Awards  map[uint32]uint32 `protobuf:"bytes,1,rep,name=Awards,proto3" json:"Awards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CurTime int64             `protobuf:"varint,2,opt,name=CurTime,proto3" json:"CurTime,omitempty"`
	SkipCG  bool              `protobuf:"varint,3,opt,name=SkipCG,proto3" json:"SkipCG,omitempty"`
}

func (m *FightAwardData) Reset()         { *m = FightAwardData{} }
func (m *FightAwardData) String() string { return proto.CompactTextString(m) }
func (*FightAwardData) ProtoMessage()    {}
func (*FightAwardData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{15}
}
func (m *FightAwardData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightAwardData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightAwardData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightAwardData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightAwardData.Merge(m, src)
}
func (m *FightAwardData) XXX_Size() int {
	return m.Size()
}
func (m *FightAwardData) XXX_DiscardUnknown() {
	xxx_messageInfo_FightAwardData.DiscardUnknown(m)
}

var xxx_messageInfo_FightAwardData proto.InternalMessageInfo

func (m *FightAwardData) GetAwards() map[uint32]uint32 {
	if m != nil {
		return m.Awards
	}
	return nil
}

func (m *FightAwardData) GetCurTime() int64 {
	if m != nil {
		return m.CurTime
	}
	return 0
}

func (m *FightAwardData) GetSkipCG() bool {
	if m != nil {
		return m.SkipCG
	}
	return false
}

// 战斗结果
type FightResult struct {
	Id             string            `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Progress       uint32            `protobuf:"varint,2,opt,name=Progress,proto3" json:"Progress,omitempty"`
	IsBoss         bool              `protobuf:"varint,3,opt,name=IsBoss,proto3" json:"IsBoss,omitempty"`
	StartTimestamp int64             `protobuf:"varint,4,opt,name=StartTimestamp,proto3" json:"StartTimestamp,omitempty"`
	Time           uint32            `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
	RealTime       uint32            `protobuf:"varint,6,opt,name=RealTime,proto3" json:"RealTime,omitempty"`
	Outcome        []Camp_Enum       `protobuf:"varint,7,rep,packed,name=Outcome,proto3,enum=Camp_Enum" json:"Outcome,omitempty"`
	PawnInfos      []*PawnInfo       `protobuf:"bytes,8,rep,name=PawnInfos,proto3" json:"PawnInfos,omitempty"`
	Replay         *FightReplay      `protobuf:"bytes,9,opt,name=Replay,proto3" json:"Replay,omitempty"`
	DebugReplay    *FightReplay      `protobuf:"bytes,10,opt,name=DebugReplay,proto3" json:"DebugReplay,omitempty"`
	DelayRewards   map[uint32]uint32 `protobuf:"bytes,11,rep,name=DelayRewards,proto3" json:"DelayRewards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	DebugSceneInfo *DebugSceneInfo   `protobuf:"bytes,12,opt,name=DebugSceneInfo,proto3" json:"DebugSceneInfo,omitempty"`
	Inherit        *FightInherit     `protobuf:"bytes,13,opt,name=Inherit,proto3" json:"Inherit,omitempty"`
	BattleFieldID  uint32            `protobuf:"varint,14,opt,name=BattleFieldID,proto3" json:"BattleFieldID,omitempty"`
	CommitID       string            `protobuf:"bytes,15,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *FightResult) Reset()         { *m = FightResult{} }
func (m *FightResult) String() string { return proto.CompactTextString(m) }
func (*FightResult) ProtoMessage()    {}
func (*FightResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{16}
}
func (m *FightResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightResult.Merge(m, src)
}
func (m *FightResult) XXX_Size() int {
	return m.Size()
}
func (m *FightResult) XXX_DiscardUnknown() {
	xxx_messageInfo_FightResult.DiscardUnknown(m)
}

var xxx_messageInfo_FightResult proto.InternalMessageInfo

func (m *FightResult) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FightResult) GetProgress() uint32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *FightResult) GetIsBoss() bool {
	if m != nil {
		return m.IsBoss
	}
	return false
}

func (m *FightResult) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *FightResult) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *FightResult) GetRealTime() uint32 {
	if m != nil {
		return m.RealTime
	}
	return 0
}

func (m *FightResult) GetOutcome() []Camp_Enum {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *FightResult) GetPawnInfos() []*PawnInfo {
	if m != nil {
		return m.PawnInfos
	}
	return nil
}

func (m *FightResult) GetReplay() *FightReplay {
	if m != nil {
		return m.Replay
	}
	return nil
}

func (m *FightResult) GetDebugReplay() *FightReplay {
	if m != nil {
		return m.DebugReplay
	}
	return nil
}

func (m *FightResult) GetDelayRewards() map[uint32]uint32 {
	if m != nil {
		return m.DelayRewards
	}
	return nil
}

func (m *FightResult) GetDebugSceneInfo() *DebugSceneInfo {
	if m != nil {
		return m.DebugSceneInfo
	}
	return nil
}

func (m *FightResult) GetInherit() *FightInherit {
	if m != nil {
		return m.Inherit
	}
	return nil
}

func (m *FightResult) GetBattleFieldID() uint32 {
	if m != nil {
		return m.BattleFieldID
	}
	return 0
}

func (m *FightResult) GetCommitID() string {
	if m != nil {
		return m.CommitID
	}
	return ""
}

//DebugSceneInfo 模拟器模式下需要的场景信息
type DebugSceneInfo struct {
	BoundaryPoints []*Position `protobuf:"bytes,1,rep,name=BoundaryPoints,proto3" json:"BoundaryPoints,omitempty"`
}

func (m *DebugSceneInfo) Reset()         { *m = DebugSceneInfo{} }
func (m *DebugSceneInfo) String() string { return proto.CompactTextString(m) }
func (*DebugSceneInfo) ProtoMessage()    {}
func (*DebugSceneInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{17}
}
func (m *DebugSceneInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugSceneInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugSceneInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugSceneInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugSceneInfo.Merge(m, src)
}
func (m *DebugSceneInfo) XXX_Size() int {
	return m.Size()
}
func (m *DebugSceneInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugSceneInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DebugSceneInfo proto.InternalMessageInfo

func (m *DebugSceneInfo) GetBoundaryPoints() []*Position {
	if m != nil {
		return m.BoundaryPoints
	}
	return nil
}

//Position 位置信息
type Position struct {
	X float32 `protobuf:"fixed32,1,opt,name=X,proto3" json:"X,omitempty"`
	Y float32 `protobuf:"fixed32,2,opt,name=Y,proto3" json:"Y,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{18}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Position) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

// 角色信息
type FightRoleInfo struct {
	RoleId string           `protobuf:"bytes,1,opt,name=RoleId,proto3" json:"RoleId,omitempty"`
	Name   string           `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Power  uint64           `protobuf:"varint,3,opt,name=Power,proto3" json:"Power,omitempty"`
	Equips map[int32]uint32 `protobuf:"bytes,4,rep,name=Equips,proto3" json:"Equips,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *FightRoleInfo) Reset()         { *m = FightRoleInfo{} }
func (m *FightRoleInfo) String() string { return proto.CompactTextString(m) }
func (*FightRoleInfo) ProtoMessage()    {}
func (*FightRoleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{19}
}
func (m *FightRoleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightRoleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightRoleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightRoleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightRoleInfo.Merge(m, src)
}
func (m *FightRoleInfo) XXX_Size() int {
	return m.Size()
}
func (m *FightRoleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FightRoleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FightRoleInfo proto.InternalMessageInfo

func (m *FightRoleInfo) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *FightRoleInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FightRoleInfo) GetPower() uint64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *FightRoleInfo) GetEquips() map[int32]uint32 {
	if m != nil {
		return m.Equips
	}
	return nil
}

// AI信息
type FightAIInfo struct {
	AIID  string `protobuf:"bytes,1,opt,name=AIID,proto3" json:"AIID,omitempty"`
	Power uint64 `protobuf:"varint,2,opt,name=Power,proto3" json:"Power,omitempty"`
}

func (m *FightAIInfo) Reset()         { *m = FightAIInfo{} }
func (m *FightAIInfo) String() string { return proto.CompactTextString(m) }
func (*FightAIInfo) ProtoMessage()    {}
func (*FightAIInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{20}
}
func (m *FightAIInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightAIInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightAIInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightAIInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightAIInfo.Merge(m, src)
}
func (m *FightAIInfo) XXX_Size() int {
	return m.Size()
}
func (m *FightAIInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FightAIInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FightAIInfo proto.InternalMessageInfo

func (m *FightAIInfo) GetAIID() string {
	if m != nil {
		return m.AIID
	}
	return ""
}

func (m *FightAIInfo) GetPower() uint64 {
	if m != nil {
		return m.Power
	}
	return 0
}

// Npc信息
type FightNpcInfo struct {
	MasterId uint32 `protobuf:"varint,1,opt,name=MasterId,proto3" json:"MasterId,omitempty"`
	IsBoss   bool   `protobuf:"varint,2,opt,name=IsBoss,proto3" json:"IsBoss,omitempty"`
	SpawnID  string `protobuf:"bytes,3,opt,name=SpawnID,proto3" json:"SpawnID,omitempty"`
}

func (m *FightNpcInfo) Reset()         { *m = FightNpcInfo{} }
func (m *FightNpcInfo) String() string { return proto.CompactTextString(m) }
func (*FightNpcInfo) ProtoMessage()    {}
func (*FightNpcInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{21}
}
func (m *FightNpcInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightNpcInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightNpcInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightNpcInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightNpcInfo.Merge(m, src)
}
func (m *FightNpcInfo) XXX_Size() int {
	return m.Size()
}
func (m *FightNpcInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FightNpcInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FightNpcInfo proto.InternalMessageInfo

func (m *FightNpcInfo) GetMasterId() uint32 {
	if m != nil {
		return m.MasterId
	}
	return 0
}

func (m *FightNpcInfo) GetIsBoss() bool {
	if m != nil {
		return m.IsBoss
	}
	return false
}

func (m *FightNpcInfo) GetSpawnID() string {
	if m != nil {
		return m.SpawnID
	}
	return ""
}

// 角色继承数据
type PawnInherit struct {
	UltimateSkillPower int32 `protobuf:"varint,1,opt,name=UltimateSkillPower,proto3" json:"UltimateSkillPower,omitempty"`
}

func (m *PawnInherit) Reset()         { *m = PawnInherit{} }
func (m *PawnInherit) String() string { return proto.CompactTextString(m) }
func (*PawnInherit) ProtoMessage()    {}
func (*PawnInherit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{22}
}
func (m *PawnInherit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PawnInherit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PawnInherit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PawnInherit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PawnInherit.Merge(m, src)
}
func (m *PawnInherit) XXX_Size() int {
	return m.Size()
}
func (m *PawnInherit) XXX_DiscardUnknown() {
	xxx_messageInfo_PawnInherit.DiscardUnknown(m)
}

var xxx_messageInfo_PawnInherit proto.InternalMessageInfo

func (m *PawnInherit) GetUltimateSkillPower() int32 {
	if m != nil {
		return m.UltimateSkillPower
	}
	return 0
}

// 战斗数据继承
type FightInherit struct {
	PawnInheritMap map[string]*PawnInherit `protobuf:"bytes,1,rep,name=PawnInheritMap,proto3" json:"PawnInheritMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FightInherit) Reset()         { *m = FightInherit{} }
func (m *FightInherit) String() string { return proto.CompactTextString(m) }
func (*FightInherit) ProtoMessage()    {}
func (*FightInherit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{23}
}
func (m *FightInherit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightInherit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightInherit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightInherit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightInherit.Merge(m, src)
}
func (m *FightInherit) XXX_Size() int {
	return m.Size()
}
func (m *FightInherit) XXX_DiscardUnknown() {
	xxx_messageInfo_FightInherit.DiscardUnknown(m)
}

var xxx_messageInfo_FightInherit proto.InternalMessageInfo

func (m *FightInherit) GetPawnInheritMap() map[string]*PawnInherit {
	if m != nil {
		return m.PawnInheritMap
	}
	return nil
}

// 战斗对象信息
type PawnInfo struct {
	Id           uint32         `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ConfigId     uint32         `protobuf:"varint,2,opt,name=ConfigId,proto3" json:"ConfigId,omitempty"`
	Type         PawnType_Enum  `protobuf:"varint,3,opt,name=Type,proto3,enum=PawnType_Enum" json:"Type,omitempty"`
	Role         *FightRoleInfo `protobuf:"bytes,4,opt,name=Role,proto3" json:"Role,omitempty"`
	Npc          *FightNpcInfo  `protobuf:"bytes,5,opt,name=Npc,proto3" json:"Npc,omitempty"`
	Camp         Camp_Enum      `protobuf:"varint,6,opt,name=Camp,proto3,enum=Camp_Enum" json:"Camp,omitempty"`
	BornPos      *Position      `protobuf:"bytes,7,opt,name=BornPos,proto3" json:"BornPos,omitempty"`
	BornAngle    float32        `protobuf:"fixed32,8,opt,name=BornAngle,proto3" json:"BornAngle,omitempty"`
	Level        int32          `protobuf:"varint,9,opt,name=Level,proto3" json:"Level,omitempty"`
	FightEndDead bool           `protobuf:"varint,11,opt,name=FightEndDead,proto3" json:"FightEndDead,omitempty"`
	IsSummon     bool           `protobuf:"varint,12,opt,name=IsSummon,proto3" json:"IsSummon,omitempty"`
}

func (m *PawnInfo) Reset()         { *m = PawnInfo{} }
func (m *PawnInfo) String() string { return proto.CompactTextString(m) }
func (*PawnInfo) ProtoMessage()    {}
func (*PawnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{24}
}
func (m *PawnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PawnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PawnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PawnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PawnInfo.Merge(m, src)
}
func (m *PawnInfo) XXX_Size() int {
	return m.Size()
}
func (m *PawnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PawnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PawnInfo proto.InternalMessageInfo

func (m *PawnInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PawnInfo) GetConfigId() uint32 {
	if m != nil {
		return m.ConfigId
	}
	return 0
}

func (m *PawnInfo) GetType() PawnType_Enum {
	if m != nil {
		return m.Type
	}
	return PawnType_Role
}

func (m *PawnInfo) GetRole() *FightRoleInfo {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *PawnInfo) GetNpc() *FightNpcInfo {
	if m != nil {
		return m.Npc
	}
	return nil
}

func (m *PawnInfo) GetCamp() Camp_Enum {
	if m != nil {
		return m.Camp
	}
	return Camp_Red
}

func (m *PawnInfo) GetBornPos() *Position {
	if m != nil {
		return m.BornPos
	}
	return nil
}

func (m *PawnInfo) GetBornAngle() float32 {
	if m != nil {
		return m.BornAngle
	}
	return 0
}

func (m *PawnInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PawnInfo) GetFightEndDead() bool {
	if m != nil {
		return m.FightEndDead
	}
	return false
}

func (m *PawnInfo) GetIsSummon() bool {
	if m != nil {
		return m.IsSummon
	}
	return false
}

// 战斗回放
type FightReplay struct {
	FrameList []*FightFrame `protobuf:"bytes,1,rep,name=FrameList,proto3" json:"FrameList,omitempty"`
}

func (m *FightReplay) Reset()         { *m = FightReplay{} }
func (m *FightReplay) String() string { return proto.CompactTextString(m) }
func (*FightReplay) ProtoMessage()    {}
func (*FightReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{25}
}
func (m *FightReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightReplay.Merge(m, src)
}
func (m *FightReplay) XXX_Size() int {
	return m.Size()
}
func (m *FightReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_FightReplay.DiscardUnknown(m)
}

var xxx_messageInfo_FightReplay proto.InternalMessageInfo

func (m *FightReplay) GetFrameList() []*FightFrame {
	if m != nil {
		return m.FrameList
	}
	return nil
}

// 战斗帧
type FightFrame struct {
	Sequence   uint32         `protobuf:"varint,1,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	ActionList []*FightAction `protobuf:"bytes,2,rep,name=ActionList,proto3" json:"ActionList,omitempty"`
}

func (m *FightFrame) Reset()         { *m = FightFrame{} }
func (m *FightFrame) String() string { return proto.CompactTextString(m) }
func (*FightFrame) ProtoMessage()    {}
func (*FightFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{26}
}
func (m *FightFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightFrame.Merge(m, src)
}
func (m *FightFrame) XXX_Size() int {
	return m.Size()
}
func (m *FightFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_FightFrame.DiscardUnknown(m)
}

var xxx_messageInfo_FightFrame proto.InternalMessageInfo

func (m *FightFrame) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *FightFrame) GetActionList() []*FightAction {
	if m != nil {
		return m.ActionList
	}
	return nil
}

// 战斗动作
type FightAction struct {
	Type                      ActionType_Enum      `protobuf:"varint,1,opt,name=Type,proto3,enum=ActionType_Enum" json:"Type,omitempty"`
	ActionMoveBegin           *MoveBegin           `protobuf:"bytes,2,opt,name=ActionMoveBegin,proto3" json:"ActionMoveBegin,omitempty"`
	ActionFixMoveData         *FixMoveData         `protobuf:"bytes,3,opt,name=ActionFixMoveData,proto3" json:"ActionFixMoveData,omitempty"`
	ActionMoveEnd             *MoveEnd             `protobuf:"bytes,4,opt,name=ActionMoveEnd,proto3" json:"ActionMoveEnd,omitempty"`
	ActionUseSkill            *UseSkill            `protobuf:"bytes,5,opt,name=ActionUseSkill,proto3" json:"ActionUseSkill,omitempty"`
	ActionBreakSkill          *BreakSkill          `protobuf:"bytes,6,opt,name=ActionBreakSkill,proto3" json:"ActionBreakSkill,omitempty"`
	ActionNewAttack           *NewAttack           `protobuf:"bytes,7,opt,name=ActionNewAttack,proto3" json:"ActionNewAttack,omitempty"`
	ActionDelAttack           *DelAttack           `protobuf:"bytes,8,opt,name=ActionDelAttack,proto3" json:"ActionDelAttack,omitempty"`
	ActionAttackHit           *AttackHit           `protobuf:"bytes,9,opt,name=ActionAttackHit,proto3" json:"ActionAttackHit,omitempty"`
	ActionBeHit               *BeHit               `protobuf:"bytes,10,opt,name=ActionBeHit,proto3" json:"ActionBeHit,omitempty"`
	ActionAddBuff             *AddBuff             `protobuf:"bytes,11,opt,name=ActionAddBuff,proto3" json:"ActionAddBuff,omitempty"`
	ActionRemoveBuff          *RemoveBuff          `protobuf:"bytes,12,opt,name=ActionRemoveBuff,proto3" json:"ActionRemoveBuff,omitempty"`
	ActionChangeAttr          *ChangeAttr          `protobuf:"bytes,13,opt,name=ActionChangeAttr,proto3" json:"ActionChangeAttr,omitempty"`
	ActionChangeStat          *ChangeStat          `protobuf:"bytes,14,opt,name=ActionChangeStat,proto3" json:"ActionChangeStat,omitempty"`
	ActionFightBegin          *FightBegin          `protobuf:"bytes,15,opt,name=ActionFightBegin,proto3" json:"ActionFightBegin,omitempty"`
	ActionFightEnd            *FightEnd            `protobuf:"bytes,16,opt,name=ActionFightEnd,proto3" json:"ActionFightEnd,omitempty"`
	ActionDebugInfo           *DebugInfo           `protobuf:"bytes,17,opt,name=ActionDebugInfo,proto3" json:"ActionDebugInfo,omitempty"`
	ActionChangeSkillState    *ChangeSkillState    `protobuf:"bytes,18,opt,name=ActionChangeSkillState,proto3" json:"ActionChangeSkillState,omitempty"`
	ActionCombineSkillEndTime *CombineSkillEndTime `protobuf:"bytes,19,opt,name=ActionCombineSkillEndTime,proto3" json:"ActionCombineSkillEndTime,omitempty"`
	ActionCombineSkillPoint   *CombineSkillPoint   `protobuf:"bytes,20,opt,name=ActionCombineSkillPoint,proto3" json:"ActionCombineSkillPoint,omitempty"`
	ActionSetTarget           *SetTarget           `protobuf:"bytes,21,opt,name=ActionSetTarget,proto3" json:"ActionSetTarget,omitempty"`
	ActionAttackShowAoe       *AttackShowAoe       `protobuf:"bytes,22,opt,name=ActionAttackShowAoe,proto3" json:"ActionAttackShowAoe,omitempty"`
	ActionAttackMoveAoe       *AttackMoveAoe       `protobuf:"bytes,23,opt,name=ActionAttackMoveAoe,proto3" json:"ActionAttackMoveAoe,omitempty"`
	ActionSummonPawn          *SummonPawn          `protobuf:"bytes,24,opt,name=ActionSummonPawn,proto3" json:"ActionSummonPawn,omitempty"`
}

func (m *FightAction) Reset()         { *m = FightAction{} }
func (m *FightAction) String() string { return proto.CompactTextString(m) }
func (*FightAction) ProtoMessage()    {}
func (*FightAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{27}
}
func (m *FightAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightAction.Merge(m, src)
}
func (m *FightAction) XXX_Size() int {
	return m.Size()
}
func (m *FightAction) XXX_DiscardUnknown() {
	xxx_messageInfo_FightAction.DiscardUnknown(m)
}

var xxx_messageInfo_FightAction proto.InternalMessageInfo

func (m *FightAction) GetType() ActionType_Enum {
	if m != nil {
		return m.Type
	}
	return ActionType_MoveBegin
}

func (m *FightAction) GetActionMoveBegin() *MoveBegin {
	if m != nil {
		return m.ActionMoveBegin
	}
	return nil
}

func (m *FightAction) GetActionFixMoveData() *FixMoveData {
	if m != nil {
		return m.ActionFixMoveData
	}
	return nil
}

func (m *FightAction) GetActionMoveEnd() *MoveEnd {
	if m != nil {
		return m.ActionMoveEnd
	}
	return nil
}

func (m *FightAction) GetActionUseSkill() *UseSkill {
	if m != nil {
		return m.ActionUseSkill
	}
	return nil
}

func (m *FightAction) GetActionBreakSkill() *BreakSkill {
	if m != nil {
		return m.ActionBreakSkill
	}
	return nil
}

func (m *FightAction) GetActionNewAttack() *NewAttack {
	if m != nil {
		return m.ActionNewAttack
	}
	return nil
}

func (m *FightAction) GetActionDelAttack() *DelAttack {
	if m != nil {
		return m.ActionDelAttack
	}
	return nil
}

func (m *FightAction) GetActionAttackHit() *AttackHit {
	if m != nil {
		return m.ActionAttackHit
	}
	return nil
}

func (m *FightAction) GetActionBeHit() *BeHit {
	if m != nil {
		return m.ActionBeHit
	}
	return nil
}

func (m *FightAction) GetActionAddBuff() *AddBuff {
	if m != nil {
		return m.ActionAddBuff
	}
	return nil
}

func (m *FightAction) GetActionRemoveBuff() *RemoveBuff {
	if m != nil {
		return m.ActionRemoveBuff
	}
	return nil
}

func (m *FightAction) GetActionChangeAttr() *ChangeAttr {
	if m != nil {
		return m.ActionChangeAttr
	}
	return nil
}

func (m *FightAction) GetActionChangeStat() *ChangeStat {
	if m != nil {
		return m.ActionChangeStat
	}
	return nil
}

func (m *FightAction) GetActionFightBegin() *FightBegin {
	if m != nil {
		return m.ActionFightBegin
	}
	return nil
}

func (m *FightAction) GetActionFightEnd() *FightEnd {
	if m != nil {
		return m.ActionFightEnd
	}
	return nil
}

func (m *FightAction) GetActionDebugInfo() *DebugInfo {
	if m != nil {
		return m.ActionDebugInfo
	}
	return nil
}

func (m *FightAction) GetActionChangeSkillState() *ChangeSkillState {
	if m != nil {
		return m.ActionChangeSkillState
	}
	return nil
}

func (m *FightAction) GetActionCombineSkillEndTime() *CombineSkillEndTime {
	if m != nil {
		return m.ActionCombineSkillEndTime
	}
	return nil
}

func (m *FightAction) GetActionCombineSkillPoint() *CombineSkillPoint {
	if m != nil {
		return m.ActionCombineSkillPoint
	}
	return nil
}

func (m *FightAction) GetActionSetTarget() *SetTarget {
	if m != nil {
		return m.ActionSetTarget
	}
	return nil
}

func (m *FightAction) GetActionAttackShowAoe() *AttackShowAoe {
	if m != nil {
		return m.ActionAttackShowAoe
	}
	return nil
}

func (m *FightAction) GetActionAttackMoveAoe() *AttackMoveAoe {
	if m != nil {
		return m.ActionAttackMoveAoe
	}
	return nil
}

func (m *FightAction) GetActionSummonPawn() *SummonPawn {
	if m != nil {
		return m.ActionSummonPawn
	}
	return nil
}

// SummonPawn 召唤
type SummonPawn struct {
	SelfId uint32 `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
}

func (m *SummonPawn) Reset()         { *m = SummonPawn{} }
func (m *SummonPawn) String() string { return proto.CompactTextString(m) }
func (*SummonPawn) ProtoMessage()    {}
func (*SummonPawn) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{28}
}
func (m *SummonPawn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SummonPawn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SummonPawn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SummonPawn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummonPawn.Merge(m, src)
}
func (m *SummonPawn) XXX_Size() int {
	return m.Size()
}
func (m *SummonPawn) XXX_DiscardUnknown() {
	xxx_messageInfo_SummonPawn.DiscardUnknown(m)
}

var xxx_messageInfo_SummonPawn proto.InternalMessageInfo

func (m *SummonPawn) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

// 移动
type MoveBegin struct {
	SelfId                uint32        `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	MoveMode              MoveMode_Enum `protobuf:"varint,2,opt,name=MoveMode,proto3,enum=MoveMode_Enum" json:"MoveMode,omitempty"`
	Angle                 float32       `protobuf:"fixed32,3,opt,name=Angle,proto3" json:"Angle,omitempty"`
	Pos                   *Position     `protobuf:"bytes,4,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Speed                 float32       `protobuf:"fixed32,5,opt,name=Speed,proto3" json:"Speed,omitempty"`
	LookAtPos             *Position     `protobuf:"bytes,6,opt,name=LookAtPos,proto3" json:"LookAtPos,omitempty"`
	NeedSteeringSmoothing bool          `protobuf:"varint,7,opt,name=NeedSteeringSmoothing,proto3" json:"NeedSteeringSmoothing,omitempty"`
	ExpectMoveEndTime     uint32        `protobuf:"varint,8,opt,name=ExpectMoveEndTime,proto3" json:"ExpectMoveEndTime,omitempty"`
	ActualMoveEndTime     uint32        `protobuf:"varint,9,opt,name=ActualMoveEndTime,proto3" json:"ActualMoveEndTime,omitempty"`
}

func (m *MoveBegin) Reset()         { *m = MoveBegin{} }
func (m *MoveBegin) String() string { return proto.CompactTextString(m) }
func (*MoveBegin) ProtoMessage()    {}
func (*MoveBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{29}
}
func (m *MoveBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveBegin.Merge(m, src)
}
func (m *MoveBegin) XXX_Size() int {
	return m.Size()
}
func (m *MoveBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveBegin.DiscardUnknown(m)
}

var xxx_messageInfo_MoveBegin proto.InternalMessageInfo

func (m *MoveBegin) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *MoveBegin) GetMoveMode() MoveMode_Enum {
	if m != nil {
		return m.MoveMode
	}
	return MoveMode_None
}

func (m *MoveBegin) GetAngle() float32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *MoveBegin) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *MoveBegin) GetSpeed() float32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *MoveBegin) GetLookAtPos() *Position {
	if m != nil {
		return m.LookAtPos
	}
	return nil
}

func (m *MoveBegin) GetNeedSteeringSmoothing() bool {
	if m != nil {
		return m.NeedSteeringSmoothing
	}
	return false
}

func (m *MoveBegin) GetExpectMoveEndTime() uint32 {
	if m != nil {
		return m.ExpectMoveEndTime
	}
	return 0
}

func (m *MoveBegin) GetActualMoveEndTime() uint32 {
	if m != nil {
		return m.ActualMoveEndTime
	}
	return 0
}

//移动停止
type MoveEnd struct {
	SelfId   uint32        `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	MoveMode MoveMode_Enum `protobuf:"varint,2,opt,name=MoveMode,proto3,enum=MoveMode_Enum" json:"MoveMode,omitempty"`
	Pos      *Position     `protobuf:"bytes,3,opt,name=Pos,proto3" json:"Pos,omitempty"`
}

func (m *MoveEnd) Reset()         { *m = MoveEnd{} }
func (m *MoveEnd) String() string { return proto.CompactTextString(m) }
func (*MoveEnd) ProtoMessage()    {}
func (*MoveEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{30}
}
func (m *MoveEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveEnd.Merge(m, src)
}
func (m *MoveEnd) XXX_Size() int {
	return m.Size()
}
func (m *MoveEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveEnd.DiscardUnknown(m)
}

var xxx_messageInfo_MoveEnd proto.InternalMessageInfo

func (m *MoveEnd) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *MoveEnd) GetMoveMode() MoveMode_Enum {
	if m != nil {
		return m.MoveMode
	}
	return MoveMode_None
}

func (m *MoveEnd) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

//FixMoveData 修正角度或者位置 、瞬间移动
type FixMoveData struct {
	SelfId                uint32    `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	Pos                   *Position `protobuf:"bytes,2,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Angle                 float32   `protobuf:"fixed32,3,opt,name=Angle,proto3" json:"Angle,omitempty"`
	NeedSteeringSmoothing bool      `protobuf:"varint,4,opt,name=NeedSteeringSmoothing,proto3" json:"NeedSteeringSmoothing,omitempty"`
}

func (m *FixMoveData) Reset()         { *m = FixMoveData{} }
func (m *FixMoveData) String() string { return proto.CompactTextString(m) }
func (*FixMoveData) ProtoMessage()    {}
func (*FixMoveData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{31}
}
func (m *FixMoveData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FixMoveData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FixMoveData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FixMoveData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FixMoveData.Merge(m, src)
}
func (m *FixMoveData) XXX_Size() int {
	return m.Size()
}
func (m *FixMoveData) XXX_DiscardUnknown() {
	xxx_messageInfo_FixMoveData.DiscardUnknown(m)
}

var xxx_messageInfo_FixMoveData proto.InternalMessageInfo

func (m *FixMoveData) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *FixMoveData) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *FixMoveData) GetAngle() float32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *FixMoveData) GetNeedSteeringSmoothing() bool {
	if m != nil {
		return m.NeedSteeringSmoothing
	}
	return false
}

// 使用技能
type UseSkill struct {
	CasterId       uint32    `protobuf:"varint,1,opt,name=CasterId,proto3" json:"CasterId,omitempty"`
	SkillId        uint32    `protobuf:"varint,2,opt,name=SkillId,proto3" json:"SkillId,omitempty"`
	TargetId       uint32    `protobuf:"varint,3,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	TargetPos      *Position `protobuf:"bytes,4,opt,name=TargetPos,proto3" json:"TargetPos,omitempty"`
	SkipBefore     bool      `protobuf:"varint,5,opt,name=SkipBefore,proto3" json:"SkipBefore,omitempty"`
	SkipLater      bool      `protobuf:"varint,6,opt,name=SkipLater,proto3" json:"SkipLater,omitempty"`
	CombineCasters []uint32  `protobuf:"varint,7,rep,packed,name=CombineCasters,proto3" json:"CombineCasters,omitempty"`
}

func (m *UseSkill) Reset()         { *m = UseSkill{} }
func (m *UseSkill) String() string { return proto.CompactTextString(m) }
func (*UseSkill) ProtoMessage()    {}
func (*UseSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{32}
}
func (m *UseSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UseSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UseSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UseSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UseSkill.Merge(m, src)
}
func (m *UseSkill) XXX_Size() int {
	return m.Size()
}
func (m *UseSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_UseSkill.DiscardUnknown(m)
}

var xxx_messageInfo_UseSkill proto.InternalMessageInfo

func (m *UseSkill) GetCasterId() uint32 {
	if m != nil {
		return m.CasterId
	}
	return 0
}

func (m *UseSkill) GetSkillId() uint32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *UseSkill) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *UseSkill) GetTargetPos() *Position {
	if m != nil {
		return m.TargetPos
	}
	return nil
}

func (m *UseSkill) GetSkipBefore() bool {
	if m != nil {
		return m.SkipBefore
	}
	return false
}

func (m *UseSkill) GetSkipLater() bool {
	if m != nil {
		return m.SkipLater
	}
	return false
}

func (m *UseSkill) GetCombineCasters() []uint32 {
	if m != nil {
		return m.CombineCasters
	}
	return nil
}

// 打断技能
type BreakSkill struct {
	CasterId uint32 `protobuf:"varint,1,opt,name=CasterId,proto3" json:"CasterId,omitempty"`
	TargetId uint32 `protobuf:"varint,2,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	SkillId  uint32 `protobuf:"varint,3,opt,name=SkillId,proto3" json:"SkillId,omitempty"`
}

func (m *BreakSkill) Reset()         { *m = BreakSkill{} }
func (m *BreakSkill) String() string { return proto.CompactTextString(m) }
func (*BreakSkill) ProtoMessage()    {}
func (*BreakSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{33}
}
func (m *BreakSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BreakSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BreakSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BreakSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BreakSkill.Merge(m, src)
}
func (m *BreakSkill) XXX_Size() int {
	return m.Size()
}
func (m *BreakSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_BreakSkill.DiscardUnknown(m)
}

var xxx_messageInfo_BreakSkill proto.InternalMessageInfo

func (m *BreakSkill) GetCasterId() uint32 {
	if m != nil {
		return m.CasterId
	}
	return 0
}

func (m *BreakSkill) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *BreakSkill) GetSkillId() uint32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

// 创建伤害体
type NewAttack struct {
	CasterId    uint32         `protobuf:"varint,1,opt,name=CasterId,proto3" json:"CasterId,omitempty"`
	Src         AttackSrc_Enum `protobuf:"varint,2,opt,name=Src,proto3,enum=AttackSrc_Enum" json:"Src,omitempty"`
	SkillId     uint32         `protobuf:"varint,3,opt,name=SkillId,proto3" json:"SkillId,omitempty"`
	Index       uint32         `protobuf:"varint,4,opt,name=Index,proto3" json:"Index,omitempty"`
	BuffKey     uint64         `protobuf:"varint,5,opt,name=BuffKey,proto3" json:"BuffKey,omitempty"`
	BuffId      uint32         `protobuf:"varint,6,opt,name=BuffId,proto3" json:"BuffId,omitempty"`
	ConfigId    uint32         `protobuf:"varint,7,opt,name=ConfigId,proto3" json:"ConfigId,omitempty"`
	AttackId    uint32         `protobuf:"varint,8,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
	TargetId    uint32         `protobuf:"varint,9,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	TargetPos   *Position      `protobuf:"bytes,10,opt,name=TargetPos,proto3" json:"TargetPos,omitempty"`
	MoveBeginId uint32         `protobuf:"varint,11,opt,name=MoveBeginId,proto3" json:"MoveBeginId,omitempty"`
	MoveEndTime uint32         `protobuf:"varint,12,opt,name=MoveEndTime,proto3" json:"MoveEndTime,omitempty"`
	GroupID     uint32         `protobuf:"varint,13,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
}

func (m *NewAttack) Reset()         { *m = NewAttack{} }
func (m *NewAttack) String() string { return proto.CompactTextString(m) }
func (*NewAttack) ProtoMessage()    {}
func (*NewAttack) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{34}
}
func (m *NewAttack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewAttack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewAttack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewAttack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewAttack.Merge(m, src)
}
func (m *NewAttack) XXX_Size() int {
	return m.Size()
}
func (m *NewAttack) XXX_DiscardUnknown() {
	xxx_messageInfo_NewAttack.DiscardUnknown(m)
}

var xxx_messageInfo_NewAttack proto.InternalMessageInfo

func (m *NewAttack) GetCasterId() uint32 {
	if m != nil {
		return m.CasterId
	}
	return 0
}

func (m *NewAttack) GetSrc() AttackSrc_Enum {
	if m != nil {
		return m.Src
	}
	return AttackSrc_Skill
}

func (m *NewAttack) GetSkillId() uint32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *NewAttack) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *NewAttack) GetBuffKey() uint64 {
	if m != nil {
		return m.BuffKey
	}
	return 0
}

func (m *NewAttack) GetBuffId() uint32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

func (m *NewAttack) GetConfigId() uint32 {
	if m != nil {
		return m.ConfigId
	}
	return 0
}

func (m *NewAttack) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

func (m *NewAttack) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *NewAttack) GetTargetPos() *Position {
	if m != nil {
		return m.TargetPos
	}
	return nil
}

func (m *NewAttack) GetMoveBeginId() uint32 {
	if m != nil {
		return m.MoveBeginId
	}
	return 0
}

func (m *NewAttack) GetMoveEndTime() uint32 {
	if m != nil {
		return m.MoveEndTime
	}
	return 0
}

func (m *NewAttack) GetGroupID() uint32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

// 删除伤害体
type DelAttack struct {
	AttackId uint32 `protobuf:"varint,1,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
}

func (m *DelAttack) Reset()         { *m = DelAttack{} }
func (m *DelAttack) String() string { return proto.CompactTextString(m) }
func (*DelAttack) ProtoMessage()    {}
func (*DelAttack) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{35}
}
func (m *DelAttack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelAttack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelAttack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelAttack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelAttack.Merge(m, src)
}
func (m *DelAttack) XXX_Size() int {
	return m.Size()
}
func (m *DelAttack) XXX_DiscardUnknown() {
	xxx_messageInfo_DelAttack.DiscardUnknown(m)
}

var xxx_messageInfo_DelAttack proto.InternalMessageInfo

func (m *DelAttack) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

// 攻击命中
type AttackHit struct {
	TargetId            uint32                   `protobuf:"varint,1,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	AttackId            uint32                   `protobuf:"varint,2,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
	HitTimes            uint32                   `protobuf:"varint,3,opt,name=HitTimes,proto3" json:"HitTimes,omitempty"`
	DamageBit           uint64                   `protobuf:"varint,4,opt,name=DamageBit,proto3" json:"DamageBit,omitempty"`
	DamageHP            int64                    `protobuf:"varint,5,opt,name=DamageHP,proto3" json:"DamageHP,omitempty"`
	DamageHPShield      int64                    `protobuf:"varint,6,opt,name=DamageHPShield,proto3" json:"DamageHPShield,omitempty"`
	DamageValue         int64                    `protobuf:"varint,7,opt,name=DamageValue,proto3" json:"DamageValue,omitempty"`
	DamageFloatWordType DamageFloatWordType_Enum `protobuf:"varint,8,opt,name=DamageFloatWordType,proto3,enum=DamageFloatWordType_Enum" json:"DamageFloatWordType,omitempty"`
}

func (m *AttackHit) Reset()         { *m = AttackHit{} }
func (m *AttackHit) String() string { return proto.CompactTextString(m) }
func (*AttackHit) ProtoMessage()    {}
func (*AttackHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{36}
}
func (m *AttackHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackHit.Merge(m, src)
}
func (m *AttackHit) XXX_Size() int {
	return m.Size()
}
func (m *AttackHit) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackHit.DiscardUnknown(m)
}

var xxx_messageInfo_AttackHit proto.InternalMessageInfo

func (m *AttackHit) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *AttackHit) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

func (m *AttackHit) GetHitTimes() uint32 {
	if m != nil {
		return m.HitTimes
	}
	return 0
}

func (m *AttackHit) GetDamageBit() uint64 {
	if m != nil {
		return m.DamageBit
	}
	return 0
}

func (m *AttackHit) GetDamageHP() int64 {
	if m != nil {
		return m.DamageHP
	}
	return 0
}

func (m *AttackHit) GetDamageHPShield() int64 {
	if m != nil {
		return m.DamageHPShield
	}
	return 0
}

func (m *AttackHit) GetDamageValue() int64 {
	if m != nil {
		return m.DamageValue
	}
	return 0
}

func (m *AttackHit) GetDamageFloatWordType() DamageFloatWordType_Enum {
	if m != nil {
		return m.DamageFloatWordType
	}
	return DamageFloatWordType_Normal
}

// 受击
type BeHit struct {
	TargetId uint32       `protobuf:"varint,1,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	AttackId uint32       `protobuf:"varint,2,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
	HitType  HitType_Enum `protobuf:"varint,3,opt,name=HitType,proto3,enum=HitType_Enum" json:"HitType,omitempty"`
}

func (m *BeHit) Reset()         { *m = BeHit{} }
func (m *BeHit) String() string { return proto.CompactTextString(m) }
func (*BeHit) ProtoMessage()    {}
func (*BeHit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{37}
}
func (m *BeHit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeHit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeHit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeHit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeHit.Merge(m, src)
}
func (m *BeHit) XXX_Size() int {
	return m.Size()
}
func (m *BeHit) XXX_DiscardUnknown() {
	xxx_messageInfo_BeHit.DiscardUnknown(m)
}

var xxx_messageInfo_BeHit proto.InternalMessageInfo

func (m *BeHit) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *BeHit) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

func (m *BeHit) GetHitType() HitType_Enum {
	if m != nil {
		return m.HitType
	}
	return HitType_None
}

// 添加buff
type AddBuff struct {
	BuffKey  uint64 `protobuf:"varint,1,opt,name=BuffKey,proto3" json:"BuffKey,omitempty"`
	CasterId uint32 `protobuf:"varint,2,opt,name=CasterId,proto3" json:"CasterId,omitempty"`
	TargetId uint32 `protobuf:"varint,3,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
	BuffId   uint32 `protobuf:"varint,4,opt,name=BuffId,proto3" json:"BuffId,omitempty"`
}

func (m *AddBuff) Reset()         { *m = AddBuff{} }
func (m *AddBuff) String() string { return proto.CompactTextString(m) }
func (*AddBuff) ProtoMessage()    {}
func (*AddBuff) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{38}
}
func (m *AddBuff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddBuff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddBuff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddBuff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddBuff.Merge(m, src)
}
func (m *AddBuff) XXX_Size() int {
	return m.Size()
}
func (m *AddBuff) XXX_DiscardUnknown() {
	xxx_messageInfo_AddBuff.DiscardUnknown(m)
}

var xxx_messageInfo_AddBuff proto.InternalMessageInfo

func (m *AddBuff) GetBuffKey() uint64 {
	if m != nil {
		return m.BuffKey
	}
	return 0
}

func (m *AddBuff) GetCasterId() uint32 {
	if m != nil {
		return m.CasterId
	}
	return 0
}

func (m *AddBuff) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *AddBuff) GetBuffId() uint32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

// 移除buff
type RemoveBuff struct {
	BuffKey uint64 `protobuf:"varint,1,opt,name=BuffKey,proto3" json:"BuffKey,omitempty"`
	SelfId  uint32 `protobuf:"varint,2,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	BuffId  uint32 `protobuf:"varint,3,opt,name=BuffId,proto3" json:"BuffId,omitempty"`
}

func (m *RemoveBuff) Reset()         { *m = RemoveBuff{} }
func (m *RemoveBuff) String() string { return proto.CompactTextString(m) }
func (*RemoveBuff) ProtoMessage()    {}
func (*RemoveBuff) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{39}
}
func (m *RemoveBuff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveBuff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveBuff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveBuff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveBuff.Merge(m, src)
}
func (m *RemoveBuff) XXX_Size() int {
	return m.Size()
}
func (m *RemoveBuff) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveBuff.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveBuff proto.InternalMessageInfo

func (m *RemoveBuff) GetBuffKey() uint64 {
	if m != nil {
		return m.BuffKey
	}
	return 0
}

func (m *RemoveBuff) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *RemoveBuff) GetBuffId() uint32 {
	if m != nil {
		return m.BuffId
	}
	return 0
}

// 修改属性
type ChangeAttr struct {
	SelfId   uint32        `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	AttrType AttrType_Enum `protobuf:"varint,2,opt,name=AttrType,proto3,enum=AttrType_Enum" json:"AttrType,omitempty"`
	OldValue float64       `protobuf:"fixed64,3,opt,name=OldValue,proto3" json:"OldValue,omitempty"`
	NewValue float64       `protobuf:"fixed64,4,opt,name=NewValue,proto3" json:"NewValue,omitempty"`
}

func (m *ChangeAttr) Reset()         { *m = ChangeAttr{} }
func (m *ChangeAttr) String() string { return proto.CompactTextString(m) }
func (*ChangeAttr) ProtoMessage()    {}
func (*ChangeAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{40}
}
func (m *ChangeAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeAttr.Merge(m, src)
}
func (m *ChangeAttr) XXX_Size() int {
	return m.Size()
}
func (m *ChangeAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeAttr.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeAttr proto.InternalMessageInfo

func (m *ChangeAttr) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *ChangeAttr) GetAttrType() AttrType_Enum {
	if m != nil {
		return m.AttrType
	}
	return AttrType_CurHP
}

func (m *ChangeAttr) GetOldValue() float64 {
	if m != nil {
		return m.OldValue
	}
	return 0
}

func (m *ChangeAttr) GetNewValue() float64 {
	if m != nil {
		return m.NewValue
	}
	return 0
}

// 修改状态
type ChangeStat struct {
	SelfId    uint32        `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	StatType  StatType_Enum `protobuf:"varint,2,opt,name=StatType,proto3,enum=StatType_Enum" json:"StatType,omitempty"`
	StatValue bool          `protobuf:"varint,3,opt,name=StatValue,proto3" json:"StatValue,omitempty"`
}

func (m *ChangeStat) Reset()         { *m = ChangeStat{} }
func (m *ChangeStat) String() string { return proto.CompactTextString(m) }
func (*ChangeStat) ProtoMessage()    {}
func (*ChangeStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{41}
}
func (m *ChangeStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeStat.Merge(m, src)
}
func (m *ChangeStat) XXX_Size() int {
	return m.Size()
}
func (m *ChangeStat) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeStat.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeStat proto.InternalMessageInfo

func (m *ChangeStat) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *ChangeStat) GetStatType() StatType_Enum {
	if m != nil {
		return m.StatType
	}
	return StatType_Dead
}

func (m *ChangeStat) GetStatValue() bool {
	if m != nil {
		return m.StatValue
	}
	return false
}

// FightBegin
type FightBegin struct {
}

func (m *FightBegin) Reset()         { *m = FightBegin{} }
func (m *FightBegin) String() string { return proto.CompactTextString(m) }
func (*FightBegin) ProtoMessage()    {}
func (*FightBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{42}
}
func (m *FightBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightBegin.Merge(m, src)
}
func (m *FightBegin) XXX_Size() int {
	return m.Size()
}
func (m *FightBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_FightBegin.DiscardUnknown(m)
}

var xxx_messageInfo_FightBegin proto.InternalMessageInfo

// FightEnd
type FightEnd struct {
}

func (m *FightEnd) Reset()         { *m = FightEnd{} }
func (m *FightEnd) String() string { return proto.CompactTextString(m) }
func (*FightEnd) ProtoMessage()    {}
func (*FightEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{43}
}
func (m *FightEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FightEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FightEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FightEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FightEnd.Merge(m, src)
}
func (m *FightEnd) XXX_Size() int {
	return m.Size()
}
func (m *FightEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_FightEnd.DiscardUnknown(m)
}

var xxx_messageInfo_FightEnd proto.InternalMessageInfo

// debug日志
type DebugInfo struct {
	Message string            `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
	Type    FightLogType_Enum `protobuf:"varint,2,opt,name=Type,proto3,enum=FightLogType_Enum" json:"Type,omitempty"`
}

func (m *DebugInfo) Reset()         { *m = DebugInfo{} }
func (m *DebugInfo) String() string { return proto.CompactTextString(m) }
func (*DebugInfo) ProtoMessage()    {}
func (*DebugInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{44}
}
func (m *DebugInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugInfo.Merge(m, src)
}
func (m *DebugInfo) XXX_Size() int {
	return m.Size()
}
func (m *DebugInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DebugInfo proto.InternalMessageInfo

func (m *DebugInfo) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *DebugInfo) GetType() FightLogType_Enum {
	if m != nil {
		return m.Type
	}
	return FightLogType_Simple
}

// 改变技能阶段
type ChangeSkillState struct {
	CasterId uint32          `protobuf:"varint,1,opt,name=CasterId,proto3" json:"CasterId,omitempty"`
	SkillId  uint32          `protobuf:"varint,2,opt,name=SkillId,proto3" json:"SkillId,omitempty"`
	State    SkillState_Enum `protobuf:"varint,3,opt,name=State,proto3,enum=SkillState_Enum" json:"State,omitempty"`
}

func (m *ChangeSkillState) Reset()         { *m = ChangeSkillState{} }
func (m *ChangeSkillState) String() string { return proto.CompactTextString(m) }
func (*ChangeSkillState) ProtoMessage()    {}
func (*ChangeSkillState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{45}
}
func (m *ChangeSkillState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeSkillState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeSkillState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeSkillState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeSkillState.Merge(m, src)
}
func (m *ChangeSkillState) XXX_Size() int {
	return m.Size()
}
func (m *ChangeSkillState) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeSkillState.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeSkillState proto.InternalMessageInfo

func (m *ChangeSkillState) GetCasterId() uint32 {
	if m != nil {
		return m.CasterId
	}
	return 0
}

func (m *ChangeSkillState) GetSkillId() uint32 {
	if m != nil {
		return m.SkillId
	}
	return 0
}

func (m *ChangeSkillState) GetState() SkillState_Enum {
	if m != nil {
		return m.State
	}
	return SkillState_Wait
}

// 合体技倒计时结束时间变化
type CombineSkillEndTime struct {
	EndTime uint32 `protobuf:"varint,1,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	Cancel  bool   `protobuf:"varint,2,opt,name=Cancel,proto3" json:"Cancel,omitempty"`
}

func (m *CombineSkillEndTime) Reset()         { *m = CombineSkillEndTime{} }
func (m *CombineSkillEndTime) String() string { return proto.CompactTextString(m) }
func (*CombineSkillEndTime) ProtoMessage()    {}
func (*CombineSkillEndTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{46}
}
func (m *CombineSkillEndTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineSkillEndTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineSkillEndTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineSkillEndTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineSkillEndTime.Merge(m, src)
}
func (m *CombineSkillEndTime) XXX_Size() int {
	return m.Size()
}
func (m *CombineSkillEndTime) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineSkillEndTime.DiscardUnknown(m)
}

var xxx_messageInfo_CombineSkillEndTime proto.InternalMessageInfo

func (m *CombineSkillEndTime) GetEndTime() uint32 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *CombineSkillEndTime) GetCancel() bool {
	if m != nil {
		return m.Cancel
	}
	return false
}

// 合体技点数变化
type CombineSkillPoint struct {
	Point int32 `protobuf:"varint,1,opt,name=Point,proto3" json:"Point,omitempty"`
}

func (m *CombineSkillPoint) Reset()         { *m = CombineSkillPoint{} }
func (m *CombineSkillPoint) String() string { return proto.CompactTextString(m) }
func (*CombineSkillPoint) ProtoMessage()    {}
func (*CombineSkillPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{47}
}
func (m *CombineSkillPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombineSkillPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombineSkillPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombineSkillPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombineSkillPoint.Merge(m, src)
}
func (m *CombineSkillPoint) XXX_Size() int {
	return m.Size()
}
func (m *CombineSkillPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_CombineSkillPoint.DiscardUnknown(m)
}

var xxx_messageInfo_CombineSkillPoint proto.InternalMessageInfo

func (m *CombineSkillPoint) GetPoint() int32 {
	if m != nil {
		return m.Point
	}
	return 0
}

// 设置目标
type SetTarget struct {
	SelfId   uint32 `protobuf:"varint,1,opt,name=SelfId,proto3" json:"SelfId,omitempty"`
	TargetId uint32 `protobuf:"varint,2,opt,name=TargetId,proto3" json:"TargetId,omitempty"`
}

func (m *SetTarget) Reset()         { *m = SetTarget{} }
func (m *SetTarget) String() string { return proto.CompactTextString(m) }
func (*SetTarget) ProtoMessage()    {}
func (*SetTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{48}
}
func (m *SetTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTarget.Merge(m, src)
}
func (m *SetTarget) XXX_Size() int {
	return m.Size()
}
func (m *SetTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTarget.DiscardUnknown(m)
}

var xxx_messageInfo_SetTarget proto.InternalMessageInfo

func (m *SetTarget) GetSelfId() uint32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *SetTarget) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

// 伤害体Aoe位置角度信息
type AttackAoeTrans struct {
	Pos   *Position `protobuf:"bytes,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	Angle float32   `protobuf:"fixed32,2,opt,name=Angle,proto3" json:"Angle,omitempty"`
}

func (m *AttackAoeTrans) Reset()         { *m = AttackAoeTrans{} }
func (m *AttackAoeTrans) String() string { return proto.CompactTextString(m) }
func (*AttackAoeTrans) ProtoMessage()    {}
func (*AttackAoeTrans) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{49}
}
func (m *AttackAoeTrans) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackAoeTrans) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackAoeTrans.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackAoeTrans) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackAoeTrans.Merge(m, src)
}
func (m *AttackAoeTrans) XXX_Size() int {
	return m.Size()
}
func (m *AttackAoeTrans) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackAoeTrans.DiscardUnknown(m)
}

var xxx_messageInfo_AttackAoeTrans proto.InternalMessageInfo

func (m *AttackAoeTrans) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *AttackAoeTrans) GetAngle() float32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

// 伤害体Aoe形状信息
type AttackAoeShape struct {
	Type     AttackShapeType_Enum `protobuf:"varint,1,opt,name=Type,proto3,enum=AttackShapeType_Enum" json:"Type,omitempty"`
	Extend   *Position            `protobuf:"bytes,2,opt,name=Extend,proto3" json:"Extend,omitempty"`
	Radius   float32              `protobuf:"fixed32,3,opt,name=Radius,proto3" json:"Radius,omitempty"`
	FanAngle float32              `protobuf:"fixed32,4,opt,name=FanAngle,proto3" json:"FanAngle,omitempty"`
}

func (m *AttackAoeShape) Reset()         { *m = AttackAoeShape{} }
func (m *AttackAoeShape) String() string { return proto.CompactTextString(m) }
func (*AttackAoeShape) ProtoMessage()    {}
func (*AttackAoeShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{50}
}
func (m *AttackAoeShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackAoeShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackAoeShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackAoeShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackAoeShape.Merge(m, src)
}
func (m *AttackAoeShape) XXX_Size() int {
	return m.Size()
}
func (m *AttackAoeShape) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackAoeShape.DiscardUnknown(m)
}

var xxx_messageInfo_AttackAoeShape proto.InternalMessageInfo

func (m *AttackAoeShape) GetType() AttackShapeType_Enum {
	if m != nil {
		return m.Type
	}
	return AttackShapeType_Rect
}

func (m *AttackAoeShape) GetExtend() *Position {
	if m != nil {
		return m.Extend
	}
	return nil
}

func (m *AttackAoeShape) GetRadius() float32 {
	if m != nil {
		return m.Radius
	}
	return 0
}

func (m *AttackAoeShape) GetFanAngle() float32 {
	if m != nil {
		return m.FanAngle
	}
	return 0
}

// 显示伤害体Aoe
type AttackShowAoe struct {
	AttackId uint32          `protobuf:"varint,1,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
	Shape    *AttackAoeShape `protobuf:"bytes,2,opt,name=Shape,proto3" json:"Shape,omitempty"`
	Spawn    *AttackAoeTrans `protobuf:"bytes,3,opt,name=Spawn,proto3" json:"Spawn,omitempty"`
}

func (m *AttackShowAoe) Reset()         { *m = AttackShowAoe{} }
func (m *AttackShowAoe) String() string { return proto.CompactTextString(m) }
func (*AttackShowAoe) ProtoMessage()    {}
func (*AttackShowAoe) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{51}
}
func (m *AttackShowAoe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackShowAoe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackShowAoe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackShowAoe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackShowAoe.Merge(m, src)
}
func (m *AttackShowAoe) XXX_Size() int {
	return m.Size()
}
func (m *AttackShowAoe) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackShowAoe.DiscardUnknown(m)
}

var xxx_messageInfo_AttackShowAoe proto.InternalMessageInfo

func (m *AttackShowAoe) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

func (m *AttackShowAoe) GetShape() *AttackAoeShape {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *AttackShowAoe) GetSpawn() *AttackAoeTrans {
	if m != nil {
		return m.Spawn
	}
	return nil
}

// 移动伤害体Aoe
type AttackMoveAoe struct {
	AttackId uint32          `protobuf:"varint,1,opt,name=AttackId,proto3" json:"AttackId,omitempty"`
	Trans    *AttackAoeTrans `protobuf:"bytes,2,opt,name=Trans,proto3" json:"Trans,omitempty"`
}

func (m *AttackMoveAoe) Reset()         { *m = AttackMoveAoe{} }
func (m *AttackMoveAoe) String() string { return proto.CompactTextString(m) }
func (*AttackMoveAoe) ProtoMessage()    {}
func (*AttackMoveAoe) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{52}
}
func (m *AttackMoveAoe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttackMoveAoe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttackMoveAoe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttackMoveAoe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttackMoveAoe.Merge(m, src)
}
func (m *AttackMoveAoe) XXX_Size() int {
	return m.Size()
}
func (m *AttackMoveAoe) XXX_DiscardUnknown() {
	xxx_messageInfo_AttackMoveAoe.DiscardUnknown(m)
}

var xxx_messageInfo_AttackMoveAoe proto.InternalMessageInfo

func (m *AttackMoveAoe) GetAttackId() uint32 {
	if m != nil {
		return m.AttackId
	}
	return 0
}

func (m *AttackMoveAoe) GetTrans() *AttackAoeTrans {
	if m != nil {
		return m.Trans
	}
	return nil
}

// 刷怪结构体
type SpawnMonsterInfo struct {
	BattleFieldID uint32      `protobuf:"varint,1,opt,name=BattleFieldID,proto3" json:"BattleFieldID,omitempty"`
	PawnInfos     []*PawnInfo `protobuf:"bytes,2,rep,name=PawnInfos,proto3" json:"PawnInfos,omitempty"`
}

func (m *SpawnMonsterInfo) Reset()         { *m = SpawnMonsterInfo{} }
func (m *SpawnMonsterInfo) String() string { return proto.CompactTextString(m) }
func (*SpawnMonsterInfo) ProtoMessage()    {}
func (*SpawnMonsterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2392a956a271da54, []int{53}
}
func (m *SpawnMonsterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpawnMonsterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpawnMonsterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpawnMonsterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpawnMonsterInfo.Merge(m, src)
}
func (m *SpawnMonsterInfo) XXX_Size() int {
	return m.Size()
}
func (m *SpawnMonsterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SpawnMonsterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SpawnMonsterInfo proto.InternalMessageInfo

func (m *SpawnMonsterInfo) GetBattleFieldID() uint32 {
	if m != nil {
		return m.BattleFieldID
	}
	return 0
}

func (m *SpawnMonsterInfo) GetPawnInfos() []*PawnInfo {
	if m != nil {
		return m.PawnInfos
	}
	return nil
}

func init() {
	proto.RegisterEnum("PawnType_Enum", PawnType_Enum_name, PawnType_Enum_value)
	proto.RegisterEnum("Camp_Enum", Camp_Enum_name, Camp_Enum_value)
	proto.RegisterEnum("ActionType_Enum", ActionType_Enum_name, ActionType_Enum_value)
	proto.RegisterEnum("AttrType_Enum", AttrType_Enum_name, AttrType_Enum_value)
	proto.RegisterEnum("StatType_Enum", StatType_Enum_name, StatType_Enum_value)
	proto.RegisterEnum("AttackSrc_Enum", AttackSrc_Enum_name, AttackSrc_Enum_value)
	proto.RegisterEnum("AttackShapeType_Enum", AttackShapeType_Enum_name, AttackShapeType_Enum_value)
	proto.RegisterEnum("DamageType_Enum", DamageType_Enum_name, DamageType_Enum_value)
	proto.RegisterEnum("MoveMode_Enum", MoveMode_Enum_name, MoveMode_Enum_value)
	proto.RegisterEnum("HitType_Enum", HitType_Enum_name, HitType_Enum_value)
	proto.RegisterEnum("SkillState_Enum", SkillState_Enum_name, SkillState_Enum_value)
	proto.RegisterEnum("SkillBreakReason_Enum", SkillBreakReason_Enum_name, SkillBreakReason_Enum_value)
	proto.RegisterEnum("SkillEndReason_Enum", SkillEndReason_Enum_name, SkillEndReason_Enum_value)
	proto.RegisterEnum("FightLogType_Enum", FightLogType_Enum_name, FightLogType_Enum_value)
	proto.RegisterEnum("DamageFloatWordType_Enum", DamageFloatWordType_Enum_name, DamageFloatWordType_Enum_value)
	proto.RegisterType((*PawnType)(nil), "PawnType")
	proto.RegisterType((*Camp)(nil), "Camp")
	proto.RegisterType((*ActionType)(nil), "ActionType")
	proto.RegisterType((*AttrType)(nil), "AttrType")
	proto.RegisterType((*StatType)(nil), "StatType")
	proto.RegisterType((*AttackSrc)(nil), "AttackSrc")
	proto.RegisterType((*AttackShapeType)(nil), "AttackShapeType")
	proto.RegisterType((*DamageType)(nil), "DamageType")
	proto.RegisterType((*MoveMode)(nil), "MoveMode")
	proto.RegisterType((*HitType)(nil), "HitType")
	proto.RegisterType((*SkillState)(nil), "SkillState")
	proto.RegisterType((*SkillBreakReason)(nil), "SkillBreakReason")
	proto.RegisterType((*SkillEndReason)(nil), "SkillEndReason")
	proto.RegisterType((*FightLogType)(nil), "FightLogType")
	proto.RegisterType((*DamageFloatWordType)(nil), "DamageFloatWordType")
	proto.RegisterType((*FightAwardData)(nil), "FightAwardData")
	proto.RegisterMapType((map[uint32]uint32)(nil), "FightAwardData.AwardsEntry")
	proto.RegisterType((*FightResult)(nil), "FightResult")
	proto.RegisterMapType((map[uint32]uint32)(nil), "FightResult.DelayRewardsEntry")
	proto.RegisterType((*DebugSceneInfo)(nil), "DebugSceneInfo")
	proto.RegisterType((*Position)(nil), "Position")
	proto.RegisterType((*FightRoleInfo)(nil), "FightRoleInfo")
	proto.RegisterMapType((map[int32]uint32)(nil), "FightRoleInfo.EquipsEntry")
	proto.RegisterType((*FightAIInfo)(nil), "FightAIInfo")
	proto.RegisterType((*FightNpcInfo)(nil), "FightNpcInfo")
	proto.RegisterType((*PawnInherit)(nil), "PawnInherit")
	proto.RegisterType((*FightInherit)(nil), "FightInherit")
	proto.RegisterMapType((map[string]*PawnInherit)(nil), "FightInherit.PawnInheritMapEntry")
	proto.RegisterType((*PawnInfo)(nil), "PawnInfo")
	proto.RegisterType((*FightReplay)(nil), "FightReplay")
	proto.RegisterType((*FightFrame)(nil), "FightFrame")
	proto.RegisterType((*FightAction)(nil), "FightAction")
	proto.RegisterType((*SummonPawn)(nil), "SummonPawn")
	proto.RegisterType((*MoveBegin)(nil), "MoveBegin")
	proto.RegisterType((*MoveEnd)(nil), "MoveEnd")
	proto.RegisterType((*FixMoveData)(nil), "FixMoveData")
	proto.RegisterType((*UseSkill)(nil), "UseSkill")
	proto.RegisterType((*BreakSkill)(nil), "BreakSkill")
	proto.RegisterType((*NewAttack)(nil), "NewAttack")
	proto.RegisterType((*DelAttack)(nil), "DelAttack")
	proto.RegisterType((*AttackHit)(nil), "AttackHit")
	proto.RegisterType((*BeHit)(nil), "BeHit")
	proto.RegisterType((*AddBuff)(nil), "AddBuff")
	proto.RegisterType((*RemoveBuff)(nil), "RemoveBuff")
	proto.RegisterType((*ChangeAttr)(nil), "ChangeAttr")
	proto.RegisterType((*ChangeStat)(nil), "ChangeStat")
	proto.RegisterType((*FightBegin)(nil), "FightBegin")
	proto.RegisterType((*FightEnd)(nil), "FightEnd")
	proto.RegisterType((*DebugInfo)(nil), "DebugInfo")
	proto.RegisterType((*ChangeSkillState)(nil), "ChangeSkillState")
	proto.RegisterType((*CombineSkillEndTime)(nil), "CombineSkillEndTime")
	proto.RegisterType((*CombineSkillPoint)(nil), "CombineSkillPoint")
	proto.RegisterType((*SetTarget)(nil), "SetTarget")
	proto.RegisterType((*AttackAoeTrans)(nil), "AttackAoeTrans")
	proto.RegisterType((*AttackAoeShape)(nil), "AttackAoeShape")
	proto.RegisterType((*AttackShowAoe)(nil), "AttackShowAoe")
	proto.RegisterType((*AttackMoveAoe)(nil), "AttackMoveAoe")
	proto.RegisterType((*SpawnMonsterInfo)(nil), "SpawnMonsterInfo")
}

func init() { proto.RegisterFile("FightDef.proto", fileDescriptor_2392a956a271da54) }

var fileDescriptor_2392a956a271da54 = []byte{
	// 2976 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x39, 0x4b, 0x6f, 0x23, 0xc7,
	0xd1, 0x9a, 0xe1, 0xbb, 0x28, 0x52, 0xa3, 0xde, 0x87, 0xc7, 0xeb, 0x0f, 0xf2, 0xee, 0x7c, 0xeb,
	0xdd, 0xb5, 0xe1, 0x6f, 0x80, 0x6f, 0xbd, 0x81, 0x1d, 0x07, 0xb1, 0x2d, 0x92, 0xd2, 0x2e, 0xe1,
	0x95, 0x56, 0x68, 0xae, 0xbd, 0x76, 0x10, 0x04, 0x18, 0x93, 0x2d, 0x6a, 0x22, 0x72, 0x86, 0x9e,
	0x19, 0x4a, 0xab, 0xfc, 0x81, 0xe4, 0x92, 0x20, 0xc8, 0x7f, 0xc8, 0x25, 0xa7, 0x20, 0xbf, 0x20,
	0xc7, 0x1c, 0x0d, 0xe4, 0xe2, 0x63, 0x60, 0xdf, 0x92, 0x1f, 0x90, 0x5b, 0x10, 0x54, 0x75, 0xf7,
	0xbc, 0x48, 0xc9, 0x88, 0x91, 0xd3, 0x4c, 0x3d, 0xba, 0xba, 0xba, 0x5e, 0xdd, 0x5d, 0x0d, 0xdd,
	0x7d, 0x7f, 0x7a, 0x92, 0x0c, 0xc4, 0xb1, 0xbb, 0x88, 0xc2, 0x24, 0x74, 0xfe, 0x0f, 0x9a, 0x47,
	0xde, 0x79, 0xf0, 0xfc, 0x62, 0x21, 0x9c, 0x3b, 0x50, 0xdd, 0x0b, 0x96, 0x73, 0xd6, 0x84, 0x2a,
	0x0f, 0x67, 0xc2, 0xda, 0x60, 0x0d, 0xa8, 0x1c, 0x2e, 0xc6, 0x96, 0xc1, 0xea, 0x60, 0xf6, 0x1e,
	0x5b, 0x26, 0xb2, 0xf4, 0xbd, 0xf9, 0xc2, 0x79, 0x55, 0xb1, 0x36, 0xa0, 0xc2, 0xc5, 0xc4, 0xda,
	0xc0, 0x31, 0xbd, 0xd9, 0x52, 0x58, 0x86, 0xf3, 0xeb, 0x0a, 0xc0, 0xee, 0x38, 0xf1, 0x43, 0x29,
	0xf4, 0x5f, 0xa6, 0x62, 0xed, 0x40, 0xeb, 0x20, 0x3c, 0x13, 0x3d, 0x31, 0xf5, 0x03, 0x6b, 0x83,
	0x6d, 0x41, 0x7b, 0xdf, 0x7f, 0x89, 0x98, 0x81, 0x97, 0x78, 0x96, 0xc1, 0xda, 0xd0, 0x40, 0x68,
	0x2f, 0x98, 0x58, 0x26, 0xdb, 0x84, 0xe6, 0x27, 0xb1, 0x18, 0x9d, 0xfa, 0xb3, 0x99, 0x55, 0x61,
	0x5d, 0x80, 0x5e, 0x24, 0xbc, 0x53, 0x09, 0x57, 0x51, 0xd4, 0xa1, 0x38, 0xdf, 0x4d, 0x12, 0x6f,
	0x7c, 0x6a, 0xd5, 0x10, 0x1c, 0x88, 0x99, 0x02, 0xeb, 0x08, 0xca, 0xff, 0x27, 0x7e, 0x62, 0x35,
	0x58, 0x0b, 0x6a, 0x3d, 0x81, 0xbf, 0x4d, 0x9c, 0x62, 0x77, 0x32, 0xe9, 0x2d, 0x8f, 0x8f, 0xad,
	0x16, 0x0a, 0xe5, 0x62, 0x8e, 0x1a, 0x21, 0x0c, 0x08, 0xf7, 0x4f, 0xbc, 0x60, 0x2a, 0x76, 0x93,
	0x24, 0xb2, 0xda, 0x19, 0x3c, 0x4a, 0xbc, 0xc4, 0xda, 0x44, 0x98, 0x6c, 0x27, 0x17, 0xd0, 0x41,
	0x15, 0x09, 0x46, 0x85, 0xbb, 0x52, 0x87, 0x2f, 0x96, 0xd3, 0x61, 0x70, 0x1c, 0x5a, 0x5b, 0xec,
	0x3a, 0x58, 0x6a, 0x30, 0xaa, 0x8c, 0x12, 0x84, 0x65, 0xb1, 0x57, 0xe0, 0x5a, 0x3f, 0x9c, 0x7f,
	0xe1, 0x07, 0x12, 0xbd, 0x17, 0x4c, 0x9e, 0xfb, 0x73, 0x61, 0x6d, 0xb3, 0x1b, 0xb0, 0x9d, 0x27,
	0x1c, 0x85, 0x7e, 0x90, 0x58, 0x0c, 0x85, 0x8e, 0x44, 0xf2, 0xdc, 0x8b, 0xa6, 0x22, 0xb1, 0xae,
	0xb1, 0x6d, 0xe8, 0xc8, 0x85, 0x8d, 0x4e, 0xc2, 0xf3, 0xdd, 0x50, 0x58, 0xd7, 0x33, 0x14, 0x9a,
	0x0e, 0x51, 0x37, 0x50, 0xcf, 0xd1, 0x72, 0x3e, 0x0f, 0x03, 0xf4, 0xab, 0x75, 0xd3, 0xf9, 0x93,
	0x01, 0x4d, 0x5c, 0x12, 0x79, 0xe3, 0xf7, 0x86, 0xf2, 0x46, 0x0b, 0x6a, 0xfd, 0x65, 0xf4, 0xe4,
	0xc8, 0xda, 0xc0, 0xdf, 0x03, 0xef, 0xe5, 0x93, 0x23, 0xcb, 0xc0, 0x35, 0x3d, 0x39, 0x1a, 0x9d,
	0xf8, 0x62, 0x86, 0x4e, 0xb8, 0x09, 0xec, 0x93, 0x59, 0xe2, 0xcf, 0xbd, 0x44, 0xab, 0x75, 0x2e,
	0x22, 0xab, 0xc2, 0x18, 0x74, 0x9f, 0x9d, 0x89, 0x68, 0x10, 0xf9, 0x67, 0x42, 0xe2, 0xaa, 0xc8,
	0xdb, 0x5f, 0x46, 0xbd, 0x59, 0x38, 0x3e, 0x25, 0x57, 0x7d, 0xea, 0x61, 0x34, 0xd4, 0x70, 0x65,
	0x87, 0x61, 0x34, 0xf7, 0x94, 0x7b, 0x46, 0x0b, 0x21, 0x26, 0x56, 0x1d, 0xe7, 0x1c, 0x8d, 0xbd,
	0x99, 0xb0, 0x1a, 0xec, 0x1a, 0x6c, 0xf5, 0xc3, 0xd9, 0xcc, 0x8f, 0xfd, 0x30, 0xe0, 0xde, 0xc4,
	0x5f, 0xc6, 0x56, 0xd3, 0xf9, 0x08, 0x9a, 0x68, 0x34, 0xd2, 0xf9, 0x51, 0x16, 0x96, 0x03, 0xe1,
	0x61, 0xb0, 0x75, 0xa0, 0x95, 0x2a, 0x60, 0x19, 0xe4, 0x61, 0x9c, 0xd3, 0x32, 0x91, 0xe7, 0x05,
	0xfe, 0x55, 0x9c, 0x47, 0x3a, 0x0a, 0x46, 0xd1, 0xd8, 0xb9, 0x9f, 0xad, 0x5a, 0xc6, 0x90, 0x0c,
	0x58, 0x74, 0xbc, 0xc1, 0x00, 0xea, 0xfd, 0x65, 0x9c, 0x84, 0x73, 0xcb, 0x74, 0xde, 0x83, 0x2d,
	0x6d, 0x62, 0x6f, 0x21, 0x68, 0xfa, 0x37, 0x72, 0x59, 0x21, 0xc6, 0x89, 0xb5, 0x41, 0x03, 0xfc,
	0x68, 0x3c, 0xc3, 0xb9, 0x1b, 0x50, 0xd9, 0xf7, 0x02, 0xcb, 0x74, 0x7e, 0x01, 0x30, 0xf0, 0xe6,
	0xde, 0x54, 0x0e, 0x9a, 0xa9, 0x41, 0x00, 0x75, 0x89, 0x95, 0x5a, 0x73, 0x31, 0x0e, 0xcf, 0x44,
	0x44, 0xb6, 0x6e, 0x42, 0xb5, 0x1f, 0xf9, 0x89, 0x65, 0xa2, 0x56, 0x83, 0x70, 0x32, 0x15, 0x56,
	0x85, 0x96, 0x82, 0x36, 0xb4, 0xaa, 0x68, 0x97, 0xbd, 0x97, 0x62, 0xbe, 0xc0, 0x4c, 0x52, 0x32,
	0x6a, 0x38, 0xe8, 0xc0, 0x8f, 0x63, 0xab, 0x8e, 0x92, 0x87, 0xc1, 0x99, 0x88, 0x12, 0xab, 0xe1,
	0x8c, 0xa1, 0x89, 0xfe, 0x3f, 0x08, 0x27, 0xc2, 0x79, 0x91, 0xa9, 0x7b, 0x18, 0x06, 0x2a, 0x89,
	0xf9, 0x32, 0x90, 0x33, 0xee, 0x7b, 0x31, 0xce, 0x08, 0x50, 0x7f, 0x1a, 0x86, 0xa7, 0xbb, 0x89,
	0x4c, 0x2e, 0xf9, 0xdf, 0xf3, 0x68, 0xde, 0x36, 0x34, 0x9e, 0xf8, 0x12, 0xa8, 0x65, 0xaa, 0xd5,
	0x9d, 0x73, 0xc2, 0x17, 0x56, 0x57, 0x98, 0x03, 0x53, 0x8c, 0x8c, 0xd9, 0x8b, 0xc2, 0x53, 0x11,
	0x48, 0x67, 0x0c, 0xc2, 0xf3, 0x40, 0x2e, 0x6b, 0x7f, 0x16, 0x7a, 0x89, 0x14, 0xcf, 0x85, 0x04,
	0x68, 0x39, 0xa3, 0x64, 0x19, 0xc8, 0x80, 0x90, 0x0b, 0x6f, 0x50, 0xb6, 0xa7, 0x71, 0x64, 0x35,
	0x9d, 0x29, 0x40, 0x96, 0x45, 0xce, 0xe7, 0xd9, 0xdc, 0x2f, 0x3c, 0x3f, 0x91, 0xf1, 0xcb, 0x85,
	0x37, 0xb9, 0x90, 0xf1, 0x8b, 0xb9, 0x41, 0x59, 0x65, 0xe2, 0x54, 0x03, 0x2f, 0x3e, 0xf1, 0x83,
	0xa9, 0x55, 0x21, 0xc5, 0xc4, 0x71, 0x18, 0x09, 0xab, 0x8a, 0xff, 0x69, 0xf1, 0x68, 0x41, 0xed,
	0xa9, 0x97, 0x88, 0xc8, 0xaa, 0x3b, 0x1f, 0x80, 0x45, 0x13, 0xd1, 0xc4, 0x5c, 0x78, 0x71, 0x18,
	0x38, 0x6f, 0x65, 0x8e, 0x94, 0x71, 0x2c, 0x27, 0xc4, 0x6c, 0x0d, 0x65, 0xd1, 0xda, 0x1d, 0x1e,
	0x79, 0xcb, 0x58, 0x58, 0xa6, 0xf3, 0x18, 0xba, 0x3a, 0xaf, 0xd5, 0xe8, 0x1f, 0xac, 0x1f, 0x2d,
	0x57, 0x56, 0x1c, 0x9d, 0x49, 0xad, 0x38, 0x1f, 0xc0, 0x26, 0x95, 0x96, 0xa7, 0xe1, 0x94, 0xec,
	0xed, 0x66, 0x62, 0x46, 0xfe, 0x7c, 0x41, 0xa5, 0x19, 0x23, 0x4b, 0x24, 0x9e, 0x3f, 0xb3, 0x0c,
	0xb4, 0xd8, 0x51, 0x14, 0x4e, 0x23, 0x6f, 0x3e, 0x17, 0x91, 0x65, 0x3a, 0x3f, 0x82, 0x6b, 0x32,
	0x62, 0xc8, 0xce, 0x2f, 0xc2, 0x68, 0x42, 0x62, 0xee, 0xae, 0xd1, 0xc6, 0x82, 0xcd, 0x7c, 0xe5,
	0xb1, 0x0c, 0xac, 0x17, 0x72, 0x93, 0xd8, 0x3d, 0xf7, 0xa2, 0x09, 0x16, 0x67, 0xf6, 0x0e, 0xd4,
	0x09, 0x88, 0x6d, 0xe3, 0x76, 0xe5, 0x41, 0xfb, 0xe1, 0x6b, 0x6e, 0x91, 0xc1, 0x95, 0xd4, 0xbd,
	0x20, 0x89, 0x2e, 0xb8, 0x62, 0x65, 0x36, 0x34, 0xfa, 0xcb, 0x08, 0x5d, 0x61, 0x9b, 0xb7, 0x8d,
	0x07, 0x15, 0xae, 0x41, 0x76, 0x13, 0xea, 0xa3, 0x53, 0x7f, 0xd1, 0x7f, 0x6c, 0x57, 0x6e, 0x1b,
	0x0f, 0x9a, 0x5c, 0x41, 0xb7, 0x7e, 0x08, 0xed, 0x9c, 0x20, 0x66, 0x41, 0xe5, 0x54, 0x5c, 0xd8,
	0xc6, 0x6d, 0xe3, 0x41, 0x87, 0xe3, 0x2f, 0xbb, 0x0e, 0xb5, 0x33, 0xac, 0x2b, 0x24, 0xb0, 0xc3,
	0x25, 0xf0, 0xbe, 0xf9, 0x9e, 0xe1, 0xfc, 0xb3, 0x8a, 0xdb, 0xc9, 0xf4, 0x24, 0xe1, 0x22, 0x5e,
	0xce, 0x12, 0xd6, 0x05, 0x73, 0x38, 0xa1, 0xa1, 0x2d, 0x6e, 0x0e, 0x27, 0xec, 0x16, 0x34, 0xc9,
	0x42, 0x22, 0x8e, 0xd5, 0xe0, 0x14, 0x46, 0x75, 0x86, 0x71, 0x2f, 0x8c, 0x63, 0xad, 0x8e, 0x84,
	0xd8, 0x3d, 0xe8, 0x8e, 0x12, 0x2f, 0x4a, 0x50, 0xe7, 0x38, 0xf1, 0xe6, 0x0b, 0xbb, 0x4a, 0xeb,
	0x28, 0x61, 0x19, 0x83, 0x2a, 0xad, 0xb2, 0x46, 0x72, 0xe9, 0x1f, 0xe7, 0xe3, 0xc2, 0x9b, 0x11,
	0xbe, 0x2e, 0xe7, 0xd3, 0x30, 0xbb, 0x0b, 0x8d, 0x67, 0xcb, 0x64, 0x1c, 0xce, 0x85, 0xdd, 0xb8,
	0x5d, 0x79, 0xd0, 0x7d, 0x08, 0x2e, 0xee, 0xa9, 0x2e, 0xfa, 0x86, 0x6b, 0x12, 0xbb, 0x0f, 0x2d,
	0x2c, 0xe0, 0xb8, 0x9f, 0xc4, 0x76, 0x93, 0xcc, 0xde, 0x72, 0x35, 0x86, 0x67, 0x34, 0x76, 0x17,
	0xea, 0x5c, 0x2c, 0x66, 0xde, 0x85, 0xdd, 0xba, 0x6d, 0x3c, 0x68, 0x3f, 0xdc, 0x74, 0x95, 0x21,
	0x10, 0xc7, 0x15, 0x8d, 0xb9, 0xd0, 0xa6, 0xfd, 0x49, 0xb1, 0xc2, 0x1a, 0xd6, 0x3c, 0x03, 0xeb,
	0xc1, 0xe6, 0x40, 0x20, 0x56, 0x48, 0xc7, 0xb7, 0x49, 0x83, 0x1d, 0x37, 0x67, 0x64, 0x37, 0xcf,
	0x20, 0x7d, 0x5f, 0x18, 0xc3, 0xde, 0x85, 0x2e, 0x89, 0x1c, 0x8d, 0x45, 0x20, 0x50, 0x59, 0x7b,
	0x93, 0xa6, 0xdd, 0x72, 0x8b, 0x68, 0x5e, 0x62, 0x63, 0xf7, 0xa1, 0x31, 0x0c, 0x4e, 0x44, 0xe4,
	0x27, 0x76, 0x87, 0x46, 0x74, 0xe4, 0xbc, 0x0a, 0xc9, 0x35, 0x95, 0xdd, 0x85, 0x4e, 0xcf, 0x4b,
	0x92, 0x99, 0xd8, 0xc7, 0x2d, 0x6b, 0x38, 0xb0, 0xbb, 0x64, 0xeb, 0x22, 0x12, 0x9d, 0xd1, 0x0f,
	0xe7, 0x73, 0x3f, 0x19, 0x0e, 0xec, 0x2d, 0x0a, 0x89, 0x14, 0xbe, 0xf5, 0x21, 0x6c, 0xaf, 0x2c,
	0xe3, 0x3f, 0x8a, 0xbc, 0x7e, 0x79, 0x91, 0xec, 0xff, 0xa1, 0xdb, 0x0b, 0x97, 0xc1, 0xc4, 0x8b,
	0x2e, 0x68, 0x23, 0xd7, 0x59, 0xd3, 0x72, 0x8f, 0xc2, 0xd8, 0xc7, 0x72, 0xce, 0x4b, 0x0c, 0xce,
	0x3d, 0x68, 0x6a, 0x1a, 0xdb, 0x04, 0xe3, 0x33, 0x9a, 0xda, 0xe4, 0xc6, 0x67, 0x08, 0x7d, 0x4e,
	0x93, 0x9a, 0xdc, 0xf8, 0xdc, 0xf9, 0xb3, 0x01, 0x1d, 0xe9, 0x81, 0x70, 0x26, 0x27, 0xbb, 0x09,
	0x75, 0xfa, 0xd7, 0xc1, 0xae, 0x20, 0x0c, 0xca, 0x43, 0x4f, 0xa5, 0x5e, 0x8b, 0xd3, 0x3f, 0x2e,
	0x82, 0xb6, 0x6b, 0x8a, 0xf3, 0x2a, 0x97, 0x00, 0x7b, 0x08, 0xf5, 0xbd, 0x2f, 0x97, 0xfe, 0x22,
	0xb6, 0xab, 0xa4, 0xe6, 0x2d, 0xb7, 0x30, 0x83, 0x2b, 0x89, 0x2a, 0xb7, 0x25, 0x80, 0x99, 0x9a,
	0x43, 0xe7, 0xed, 0x55, 0xfb, 0x2e, 0x7b, 0xbd, 0xab, 0x12, 0x75, 0x77, 0x48, 0xfa, 0x33, 0xa8,
	0xee, 0x0e, 0x87, 0x03, 0xa5, 0x3d, 0xfd, 0x67, 0x7a, 0x9a, 0x39, 0x3d, 0x9d, 0x9f, 0xaa, 0xa2,
	0x78, 0xb8, 0x18, 0xd3, 0xc8, 0x5b, 0xd0, 0x3c, 0xf0, 0xe2, 0x44, 0x44, 0x6a, 0xed, 0x1d, 0x9e,
	0xc2, 0xb9, 0x94, 0x36, 0x0b, 0x29, 0x6d, 0x43, 0x63, 0xb4, 0xc0, 0xcc, 0x19, 0x90, 0x0d, 0x5a,
	0x5c, 0x83, 0xce, 0x8f, 0xa1, 0x2d, 0x53, 0x4a, 0x06, 0x96, 0xbb, 0xee, 0xe8, 0xa3, 0x16, 0xb8,
	0x86, 0xe2, 0xfc, 0xc1, 0x50, 0xda, 0x69, 0x01, 0x43, 0xe8, 0xe6, 0xe4, 0x1d, 0x78, 0x0b, 0x15,
	0x04, 0x77, 0x0a, 0x91, 0xec, 0x16, 0x79, 0xa4, 0x91, 0x4b, 0x03, 0x6f, 0x3d, 0x83, 0x6b, 0x6b,
	0xd8, 0xf2, 0x46, 0x6f, 0x49, 0xa3, 0x3b, 0x79, 0xa3, 0x63, 0x76, 0xe7, 0x86, 0xe5, 0x5d, 0xf0,
	0xb5, 0x29, 0x0f, 0xfd, 0x64, 0xc6, 0xac, 0x52, 0x76, 0x74, 0xa5, 0xec, 0x87, 0xc1, 0xb1, 0x3f,
	0x1d, 0x4e, 0x74, 0xa5, 0xd4, 0x30, 0x73, 0xa0, 0x8a, 0x1b, 0x09, 0xd9, 0xae, 0xfb, 0xb0, 0xeb,
	0xea, 0x9b, 0x83, 0x2c, 0x5d, 0x44, 0x43, 0x1e, 0x0c, 0x1d, 0xaa, 0x95, 0xed, 0x87, 0xdd, 0x62,
	0x30, 0x71, 0xa2, 0xb1, 0xd7, 0xe9, 0x5a, 0x41, 0x05, 0x33, 0xcd, 0x6d, 0xe5, 0x56, 0x8e, 0x14,
	0xb6, 0x23, 0xaf, 0x19, 0x54, 0x3a, 0x8b, 0xf5, 0x91, 0xf0, 0xec, 0x7f, 0xa1, 0xd1, 0x0b, 0xa3,
	0xe0, 0x28, 0x8c, 0xed, 0x06, 0x09, 0xc9, 0xe5, 0x96, 0xa6, 0xb0, 0xff, 0x81, 0x16, 0xfe, 0xee,
	0x06, 0xd3, 0x99, 0xb0, 0x9b, 0x94, 0x42, 0x19, 0x02, 0x83, 0xec, 0xa9, 0x38, 0x13, 0x33, 0xaa,
	0x9a, 0x35, 0x2e, 0x01, 0xe6, 0x28, 0x37, 0xee, 0x05, 0x13, 0x3c, 0x6b, 0xda, 0x6d, 0x0a, 0x9f,
	0x02, 0x0e, 0x2d, 0x34, 0x8c, 0xe5, 0x11, 0x9b, 0x0a, 0x5a, 0x93, 0xa7, 0xb0, 0xf3, 0x5e, 0xba,
	0x0d, 0x51, 0x15, 0x7d, 0x13, 0x5a, 0xfb, 0x91, 0x37, 0x17, 0x4f, 0xfd, 0x38, 0x51, 0x01, 0xd0,
	0x96, 0xcb, 0x25, 0x34, 0xcf, 0xa8, 0xce, 0xa7, 0xea, 0x7a, 0x41, 0x18, 0x9c, 0x63, 0x24, 0xbe,
	0x5c, 0x8a, 0x60, 0x2c, 0x74, 0x70, 0x6b, 0x98, 0xbd, 0xad, 0xef, 0x57, 0x24, 0xd5, 0x24, 0xa9,
	0xaa, 0x92, 0x4b, 0x3c, 0xcf, 0xd1, 0x9d, 0xbf, 0x83, 0x4e, 0x38, 0xc2, 0xb1, 0xbb, 0xca, 0x87,
	0x06, 0x99, 0xd6, 0x72, 0xb3, 0xab, 0x5a, 0xde, 0x8b, 0x8f, 0x60, 0x4b, 0x12, 0xd2, 0x2b, 0x9b,
	0x0a, 0x2a, 0x70, 0x53, 0x0c, 0x2f, 0xb3, 0xb0, 0xf7, 0x61, 0x5b, 0xa2, 0x72, 0x37, 0x3b, 0x0a,
	0x16, 0xa9, 0x60, 0x8a, 0xe3, 0xab, 0x6c, 0xcc, 0x85, 0x4e, 0x26, 0x6e, 0x2f, 0x98, 0xa8, 0x00,
	0x6a, 0xba, 0x0a, 0xe6, 0x45, 0x32, 0x56, 0x59, 0x89, 0xd0, 0xf7, 0x44, 0x15, 0x4e, 0x2d, 0x57,
	0x23, 0x78, 0x89, 0x81, 0xbd, 0x0b, 0x96, 0xc4, 0x64, 0x97, 0x49, 0x8a, 0x30, 0x74, 0x4a, 0x86,
	0xe2, 0x2b, 0x4c, 0x99, 0x35, 0xd2, 0x5b, 0xa7, 0x0a, 0x3b, 0x70, 0x53, 0x0c, 0x2f, 0xb3, 0x64,
	0xa3, 0xd2, 0xcb, 0x29, 0x45, 0x21, 0x8e, 0x4a, 0x31, 0xbc, 0xcc, 0x92, 0x8d, 0x4a, 0xef, 0xb0,
	0x6a, 0x5f, 0x07, 0x37, 0xc5, 0xf0, 0x32, 0x0b, 0x7b, 0x00, 0x6d, 0xa5, 0x35, 0x5e, 0x75, 0xd5,
	0xf6, 0x5e, 0x77, 0x09, 0xe2, 0x79, 0x52, 0x66, 0x67, 0x75, 0x13, 0xa6, 0x10, 0x47, 0x3b, 0x2b,
	0x98, 0x17, 0xc9, 0x99, 0xd1, 0xb2, 0xcb, 0xb2, 0xda, 0xc6, 0xdb, 0x6e, 0x86, 0xe2, 0x2b, 0x4c,
	0xd9, 0xc0, 0xec, 0x56, 0xad, 0x76, 0xf3, 0xb6, 0x9b, 0xa1, 0xf8, 0x0a, 0x53, 0x79, 0x20, 0x1e,
	0xfb, 0x69, 0x5f, 0xcf, 0x06, 0x22, 0x8a, 0xaf, 0x30, 0x65, 0x03, 0xb3, 0x7b, 0x3a, 0xed, 0xf7,
	0x69, 0xd2, 0xc9, 0xb0, 0x5d, 0x61, 0xca, 0x62, 0x49, 0xe7, 0xb9, 0x6d, 0xa9, 0x58, 0xd2, 0x08,
	0x5e, 0x62, 0xc8, 0x3b, 0x57, 0xdd, 0xfa, 0xed, 0xed, 0xd4, 0xb9, 0x0a, 0xc3, 0xcb, 0x2c, 0x6c,
	0x08, 0x37, 0x0b, 0x5a, 0xa7, 0xd7, 0x1a, 0x9b, 0xd1, 0xe0, 0x6d, 0xb7, 0x4c, 0xe0, 0x97, 0x0c,
	0x60, 0x1c, 0x5e, 0x55, 0x94, 0xd5, 0x8e, 0x82, 0x7d, 0x8d, 0xa4, 0x5d, 0x77, 0xd7, 0xd0, 0xf8,
	0xe5, 0xc3, 0xd8, 0x53, 0x78, 0x65, 0x95, 0x48, 0x47, 0x14, 0xfb, 0x3a, 0x49, 0x64, 0xee, 0x0a,
	0x85, 0x5f, 0x36, 0x24, 0x33, 0x51, 0xda, 0xc3, 0xb0, 0x6f, 0x28, 0x13, 0xa5, 0x18, 0x5e, 0x66,
	0x61, 0x1f, 0xc1, 0xb5, 0x7c, 0x70, 0xab, 0x56, 0x87, 0x7d, 0x53, 0x6d, 0x27, 0x05, 0x2c, 0x5f,
	0xc7, 0x5a, 0x96, 0xa0, 0x3a, 0x23, 0xf6, 0x2b, 0x05, 0x09, 0x0a, 0xcb, 0xd7, 0xb1, 0x66, 0x81,
	0x94, 0x35, 0x52, 0x6c, 0x5b, 0x05, 0x52, 0x86, 0xe2, 0x2b, 0x4c, 0xce, 0xdd, 0x7c, 0xef, 0x85,
	0xee, 0x39, 0x62, 0x76, 0x9c, 0x6e, 0xaf, 0x0a, 0x72, 0xfe, 0x6a, 0xe6, 0x5a, 0x61, 0x97, 0x71,
	0xb1, 0xb7, 0xb2, 0x4b, 0x3d, 0xd5, 0x5e, 0xdc, 0x70, 0x35, 0x42, 0x96, 0xea, 0x94, 0x8e, 0x9b,
	0x99, 0xdc, 0xe6, 0x2a, 0xb4, 0xcd, 0x49, 0x80, 0xbd, 0x06, 0x15, 0xdc, 0x21, 0xab, 0xe5, 0x1d,
	0x12, 0xb1, 0x38, 0x84, 0x9a, 0x31, 0x54, 0x36, 0x4d, 0x2e, 0x01, 0xbc, 0x75, 0xc8, 0x66, 0x00,
	0x0e, 0xac, 0x97, 0x07, 0x66, 0x34, 0xf6, 0x08, 0x6e, 0x1c, 0x0a, 0x31, 0x19, 0x25, 0x42, 0x44,
	0x7e, 0x30, 0x1d, 0xcd, 0xc3, 0x30, 0xc1, 0x9b, 0x36, 0x15, 0xc6, 0x26, 0x5f, 0x4f, 0x64, 0x6f,
	0xc3, 0xf6, 0xde, 0xcb, 0x85, 0x18, 0x27, 0xaa, 0x8a, 0x53, 0xb0, 0x36, 0x69, 0xd9, 0xab, 0x04,
	0xe4, 0xde, 0x1d, 0x27, 0x4b, 0x6f, 0x96, 0xe7, 0x6e, 0x49, 0xee, 0x15, 0x82, 0xf3, 0xf3, 0xb4,
	0x7f, 0xf8, 0x5f, 0x31, 0xa9, 0x32, 0x5e, 0x65, 0x9d, 0xf1, 0x9c, 0xdf, 0x18, 0x85, 0xee, 0xe5,
	0xa5, 0x13, 0x2a, 0x21, 0xe6, 0x65, 0x1e, 0x58, 0xe3, 0xb4, 0x4b, 0x0d, 0x5b, 0xbd, 0xc2, 0xb0,
	0xce, 0x3f, 0x8c, 0xac, 0x61, 0x4a, 0x47, 0xb8, 0xd2, 0xc9, 0x58, 0xc3, 0x74, 0x02, 0x46, 0xa6,
	0xf4, 0x74, 0xa7, 0x41, 0x1c, 0x25, 0x53, 0x70, 0x38, 0x21, 0x8d, 0x3a, 0x3c, 0x85, 0x31, 0x2c,
	0xe4, 0xff, 0xda, 0x78, 0xca, 0x68, 0x6c, 0x87, 0x7a, 0x35, 0x0b, 0xd9, 0x69, 0xa1, 0xd0, 0x6a,
	0xf2, 0x1c, 0x06, 0xcf, 0x64, 0x08, 0x51, 0xc7, 0x85, 0xe2, 0xab, 0xc9, 0x33, 0x04, 0xde, 0xb8,
	0x55, 0x19, 0x91, 0xfa, 0xc6, 0x74, 0x41, 0xee, 0xf0, 0x12, 0xd6, 0xf9, 0x59, 0xbe, 0x1f, 0x7c,
	0xe5, 0x72, 0xf3, 0x8b, 0x32, 0x4b, 0x8b, 0xca, 0x99, 0xa2, 0x52, 0x30, 0x85, 0xf3, 0xcb, 0x4a,
	0xae, 0xc1, 0x7c, 0xa5, 0xfc, 0x3b, 0x50, 0x19, 0x45, 0x63, 0x15, 0x4c, 0x5b, 0x6e, 0xda, 0x71,
	0x94, 0xd1, 0x84, 0xb4, 0xcb, 0xa7, 0xc1, 0x00, 0x18, 0x06, 0x13, 0xf1, 0x92, 0x2c, 0xda, 0xe1,
	0x12, 0x40, 0x7e, 0xdc, 0x3f, 0x3f, 0x16, 0x17, 0x64, 0xbf, 0x2a, 0xd7, 0x20, 0x46, 0x19, 0xfe,
	0x0e, 0x27, 0xaa, 0xa5, 0xa0, 0xa0, 0xc2, 0x91, 0xbd, 0x51, 0x3a, 0xb2, 0xdf, 0xa2, 0xe6, 0xaf,
	0x37, 0x3e, 0x1d, 0x4e, 0x54, 0xa2, 0xa5, 0x70, 0xc1, 0x38, 0xad, 0xab, 0x3c, 0x0e, 0x57, 0x78,
	0xfc, 0x36, 0xb4, 0xd3, 0x5a, 0x36, 0x94, 0x07, 0xe6, 0x0e, 0xcf, 0xa3, 0x34, 0x87, 0x4e, 0xe0,
	0xcd, 0x8c, 0x43, 0x27, 0xba, 0x0d, 0x8d, 0xc7, 0x51, 0xb8, 0x5c, 0x0c, 0x07, 0x74, 0x42, 0xe8,
	0x70, 0x0d, 0x3a, 0xf7, 0x73, 0xad, 0xfd, 0xc2, 0x5a, 0x8c, 0xe2, 0x5a, 0x9c, 0x3f, 0x9a, 0xb9,
	0xae, 0x7f, 0x61, 0x65, 0x46, 0x69, 0x65, 0x79, 0x29, 0xe6, 0xaa, 0x45, 0x9e, 0xf8, 0xb2, 0xb5,
	0xa3, 0x73, 0x40, 0xc3, 0x18, 0xba, 0xb2, 0xa9, 0xd6, 0xf3, 0x13, 0xf2, 0x58, 0x95, 0x67, 0x08,
	0x1c, 0x29, 0x81, 0x27, 0x47, 0xe4, 0xb6, 0x0a, 0x4f, 0x61, 0x0c, 0x6b, 0xfd, 0x2f, 0x7b, 0xeb,
	0xe4, 0xbf, 0x0a, 0x2f, 0x61, 0xd1, 0x50, 0x12, 0x43, 0xcd, 0x73, 0x72, 0x65, 0x85, 0xe7, 0x51,
	0xec, 0xe3, 0xb5, 0x8d, 0x3d, 0x72, 0x6c, 0xf7, 0xe1, 0xab, 0xee, 0x1a, 0x9a, 0x0c, 0xc4, 0xb5,
	0xed, 0xc0, 0x13, 0xf5, 0x30, 0xf2, 0xbd, 0xad, 0x75, 0x3f, 0xed, 0x08, 0xab, 0x1b, 0x61, 0xc7,
	0x55, 0xb0, 0xea, 0x65, 0xe9, 0x7e, 0x71, 0x9c, 0xbe, 0xbb, 0xe4, 0xa3, 0xdb, 0x28, 0x46, 0x77,
	0x3e, 0xcd, 0xcc, 0x2b, 0xd2, 0xb8, 0x5c, 0x9b, 0xb2, 0xac, 0xa8, 0xe6, 0xb3, 0x02, 0x2f, 0x54,
	0xb9, 0xd3, 0xe8, 0xe5, 0xf3, 0x66, 0xb5, 0xdb, 0x2c, 0xd4, 0xee, 0x4c, 0x6e, 0xa5, 0x20, 0xf7,
	0x57, 0x46, 0xfe, 0xa1, 0xe8, 0xaa, 0xbd, 0x46, 0xbf, 0xba, 0xa4, 0x7b, 0x8d, 0x46, 0xa8, 0xbd,
	0x46, 0x83, 0xb8, 0xbc, 0x67, 0xb3, 0x89, 0xf4, 0x3a, 0x4e, 0x66, 0xf0, 0x14, 0x46, 0xda, 0xa1,
	0x38, 0x97, 0xb4, 0xaa, 0xa4, 0x69, 0xd8, 0x09, 0xf2, 0x4f, 0x54, 0x57, 0x69, 0xa2, 0xdf, 0x52,
	0x52, 0x4d, 0x34, 0x42, 0x69, 0xa2, 0x41, 0xaa, 0xcf, 0x89, 0x97, 0x64, 0xaa, 0x60, 0x7d, 0xd6,
	0x08, 0x67, 0x33, 0xff, 0x04, 0xe6, 0x40, 0xf6, 0x00, 0xe6, 0x1c, 0xe4, 0x9e, 0xbf, 0xd0, 0xd6,
	0x07, 0x22, 0x8e, 0xbd, 0xa9, 0x50, 0xdd, 0x09, 0x0d, 0xb2, 0x7b, 0xea, 0xf2, 0x29, 0xd5, 0x60,
	0x6e, 0xbe, 0xcb, 0x9d, 0xbb, 0x7e, 0x3a, 0x8b, 0xd5, 0xe7, 0xb3, 0xef, 0xb9, 0xab, 0xdd, 0x83,
	0x9a, 0x3c, 0x60, 0x57, 0xd4, 0x7d, 0x37, 0x93, 0x28, 0x27, 0x94, 0x64, 0xe7, 0xf1, 0xda, 0xa7,
	0x39, 0x14, 0xac, 0xeb, 0x96, 0x9c, 0x53, 0x83, 0x68, 0xed, 0xbe, 0x17, 0x8c, 0xc5, 0x4c, 0xb7,
	0x98, 0x24, 0xe4, 0xbc, 0xb9, 0xe6, 0x29, 0x4f, 0x76, 0xb4, 0xf0, 0x18, 0x2d, 0x3b, 0x48, 0x12,
	0x70, 0x3e, 0xcc, 0x3d, 0xef, 0x5d, 0xea, 0xbd, 0x2b, 0x76, 0x30, 0xa7, 0x0f, 0x5d, 0x99, 0x8c,
	0xbb, 0xa1, 0x78, 0x1e, 0x79, 0x41, 0xac, 0x0f, 0x1c, 0xc6, 0xd5, 0x07, 0x0e, 0x33, 0x77, 0xe0,
	0x70, 0x7e, 0x67, 0xe4, 0xa4, 0xd0, 0xb3, 0x17, 0x7b, 0xb3, 0xd0, 0x23, 0xb8, 0xe1, 0x96, 0x9e,
	0xc4, 0xf2, 0x8d, 0x82, 0x3b, 0x50, 0xdf, 0x7b, 0x99, 0x88, 0x60, 0xb2, 0x7a, 0xc8, 0x51, 0x04,
	0x6a, 0x51, 0xd2, 0xbb, 0x9e, 0x3a, 0xe8, 0x28, 0x08, 0x57, 0xb6, 0xef, 0xa9, 0xf6, 0x4c, 0x95,
	0x28, 0x29, 0xec, 0x5c, 0x94, 0x9e, 0x3a, 0xaf, 0xaa, 0xfd, 0xec, 0x0d, 0xa8, 0x91, 0x6e, 0x4a,
	0x05, 0xbd, 0x0d, 0xeb, 0xe5, 0x70, 0x49, 0x25, 0xb6, 0x05, 0x1e, 0xe5, 0x2b, 0x65, 0x36, 0xb2,
	0x1d, 0x97, 0x54, 0x87, 0x97, 0x9e, 0x54, 0xbf, 0x6b, 0x6a, 0x1a, 0xbc, 0x3a, 0xb5, 0x92, 0x49,
	0x1f, 0xc7, 0x03, 0x8b, 0x84, 0x1f, 0x84, 0x01, 0x45, 0x2c, 0x66, 0xc9, 0x4a, 0xef, 0xda, 0x58,
	0xd7, 0xbb, 0x2e, 0x3c, 0x03, 0x98, 0x97, 0x3f, 0x03, 0xf4, 0x5e, 0xff, 0xcb, 0x37, 0x3b, 0xc6,
	0x57, 0xdf, 0xec, 0x18, 0x7f, 0xfb, 0x66, 0xc7, 0xf8, 0xed, 0xb7, 0x3b, 0x1b, 0x5f, 0x7d, 0xbb,
	0xb3, 0xf1, 0xf5, 0xb7, 0x3b, 0x1b, 0x3f, 0xa9, 0x1d, 0x45, 0x61, 0x12, 0x7e, 0x51, 0xa7, 0x07,
	0xff, 0x77, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xd6, 0xe0, 0x9c, 0xbf, 0x02, 0x20, 0x00, 0x00,
}

func (m *PawnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PawnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PawnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Camp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Camp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Camp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AttrType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StatType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AttackSrc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackSrc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackSrc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AttackShapeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackShapeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackShapeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DamageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DamageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DamageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MoveMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *HitType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HitType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HitType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SkillState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SkillBreakReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillBreakReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillBreakReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SkillEndReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillEndReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillEndReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FightLogType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightLogType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightLogType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DamageFloatWordType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DamageFloatWordType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DamageFloatWordType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FightAwardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightAwardData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightAwardData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipCG {
		i--
		if m.SkipCG {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.CurTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CurTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Awards) > 0 {
		for k := range m.Awards {
			v := m.Awards[k]
			baseI := i
			i = encodeVarintFightDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFightDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFightDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FightResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		i -= len(m.CommitID)
		copy(dAtA[i:], m.CommitID)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.CommitID)))
		i--
		dAtA[i] = 0x7a
	}
	if m.BattleFieldID != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BattleFieldID))
		i--
		dAtA[i] = 0x70
	}
	if m.Inherit != nil {
		{
			size, err := m.Inherit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.DebugSceneInfo != nil {
		{
			size, err := m.DebugSceneInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.DelayRewards) > 0 {
		for k := range m.DelayRewards {
			v := m.DelayRewards[k]
			baseI := i
			i = encodeVarintFightDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFightDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFightDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.DebugReplay != nil {
		{
			size, err := m.DebugReplay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Replay != nil {
		{
			size, err := m.Replay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PawnInfos) > 0 {
		for iNdEx := len(m.PawnInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PawnInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFightDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Outcome) > 0 {
		dAtA6 := make([]byte, len(m.Outcome)*10)
		var j5 int
		for _, num := range m.Outcome {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintFightDef(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x3a
	}
	if m.RealTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.RealTime))
		i--
		dAtA[i] = 0x30
	}
	if m.Time != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.IsBoss {
		i--
		if m.IsBoss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Progress != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Progress))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DebugSceneInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugSceneInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugSceneInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BoundaryPoints) > 0 {
		for iNdEx := len(m.BoundaryPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BoundaryPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFightDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x15
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *FightRoleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightRoleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightRoleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Equips) > 0 {
		for k := range m.Equips {
			v := m.Equips[k]
			baseI := i
			i = encodeVarintFightDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintFightDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFightDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Power != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FightAIInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightAIInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightAIInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Power != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AIID) > 0 {
		i -= len(m.AIID)
		copy(dAtA[i:], m.AIID)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.AIID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FightNpcInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightNpcInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightNpcInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SpawnID) > 0 {
		i -= len(m.SpawnID)
		copy(dAtA[i:], m.SpawnID)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.SpawnID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsBoss {
		i--
		if m.IsBoss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.MasterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PawnInherit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PawnInherit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PawnInherit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UltimateSkillPower != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.UltimateSkillPower))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FightInherit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightInherit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightInherit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PawnInheritMap) > 0 {
		for k := range m.PawnInheritMap {
			v := m.PawnInheritMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFightDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFightDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFightDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PawnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PawnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PawnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSummon {
		i--
		if m.IsSummon {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.FightEndDead {
		i--
		if m.FightEndDead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Level != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x48
	}
	if m.BornAngle != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BornAngle))))
		i--
		dAtA[i] = 0x45
	}
	if m.BornPos != nil {
		{
			size, err := m.BornPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Camp != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Camp))
		i--
		dAtA[i] = 0x30
	}
	if m.Npc != nil {
		{
			size, err := m.Npc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.ConfigId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.ConfigId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FightReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightReplay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightReplay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FrameList) > 0 {
		for iNdEx := len(m.FrameList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FrameList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFightDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FightFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActionList) > 0 {
		for iNdEx := len(m.ActionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFightDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Sequence != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FightAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionSummonPawn != nil {
		{
			size, err := m.ActionSummonPawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.ActionAttackMoveAoe != nil {
		{
			size, err := m.ActionAttackMoveAoe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ActionAttackShowAoe != nil {
		{
			size, err := m.ActionAttackShowAoe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ActionSetTarget != nil {
		{
			size, err := m.ActionSetTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ActionCombineSkillPoint != nil {
		{
			size, err := m.ActionCombineSkillPoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ActionCombineSkillEndTime != nil {
		{
			size, err := m.ActionCombineSkillEndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ActionChangeSkillState != nil {
		{
			size, err := m.ActionChangeSkillState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ActionDebugInfo != nil {
		{
			size, err := m.ActionDebugInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ActionFightEnd != nil {
		{
			size, err := m.ActionFightEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ActionFightBegin != nil {
		{
			size, err := m.ActionFightBegin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ActionChangeStat != nil {
		{
			size, err := m.ActionChangeStat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.ActionChangeAttr != nil {
		{
			size, err := m.ActionChangeAttr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ActionRemoveBuff != nil {
		{
			size, err := m.ActionRemoveBuff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ActionAddBuff != nil {
		{
			size, err := m.ActionAddBuff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ActionBeHit != nil {
		{
			size, err := m.ActionBeHit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ActionAttackHit != nil {
		{
			size, err := m.ActionAttackHit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ActionDelAttack != nil {
		{
			size, err := m.ActionDelAttack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ActionNewAttack != nil {
		{
			size, err := m.ActionNewAttack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ActionBreakSkill != nil {
		{
			size, err := m.ActionBreakSkill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ActionUseSkill != nil {
		{
			size, err := m.ActionUseSkill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ActionMoveEnd != nil {
		{
			size, err := m.ActionMoveEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ActionFixMoveData != nil {
		{
			size, err := m.ActionFixMoveData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ActionMoveBegin != nil {
		{
			size, err := m.ActionMoveBegin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SummonPawn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummonPawn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SummonPawn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActualMoveEndTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.ActualMoveEndTime))
		i--
		dAtA[i] = 0x48
	}
	if m.ExpectMoveEndTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.ExpectMoveEndTime))
		i--
		dAtA[i] = 0x40
	}
	if m.NeedSteeringSmoothing {
		i--
		if m.NeedSteeringSmoothing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LookAtPos != nil {
		{
			size, err := m.LookAtPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Speed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Speed))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Angle != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Angle))))
		i--
		dAtA[i] = 0x1d
	}
	if m.MoveMode != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.MoveMode))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MoveMode != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.MoveMode))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FixMoveData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FixMoveData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FixMoveData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NeedSteeringSmoothing {
		i--
		if m.NeedSteeringSmoothing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Angle != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Angle))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UseSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UseSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CombineCasters) > 0 {
		dAtA39 := make([]byte, len(m.CombineCasters)*10)
		var j38 int
		for _, num := range m.CombineCasters {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintFightDef(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x3a
	}
	if m.SkipLater {
		i--
		if m.SkipLater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SkipBefore {
		i--
		if m.SkipBefore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TargetPos != nil {
		{
			size, err := m.TargetPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x18
	}
	if m.SkillId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SkillId))
		i--
		dAtA[i] = 0x10
	}
	if m.CasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CasterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BreakSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BreakSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BreakSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkillId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SkillId))
		i--
		dAtA[i] = 0x18
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x10
	}
	if m.CasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CasterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewAttack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewAttack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewAttack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupID != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x68
	}
	if m.MoveEndTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.MoveEndTime))
		i--
		dAtA[i] = 0x60
	}
	if m.MoveBeginId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.MoveBeginId))
		i--
		dAtA[i] = 0x58
	}
	if m.TargetPos != nil {
		{
			size, err := m.TargetPos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x48
	}
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x40
	}
	if m.ConfigId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.ConfigId))
		i--
		dAtA[i] = 0x38
	}
	if m.BuffId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffId))
		i--
		dAtA[i] = 0x30
	}
	if m.BuffKey != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffKey))
		i--
		dAtA[i] = 0x28
	}
	if m.Index != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x20
	}
	if m.SkillId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SkillId))
		i--
		dAtA[i] = 0x18
	}
	if m.Src != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Src))
		i--
		dAtA[i] = 0x10
	}
	if m.CasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CasterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelAttack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelAttack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelAttack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttackHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackHit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackHit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DamageFloatWordType != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.DamageFloatWordType))
		i--
		dAtA[i] = 0x40
	}
	if m.DamageValue != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.DamageValue))
		i--
		dAtA[i] = 0x38
	}
	if m.DamageHPShield != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.DamageHPShield))
		i--
		dAtA[i] = 0x30
	}
	if m.DamageHP != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.DamageHP))
		i--
		dAtA[i] = 0x28
	}
	if m.DamageBit != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.DamageBit))
		i--
		dAtA[i] = 0x20
	}
	if m.HitTimes != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.HitTimes))
		i--
		dAtA[i] = 0x18
	}
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeHit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeHit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeHit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HitType != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.HitType))
		i--
		dAtA[i] = 0x18
	}
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddBuff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBuff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddBuff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BuffId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffId))
		i--
		dAtA[i] = 0x20
	}
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x18
	}
	if m.CasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CasterId))
		i--
		dAtA[i] = 0x10
	}
	if m.BuffKey != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveBuff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveBuff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveBuff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BuffId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffId))
		i--
		dAtA[i] = 0x18
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x10
	}
	if m.BuffKey != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BuffKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangeAttr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NewValue))))
		i--
		dAtA[i] = 0x21
	}
	if m.OldValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OldValue))))
		i--
		dAtA[i] = 0x19
	}
	if m.AttrType != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttrType))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangeStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatValue {
		i--
		if m.StatValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.StatType != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.StatType))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FightBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FightEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FightEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DebugInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintFightDef(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeSkillState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeSkillState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeSkillState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.SkillId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SkillId))
		i--
		dAtA[i] = 0x10
	}
	if m.CasterId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.CasterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CombineSkillEndTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineSkillEndTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineSkillEndTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cancel {
		i--
		if m.Cancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EndTime != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CombineSkillPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombineSkillPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombineSkillPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Point != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Point))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x10
	}
	if m.SelfId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.SelfId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttackAoeTrans) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackAoeTrans) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackAoeTrans) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Angle != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Angle))))
		i--
		dAtA[i] = 0x15
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttackAoeShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackAoeShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackAoeShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FanAngle != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FanAngle))))
		i--
		dAtA[i] = 0x25
	}
	if m.Radius != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Radius))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Extend != nil {
		{
			size, err := m.Extend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttackShowAoe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackShowAoe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackShowAoe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Spawn != nil {
		{
			size, err := m.Spawn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Shape != nil {
		{
			size, err := m.Shape.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttackMoveAoe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackMoveAoe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttackMoveAoe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Trans != nil {
		{
			size, err := m.Trans.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFightDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AttackId != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.AttackId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpawnMonsterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpawnMonsterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpawnMonsterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PawnInfos) > 0 {
		for iNdEx := len(m.PawnInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PawnInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFightDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BattleFieldID != 0 {
		i = encodeVarintFightDef(dAtA, i, uint64(m.BattleFieldID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFightDef(dAtA []byte, offset int, v uint64) int {
	offset -= sovFightDef(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PawnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Camp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AttrType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StatType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AttackSrc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AttackShapeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DamageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MoveMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *HitType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SkillState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SkillBreakReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SkillEndReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FightLogType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DamageFloatWordType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FightAwardData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Awards) > 0 {
		for k, v := range m.Awards {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFightDef(uint64(k)) + 1 + sovFightDef(uint64(v))
			n += mapEntrySize + 1 + sovFightDef(uint64(mapEntrySize))
		}
	}
	if m.CurTime != 0 {
		n += 1 + sovFightDef(uint64(m.CurTime))
	}
	if m.SkipCG {
		n += 2
	}
	return n
}

func (m *FightResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Progress != 0 {
		n += 1 + sovFightDef(uint64(m.Progress))
	}
	if m.IsBoss {
		n += 2
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovFightDef(uint64(m.StartTimestamp))
	}
	if m.Time != 0 {
		n += 1 + sovFightDef(uint64(m.Time))
	}
	if m.RealTime != 0 {
		n += 1 + sovFightDef(uint64(m.RealTime))
	}
	if len(m.Outcome) > 0 {
		l = 0
		for _, e := range m.Outcome {
			l += sovFightDef(uint64(e))
		}
		n += 1 + sovFightDef(uint64(l)) + l
	}
	if len(m.PawnInfos) > 0 {
		for _, e := range m.PawnInfos {
			l = e.Size()
			n += 1 + l + sovFightDef(uint64(l))
		}
	}
	if m.Replay != nil {
		l = m.Replay.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.DebugReplay != nil {
		l = m.DebugReplay.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if len(m.DelayRewards) > 0 {
		for k, v := range m.DelayRewards {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFightDef(uint64(k)) + 1 + sovFightDef(uint64(v))
			n += mapEntrySize + 1 + sovFightDef(uint64(mapEntrySize))
		}
	}
	if m.DebugSceneInfo != nil {
		l = m.DebugSceneInfo.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Inherit != nil {
		l = m.Inherit.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.BattleFieldID != 0 {
		n += 1 + sovFightDef(uint64(m.BattleFieldID))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *DebugSceneInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BoundaryPoints) > 0 {
		for _, e := range m.BoundaryPoints {
			l = e.Size()
			n += 1 + l + sovFightDef(uint64(l))
		}
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	return n
}

func (m *FightRoleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovFightDef(uint64(m.Power))
	}
	if len(m.Equips) > 0 {
		for k, v := range m.Equips {
			_ = k
			_ = v
			mapEntrySize := 1 + sovFightDef(uint64(k)) + 1 + sovFightDef(uint64(v))
			n += mapEntrySize + 1 + sovFightDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FightAIInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AIID)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovFightDef(uint64(m.Power))
	}
	return n
}

func (m *FightNpcInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MasterId != 0 {
		n += 1 + sovFightDef(uint64(m.MasterId))
	}
	if m.IsBoss {
		n += 2
	}
	l = len(m.SpawnID)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *PawnInherit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UltimateSkillPower != 0 {
		n += 1 + sovFightDef(uint64(m.UltimateSkillPower))
	}
	return n
}

func (m *FightInherit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PawnInheritMap) > 0 {
		for k, v := range m.PawnInheritMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovFightDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFightDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFightDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PawnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFightDef(uint64(m.Id))
	}
	if m.ConfigId != 0 {
		n += 1 + sovFightDef(uint64(m.ConfigId))
	}
	if m.Type != 0 {
		n += 1 + sovFightDef(uint64(m.Type))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Npc != nil {
		l = m.Npc.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovFightDef(uint64(m.Camp))
	}
	if m.BornPos != nil {
		l = m.BornPos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.BornAngle != 0 {
		n += 5
	}
	if m.Level != 0 {
		n += 1 + sovFightDef(uint64(m.Level))
	}
	if m.FightEndDead {
		n += 2
	}
	if m.IsSummon {
		n += 2
	}
	return n
}

func (m *FightReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FrameList) > 0 {
		for _, e := range m.FrameList {
			l = e.Size()
			n += 1 + l + sovFightDef(uint64(l))
		}
	}
	return n
}

func (m *FightFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovFightDef(uint64(m.Sequence))
	}
	if len(m.ActionList) > 0 {
		for _, e := range m.ActionList {
			l = e.Size()
			n += 1 + l + sovFightDef(uint64(l))
		}
	}
	return n
}

func (m *FightAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFightDef(uint64(m.Type))
	}
	if m.ActionMoveBegin != nil {
		l = m.ActionMoveBegin.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionFixMoveData != nil {
		l = m.ActionFixMoveData.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionMoveEnd != nil {
		l = m.ActionMoveEnd.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionUseSkill != nil {
		l = m.ActionUseSkill.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionBreakSkill != nil {
		l = m.ActionBreakSkill.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionNewAttack != nil {
		l = m.ActionNewAttack.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionDelAttack != nil {
		l = m.ActionDelAttack.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionAttackHit != nil {
		l = m.ActionAttackHit.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionBeHit != nil {
		l = m.ActionBeHit.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionAddBuff != nil {
		l = m.ActionAddBuff.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionRemoveBuff != nil {
		l = m.ActionRemoveBuff.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionChangeAttr != nil {
		l = m.ActionChangeAttr.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionChangeStat != nil {
		l = m.ActionChangeStat.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionFightBegin != nil {
		l = m.ActionFightBegin.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.ActionFightEnd != nil {
		l = m.ActionFightEnd.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionDebugInfo != nil {
		l = m.ActionDebugInfo.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionChangeSkillState != nil {
		l = m.ActionChangeSkillState.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionCombineSkillEndTime != nil {
		l = m.ActionCombineSkillEndTime.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionCombineSkillPoint != nil {
		l = m.ActionCombineSkillPoint.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionSetTarget != nil {
		l = m.ActionSetTarget.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionAttackShowAoe != nil {
		l = m.ActionAttackShowAoe.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionAttackMoveAoe != nil {
		l = m.ActionAttackMoveAoe.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	if m.ActionSummonPawn != nil {
		l = m.ActionSummonPawn.Size()
		n += 2 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *SummonPawn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	return n
}

func (m *MoveBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.MoveMode != 0 {
		n += 1 + sovFightDef(uint64(m.MoveMode))
	}
	if m.Angle != 0 {
		n += 5
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Speed != 0 {
		n += 5
	}
	if m.LookAtPos != nil {
		l = m.LookAtPos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.NeedSteeringSmoothing {
		n += 2
	}
	if m.ExpectMoveEndTime != 0 {
		n += 1 + sovFightDef(uint64(m.ExpectMoveEndTime))
	}
	if m.ActualMoveEndTime != 0 {
		n += 1 + sovFightDef(uint64(m.ActualMoveEndTime))
	}
	return n
}

func (m *MoveEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.MoveMode != 0 {
		n += 1 + sovFightDef(uint64(m.MoveMode))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *FixMoveData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Angle != 0 {
		n += 5
	}
	if m.NeedSteeringSmoothing {
		n += 2
	}
	return n
}

func (m *UseSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CasterId != 0 {
		n += 1 + sovFightDef(uint64(m.CasterId))
	}
	if m.SkillId != 0 {
		n += 1 + sovFightDef(uint64(m.SkillId))
	}
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.TargetPos != nil {
		l = m.TargetPos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.SkipBefore {
		n += 2
	}
	if m.SkipLater {
		n += 2
	}
	if len(m.CombineCasters) > 0 {
		l = 0
		for _, e := range m.CombineCasters {
			l += sovFightDef(uint64(e))
		}
		n += 1 + sovFightDef(uint64(l)) + l
	}
	return n
}

func (m *BreakSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CasterId != 0 {
		n += 1 + sovFightDef(uint64(m.CasterId))
	}
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.SkillId != 0 {
		n += 1 + sovFightDef(uint64(m.SkillId))
	}
	return n
}

func (m *NewAttack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CasterId != 0 {
		n += 1 + sovFightDef(uint64(m.CasterId))
	}
	if m.Src != 0 {
		n += 1 + sovFightDef(uint64(m.Src))
	}
	if m.SkillId != 0 {
		n += 1 + sovFightDef(uint64(m.SkillId))
	}
	if m.Index != 0 {
		n += 1 + sovFightDef(uint64(m.Index))
	}
	if m.BuffKey != 0 {
		n += 1 + sovFightDef(uint64(m.BuffKey))
	}
	if m.BuffId != 0 {
		n += 1 + sovFightDef(uint64(m.BuffId))
	}
	if m.ConfigId != 0 {
		n += 1 + sovFightDef(uint64(m.ConfigId))
	}
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.TargetPos != nil {
		l = m.TargetPos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.MoveBeginId != 0 {
		n += 1 + sovFightDef(uint64(m.MoveBeginId))
	}
	if m.MoveEndTime != 0 {
		n += 1 + sovFightDef(uint64(m.MoveEndTime))
	}
	if m.GroupID != 0 {
		n += 1 + sovFightDef(uint64(m.GroupID))
	}
	return n
}

func (m *DelAttack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	return n
}

func (m *AttackHit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	if m.HitTimes != 0 {
		n += 1 + sovFightDef(uint64(m.HitTimes))
	}
	if m.DamageBit != 0 {
		n += 1 + sovFightDef(uint64(m.DamageBit))
	}
	if m.DamageHP != 0 {
		n += 1 + sovFightDef(uint64(m.DamageHP))
	}
	if m.DamageHPShield != 0 {
		n += 1 + sovFightDef(uint64(m.DamageHPShield))
	}
	if m.DamageValue != 0 {
		n += 1 + sovFightDef(uint64(m.DamageValue))
	}
	if m.DamageFloatWordType != 0 {
		n += 1 + sovFightDef(uint64(m.DamageFloatWordType))
	}
	return n
}

func (m *BeHit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	if m.HitType != 0 {
		n += 1 + sovFightDef(uint64(m.HitType))
	}
	return n
}

func (m *AddBuff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuffKey != 0 {
		n += 1 + sovFightDef(uint64(m.BuffKey))
	}
	if m.CasterId != 0 {
		n += 1 + sovFightDef(uint64(m.CasterId))
	}
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	if m.BuffId != 0 {
		n += 1 + sovFightDef(uint64(m.BuffId))
	}
	return n
}

func (m *RemoveBuff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BuffKey != 0 {
		n += 1 + sovFightDef(uint64(m.BuffKey))
	}
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.BuffId != 0 {
		n += 1 + sovFightDef(uint64(m.BuffId))
	}
	return n
}

func (m *ChangeAttr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.AttrType != 0 {
		n += 1 + sovFightDef(uint64(m.AttrType))
	}
	if m.OldValue != 0 {
		n += 9
	}
	if m.NewValue != 0 {
		n += 9
	}
	return n
}

func (m *ChangeStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.StatType != 0 {
		n += 1 + sovFightDef(uint64(m.StatType))
	}
	if m.StatValue {
		n += 2
	}
	return n
}

func (m *FightBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FightEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DebugInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFightDef(uint64(m.Type))
	}
	return n
}

func (m *ChangeSkillState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CasterId != 0 {
		n += 1 + sovFightDef(uint64(m.CasterId))
	}
	if m.SkillId != 0 {
		n += 1 + sovFightDef(uint64(m.SkillId))
	}
	if m.State != 0 {
		n += 1 + sovFightDef(uint64(m.State))
	}
	return n
}

func (m *CombineSkillEndTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndTime != 0 {
		n += 1 + sovFightDef(uint64(m.EndTime))
	}
	if m.Cancel {
		n += 2
	}
	return n
}

func (m *CombineSkillPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Point != 0 {
		n += 1 + sovFightDef(uint64(m.Point))
	}
	return n
}

func (m *SetTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovFightDef(uint64(m.SelfId))
	}
	if m.TargetId != 0 {
		n += 1 + sovFightDef(uint64(m.TargetId))
	}
	return n
}

func (m *AttackAoeTrans) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Angle != 0 {
		n += 5
	}
	return n
}

func (m *AttackAoeShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFightDef(uint64(m.Type))
	}
	if m.Extend != nil {
		l = m.Extend.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Radius != 0 {
		n += 5
	}
	if m.FanAngle != 0 {
		n += 5
	}
	return n
}

func (m *AttackShowAoe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	if m.Shape != nil {
		l = m.Shape.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	if m.Spawn != nil {
		l = m.Spawn.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *AttackMoveAoe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttackId != 0 {
		n += 1 + sovFightDef(uint64(m.AttackId))
	}
	if m.Trans != nil {
		l = m.Trans.Size()
		n += 1 + l + sovFightDef(uint64(l))
	}
	return n
}

func (m *SpawnMonsterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BattleFieldID != 0 {
		n += 1 + sovFightDef(uint64(m.BattleFieldID))
	}
	if len(m.PawnInfos) > 0 {
		for _, e := range m.PawnInfos {
			l = e.Size()
			n += 1 + l + sovFightDef(uint64(l))
		}
	}
	return n
}

func sovFightDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFightDef(x uint64) (n int) {
	return sovFightDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PawnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PawnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PawnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Camp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Camp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Camp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackSrc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackSrc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackSrc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackShapeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackShapeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackShapeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DamageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DamageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DamageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HitType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HitType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HitType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillBreakReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillBreakReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillBreakReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillEndReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillEndReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillEndReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightLogType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightLogType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightLogType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DamageFloatWordType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DamageFloatWordType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DamageFloatWordType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightAwardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightAwardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightAwardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Awards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Awards == nil {
				m.Awards = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFightDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFightDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Awards[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurTime", wireType)
			}
			m.CurTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipCG", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipCG = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBoss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBoss = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealTime", wireType)
			}
			m.RealTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RealTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v Camp_Enum
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Camp_Enum(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Outcome = append(m.Outcome, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFightDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFightDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Outcome) == 0 {
					m.Outcome = make([]Camp_Enum, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Camp_Enum
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Camp_Enum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Outcome = append(m.Outcome, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcome", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PawnInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PawnInfos = append(m.PawnInfos, &PawnInfo{})
			if err := m.PawnInfos[len(m.PawnInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replay == nil {
				m.Replay = &FightReplay{}
			}
			if err := m.Replay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugReplay == nil {
				m.DebugReplay = &FightReplay{}
			}
			if err := m.DebugReplay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DelayRewards == nil {
				m.DelayRewards = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFightDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFightDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DelayRewards[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugSceneInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DebugSceneInfo == nil {
				m.DebugSceneInfo = &DebugSceneInfo{}
			}
			if err := m.DebugSceneInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inherit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inherit == nil {
				m.Inherit = &FightInherit{}
			}
			if err := m.Inherit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleFieldID", wireType)
			}
			m.BattleFieldID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleFieldID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugSceneInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugSceneInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugSceneInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundaryPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BoundaryPoints = append(m.BoundaryPoints, &Position{})
			if err := m.BoundaryPoints[len(m.BoundaryPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightRoleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightRoleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightRoleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equips == nil {
				m.Equips = make(map[int32]uint32)
			}
			var mapkey int32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFightDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFightDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Equips[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightAIInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightAIInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightAIInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AIID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AIID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightNpcInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightNpcInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightNpcInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterId", wireType)
			}
			m.MasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBoss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBoss = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpawnID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpawnID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PawnInherit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PawnInherit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PawnInherit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UltimateSkillPower", wireType)
			}
			m.UltimateSkillPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UltimateSkillPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightInherit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightInherit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightInherit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PawnInheritMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PawnInheritMap == nil {
				m.PawnInheritMap = make(map[string]*PawnInherit)
			}
			var mapkey string
			var mapvalue *PawnInherit
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFightDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFightDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFightDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFightDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PawnInherit{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFightDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthFightDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PawnInheritMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PawnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PawnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PawnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigId", wireType)
			}
			m.ConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PawnType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &FightRoleInfo{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Npc == nil {
				m.Npc = &FightNpcInfo{}
			}
			if err := m.Npc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= Camp_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BornPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BornPos == nil {
				m.BornPos = &Position{}
			}
			if err := m.BornPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BornAngle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BornAngle = float32(math.Float32frombits(v))
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightEndDead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FightEndDead = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSummon", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSummon = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameList = append(m.FrameList, &FightFrame{})
			if err := m.FrameList[len(m.FrameList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionList = append(m.ActionList, &FightAction{})
			if err := m.ActionList[len(m.ActionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionMoveBegin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionMoveBegin == nil {
				m.ActionMoveBegin = &MoveBegin{}
			}
			if err := m.ActionMoveBegin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionFixMoveData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionFixMoveData == nil {
				m.ActionFixMoveData = &FixMoveData{}
			}
			if err := m.ActionFixMoveData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionMoveEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionMoveEnd == nil {
				m.ActionMoveEnd = &MoveEnd{}
			}
			if err := m.ActionMoveEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionUseSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionUseSkill == nil {
				m.ActionUseSkill = &UseSkill{}
			}
			if err := m.ActionUseSkill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionBreakSkill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionBreakSkill == nil {
				m.ActionBreakSkill = &BreakSkill{}
			}
			if err := m.ActionBreakSkill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionNewAttack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionNewAttack == nil {
				m.ActionNewAttack = &NewAttack{}
			}
			if err := m.ActionNewAttack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDelAttack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionDelAttack == nil {
				m.ActionDelAttack = &DelAttack{}
			}
			if err := m.ActionDelAttack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionAttackHit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionAttackHit == nil {
				m.ActionAttackHit = &AttackHit{}
			}
			if err := m.ActionAttackHit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionBeHit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionBeHit == nil {
				m.ActionBeHit = &BeHit{}
			}
			if err := m.ActionBeHit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionAddBuff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionAddBuff == nil {
				m.ActionAddBuff = &AddBuff{}
			}
			if err := m.ActionAddBuff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionRemoveBuff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionRemoveBuff == nil {
				m.ActionRemoveBuff = &RemoveBuff{}
			}
			if err := m.ActionRemoveBuff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionChangeAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionChangeAttr == nil {
				m.ActionChangeAttr = &ChangeAttr{}
			}
			if err := m.ActionChangeAttr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionChangeStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionChangeStat == nil {
				m.ActionChangeStat = &ChangeStat{}
			}
			if err := m.ActionChangeStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionFightBegin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionFightBegin == nil {
				m.ActionFightBegin = &FightBegin{}
			}
			if err := m.ActionFightBegin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionFightEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionFightEnd == nil {
				m.ActionFightEnd = &FightEnd{}
			}
			if err := m.ActionFightEnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionDebugInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionDebugInfo == nil {
				m.ActionDebugInfo = &DebugInfo{}
			}
			if err := m.ActionDebugInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionChangeSkillState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionChangeSkillState == nil {
				m.ActionChangeSkillState = &ChangeSkillState{}
			}
			if err := m.ActionChangeSkillState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCombineSkillEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionCombineSkillEndTime == nil {
				m.ActionCombineSkillEndTime = &CombineSkillEndTime{}
			}
			if err := m.ActionCombineSkillEndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionCombineSkillPoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionCombineSkillPoint == nil {
				m.ActionCombineSkillPoint = &CombineSkillPoint{}
			}
			if err := m.ActionCombineSkillPoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionSetTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionSetTarget == nil {
				m.ActionSetTarget = &SetTarget{}
			}
			if err := m.ActionSetTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionAttackShowAoe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionAttackShowAoe == nil {
				m.ActionAttackShowAoe = &AttackShowAoe{}
			}
			if err := m.ActionAttackShowAoe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionAttackMoveAoe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionAttackMoveAoe == nil {
				m.ActionAttackMoveAoe = &AttackMoveAoe{}
			}
			if err := m.ActionAttackMoveAoe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionSummonPawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionSummonPawn == nil {
				m.ActionSummonPawn = &SummonPawn{}
			}
			if err := m.ActionSummonPawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummonPawn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummonPawn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummonPawn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveMode", wireType)
			}
			m.MoveMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveMode |= MoveMode_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Angle = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Speed = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookAtPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookAtPos == nil {
				m.LookAtPos = &Position{}
			}
			if err := m.LookAtPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedSteeringSmoothing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedSteeringSmoothing = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectMoveEndTime", wireType)
			}
			m.ExpectMoveEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectMoveEndTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualMoveEndTime", wireType)
			}
			m.ActualMoveEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualMoveEndTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveMode", wireType)
			}
			m.MoveMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveMode |= MoveMode_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FixMoveData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FixMoveData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FixMoveData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Angle = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedSteeringSmoothing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedSteeringSmoothing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterId", wireType)
			}
			m.CasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetPos == nil {
				m.TargetPos = &Position{}
			}
			if err := m.TargetPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipBefore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipBefore = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipLater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipLater = bool(v != 0)
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CombineCasters = append(m.CombineCasters, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFightDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFightDef
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFightDef
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CombineCasters) == 0 {
					m.CombineCasters = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFightDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CombineCasters = append(m.CombineCasters, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CombineCasters", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BreakSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BreakSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BreakSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterId", wireType)
			}
			m.CasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewAttack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewAttack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewAttack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterId", wireType)
			}
			m.CasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= AttackSrc_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffKey", wireType)
			}
			m.BuffKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigId", wireType)
			}
			m.ConfigId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetPos == nil {
				m.TargetPos = &Position{}
			}
			if err := m.TargetPos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveBeginId", wireType)
			}
			m.MoveBeginId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveBeginId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveEndTime", wireType)
			}
			m.MoveEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoveEndTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelAttack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelAttack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelAttack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitTimes", wireType)
			}
			m.HitTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageBit", wireType)
			}
			m.DamageBit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageBit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageHP", wireType)
			}
			m.DamageHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageHPShield", wireType)
			}
			m.DamageHPShield = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageHPShield |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageValue", wireType)
			}
			m.DamageValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageValue |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DamageFloatWordType", wireType)
			}
			m.DamageFloatWordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DamageFloatWordType |= DamageFloatWordType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeHit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeHit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeHit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitType", wireType)
			}
			m.HitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitType |= HitType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBuff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBuff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBuff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffKey", wireType)
			}
			m.BuffKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterId", wireType)
			}
			m.CasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveBuff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveBuff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveBuff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffKey", wireType)
			}
			m.BuffKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffId", wireType)
			}
			m.BuffId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrType", wireType)
			}
			m.AttrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrType |= AttrType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OldValue = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NewValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatType", wireType)
			}
			m.StatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatType |= StatType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatValue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FightLogType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeSkillState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeSkillState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeSkillState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterId", wireType)
			}
			m.CasterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CasterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillId", wireType)
			}
			m.SkillId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SkillState_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineSkillEndTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineSkillEndTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineSkillEndTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cancel = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombineSkillPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombineSkillPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombineSkillPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			m.Point = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Point |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackAoeTrans) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackAoeTrans: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackAoeTrans: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Angle = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackAoeShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackAoeShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackAoeShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AttackShapeType_Enum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extend == nil {
				m.Extend = &Position{}
			}
			if err := m.Extend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Radius", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Radius = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FanAngle", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.FanAngle = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackShowAoe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackShowAoe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackShowAoe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shape == nil {
				m.Shape = &AttackAoeShape{}
			}
			if err := m.Shape.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spawn == nil {
				m.Spawn = &AttackAoeTrans{}
			}
			if err := m.Spawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackMoveAoe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackMoveAoe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackMoveAoe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackId", wireType)
			}
			m.AttackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trans == nil {
				m.Trans = &AttackAoeTrans{}
			}
			if err := m.Trans.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpawnMonsterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpawnMonsterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpawnMonsterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleFieldID", wireType)
			}
			m.BattleFieldID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleFieldID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PawnInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFightDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFightDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PawnInfos = append(m.PawnInfos, &PawnInfo{})
			if err := m.PawnInfos[len(m.PawnInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFightDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFightDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFightDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFightDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFightDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFightDef
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFightDef
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFightDef
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFightDef        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFightDef          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFightDef = fmt.Errorf("proto: unexpected end of group")
)
