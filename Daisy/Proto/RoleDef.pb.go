// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: RoleDef.proto

package Proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//Role 指挥官
type Role struct {
	Base              *RoleBase                  `protobuf:"bytes,1,opt,name=Base,proto3" json:"Base,omitempty"`
	Invites           map[string]*RoleInviteInfo `protobuf:"bytes,2,rep,name=Invites,proto3" json:"Invites,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	InitedOnce        bool                       `protobuf:"varint,4,opt,name=InitedOnce,proto3" json:"InitedOnce,omitempty"`
	SpecialAgentList  map[uint32]*SpecialAgent   `protobuf:"bytes,5,rep,name=SpecialAgentList,proto3" json:"SpecialAgentList,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	BuildMap          map[string]*BuildData      `protobuf:"bytes,6,rep,name=BuildMap,proto3" json:"BuildMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FightingBuildID   string                     `protobuf:"bytes,7,opt,name=FightingBuildID,proto3" json:"FightingBuildID,omitempty"`
	ItemContainerMap  map[int32]*ItemContainer   `protobuf:"bytes,8,rep,name=ItemContainerMap,proto3" json:"ItemContainerMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Chat              *RoleChat                  `protobuf:"bytes,9,opt,name=Chat,proto3" json:"Chat,omitempty"`
	InheritAttr       *PawnInherit               `protobuf:"bytes,10,opt,name=InheritAttr,proto3" json:"InheritAttr,omitempty"`
	Gold              uint64                     `protobuf:"varint,11,opt,name=Gold,proto3" json:"Gold,omitempty"`
	Diamond           uint64                     `protobuf:"varint,12,opt,name=Diamond,proto3" json:"Diamond,omitempty"`
	OfflineAwardDatas *OfflineAwardData          `protobuf:"bytes,13,opt,name=OfflineAwardDatas,proto3" json:"OfflineAwardDatas,omitempty"`
	SkillsLearned     map[uint32]*SkillData      `protobuf:"bytes,14,rep,name=SkillsLearned,proto3" json:"SkillsLearned,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RedPointsData     map[string]*RedPointInfo   `protobuf:"bytes,15,rep,name=RedPointsData,proto3" json:"RedPointsData,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FastBattle        *FastBattle                `protobuf:"bytes,16,opt,name=FastBattle,proto3" json:"FastBattle,omitempty"`
	MailBox           *MailBox                   `protobuf:"bytes,17,opt,name=MailBox,proto3" json:"MailBox,omitempty"`
	ShareSpoils       *ShareSpoils               `protobuf:"bytes,18,opt,name=ShareSpoils,proto3" json:"ShareSpoils,omitempty"`
	Title             *Title                     `protobuf:"bytes,19,opt,name=Title,proto3" json:"Title,omitempty"`
	SupplyInfo        *SupplyInfo                `protobuf:"bytes,20,opt,name=SupplyInfo,proto3" json:"SupplyInfo,omitempty"`
	Friends           *FriendListData            `protobuf:"bytes,21,opt,name=Friends,proto3" json:"Friends,omitempty"`
	SeasonInfo        *RoleSeasonInfo            `protobuf:"bytes,22,opt,name=SeasonInfo,proto3" json:"SeasonInfo,omitempty"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{0}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Role.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return m.Size()
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetBase() *RoleBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *Role) GetInvites() map[string]*RoleInviteInfo {
	if m != nil {
		return m.Invites
	}
	return nil
}

func (m *Role) GetInitedOnce() bool {
	if m != nil {
		return m.InitedOnce
	}
	return false
}

func (m *Role) GetSpecialAgentList() map[uint32]*SpecialAgent {
	if m != nil {
		return m.SpecialAgentList
	}
	return nil
}

func (m *Role) GetBuildMap() map[string]*BuildData {
	if m != nil {
		return m.BuildMap
	}
	return nil
}

func (m *Role) GetFightingBuildID() string {
	if m != nil {
		return m.FightingBuildID
	}
	return ""
}

func (m *Role) GetItemContainerMap() map[int32]*ItemContainer {
	if m != nil {
		return m.ItemContainerMap
	}
	return nil
}

func (m *Role) GetChat() *RoleChat {
	if m != nil {
		return m.Chat
	}
	return nil
}

func (m *Role) GetInheritAttr() *PawnInherit {
	if m != nil {
		return m.InheritAttr
	}
	return nil
}

func (m *Role) GetGold() uint64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *Role) GetDiamond() uint64 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *Role) GetOfflineAwardDatas() *OfflineAwardData {
	if m != nil {
		return m.OfflineAwardDatas
	}
	return nil
}

func (m *Role) GetSkillsLearned() map[uint32]*SkillData {
	if m != nil {
		return m.SkillsLearned
	}
	return nil
}

func (m *Role) GetRedPointsData() map[string]*RedPointInfo {
	if m != nil {
		return m.RedPointsData
	}
	return nil
}

func (m *Role) GetFastBattle() *FastBattle {
	if m != nil {
		return m.FastBattle
	}
	return nil
}

func (m *Role) GetMailBox() *MailBox {
	if m != nil {
		return m.MailBox
	}
	return nil
}

func (m *Role) GetShareSpoils() *ShareSpoils {
	if m != nil {
		return m.ShareSpoils
	}
	return nil
}

func (m *Role) GetTitle() *Title {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *Role) GetSupplyInfo() *SupplyInfo {
	if m != nil {
		return m.SupplyInfo
	}
	return nil
}

func (m *Role) GetFriends() *FriendListData {
	if m != nil {
		return m.Friends
	}
	return nil
}

func (m *Role) GetSeasonInfo() *RoleSeasonInfo {
	if m != nil {
		return m.SeasonInfo
	}
	return nil
}

//RoleBase 指挥官基础数据
type RoleBase struct {
	Name           string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Exp            uint64 `protobuf:"varint,2,opt,name=Exp,proto3" json:"Exp,omitempty"`
	Sex            uint32 `protobuf:"varint,3,opt,name=Sex,proto3" json:"Sex,omitempty"`
	CreateTime     int64  `protobuf:"varint,4,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	LastLogoutTime int64  `protobuf:"varint,5,opt,name=LastLogoutTime,proto3" json:"LastLogoutTime,omitempty"`
	LastLoginTime  int64  `protobuf:"varint,6,opt,name=LastLoginTime,proto3" json:"LastLoginTime,omitempty"`
	Level          uint32 `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
	TeamID         string `protobuf:"bytes,8,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	RaidProgress   uint32 `protobuf:"varint,9,opt,name=RaidProgress,proto3" json:"RaidProgress,omitempty"`
	Online         bool   `protobuf:"varint,10,opt,name=Online,proto3" json:"Online,omitempty"`
	Head           uint32 `protobuf:"varint,13,opt,name=Head,proto3" json:"Head,omitempty"`
	UID            uint64 `protobuf:"varint,14,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *RoleBase) Reset()         { *m = RoleBase{} }
func (m *RoleBase) String() string { return proto.CompactTextString(m) }
func (*RoleBase) ProtoMessage()    {}
func (*RoleBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{1}
}
func (m *RoleBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleBase.Merge(m, src)
}
func (m *RoleBase) XXX_Size() int {
	return m.Size()
}
func (m *RoleBase) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleBase.DiscardUnknown(m)
}

var xxx_messageInfo_RoleBase proto.InternalMessageInfo

func (m *RoleBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RoleBase) GetExp() uint64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *RoleBase) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *RoleBase) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *RoleBase) GetLastLogoutTime() int64 {
	if m != nil {
		return m.LastLogoutTime
	}
	return 0
}

func (m *RoleBase) GetLastLoginTime() int64 {
	if m != nil {
		return m.LastLoginTime
	}
	return 0
}

func (m *RoleBase) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *RoleBase) GetTeamID() string {
	if m != nil {
		return m.TeamID
	}
	return ""
}

func (m *RoleBase) GetRaidProgress() uint32 {
	if m != nil {
		return m.RaidProgress
	}
	return 0
}

func (m *RoleBase) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *RoleBase) GetHead() uint32 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *RoleBase) GetUID() uint64 {
	if m != nil {
		return m.UID
	}
	return 0
}

// 邀请信息
type RoleInviteInfo struct {
	Instigator string `protobuf:"bytes,1,opt,name=Instigator,proto3" json:"Instigator,omitempty"`
	Time       int64  `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *RoleInviteInfo) Reset()         { *m = RoleInviteInfo{} }
func (m *RoleInviteInfo) String() string { return proto.CompactTextString(m) }
func (*RoleInviteInfo) ProtoMessage()    {}
func (*RoleInviteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{2}
}
func (m *RoleInviteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleInviteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleInviteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleInviteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleInviteInfo.Merge(m, src)
}
func (m *RoleInviteInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoleInviteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleInviteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoleInviteInfo proto.InternalMessageInfo

func (m *RoleInviteInfo) GetInstigator() string {
	if m != nil {
		return m.Instigator
	}
	return ""
}

func (m *RoleInviteInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type RoleChat struct {
	ChatChannels map[string]bool `protobuf:"bytes,1,rep,name=ChatChannels,proto3" json:"ChatChannels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *RoleChat) Reset()         { *m = RoleChat{} }
func (m *RoleChat) String() string { return proto.CompactTextString(m) }
func (*RoleChat) ProtoMessage()    {}
func (*RoleChat) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{3}
}
func (m *RoleChat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleChat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleChat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleChat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleChat.Merge(m, src)
}
func (m *RoleChat) XXX_Size() int {
	return m.Size()
}
func (m *RoleChat) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleChat.DiscardUnknown(m)
}

var xxx_messageInfo_RoleChat proto.InternalMessageInfo

func (m *RoleChat) GetChatChannels() map[string]bool {
	if m != nil {
		return m.ChatChannels
	}
	return nil
}

type ShareSpoils struct {
	GiveEquipCount             uint32                     `protobuf:"varint,1,opt,name=GiveEquipCount,proto3" json:"GiveEquipCount,omitempty"`
	RequestSkillResetTimeStamp int64                      `protobuf:"varint,2,opt,name=RequestSkillResetTimeStamp,proto3" json:"RequestSkillResetTimeStamp,omitempty"`
	RequestSkillCount          uint32                     `protobuf:"varint,3,opt,name=RequestSkillCount,proto3" json:"RequestSkillCount,omitempty"`
	RequestSkillCountLimit     uint32                     `protobuf:"varint,4,opt,name=RequestSkillCountLimit,proto3" json:"RequestSkillCountLimit,omitempty"`
	GiveSkillResetTimeStamp    int64                      `protobuf:"varint,5,opt,name=GiveSkillResetTimeStamp,proto3" json:"GiveSkillResetTimeStamp,omitempty"`
	GiveSkillCount             uint32                     `protobuf:"varint,6,opt,name=GiveSkillCount,proto3" json:"GiveSkillCount,omitempty"`
	GiveSkillCountLimit        uint32                     `protobuf:"varint,7,opt,name=GiveSkillCountLimit,proto3" json:"GiveSkillCountLimit,omitempty"`
	RequestSkillData           map[string]*RequestSkill   `protobuf:"bytes,8,rep,name=RequestSkillData,proto3" json:"RequestSkillData,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	GiveSkillToTargetCount     map[string]*GiveSkillCount `protobuf:"bytes,9,rep,name=GiveSkillToTargetCount,proto3" json:"GiveSkillToTargetCount,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ShareSpoils) Reset()         { *m = ShareSpoils{} }
func (m *ShareSpoils) String() string { return proto.CompactTextString(m) }
func (*ShareSpoils) ProtoMessage()    {}
func (*ShareSpoils) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{4}
}
func (m *ShareSpoils) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareSpoils) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareSpoils.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareSpoils) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareSpoils.Merge(m, src)
}
func (m *ShareSpoils) XXX_Size() int {
	return m.Size()
}
func (m *ShareSpoils) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareSpoils.DiscardUnknown(m)
}

var xxx_messageInfo_ShareSpoils proto.InternalMessageInfo

func (m *ShareSpoils) GetGiveEquipCount() uint32 {
	if m != nil {
		return m.GiveEquipCount
	}
	return 0
}

func (m *ShareSpoils) GetRequestSkillResetTimeStamp() int64 {
	if m != nil {
		return m.RequestSkillResetTimeStamp
	}
	return 0
}

func (m *ShareSpoils) GetRequestSkillCount() uint32 {
	if m != nil {
		return m.RequestSkillCount
	}
	return 0
}

func (m *ShareSpoils) GetRequestSkillCountLimit() uint32 {
	if m != nil {
		return m.RequestSkillCountLimit
	}
	return 0
}

func (m *ShareSpoils) GetGiveSkillResetTimeStamp() int64 {
	if m != nil {
		return m.GiveSkillResetTimeStamp
	}
	return 0
}

func (m *ShareSpoils) GetGiveSkillCount() uint32 {
	if m != nil {
		return m.GiveSkillCount
	}
	return 0
}

func (m *ShareSpoils) GetGiveSkillCountLimit() uint32 {
	if m != nil {
		return m.GiveSkillCountLimit
	}
	return 0
}

func (m *ShareSpoils) GetRequestSkillData() map[string]*RequestSkill {
	if m != nil {
		return m.RequestSkillData
	}
	return nil
}

func (m *ShareSpoils) GetGiveSkillToTargetCount() map[string]*GiveSkillCount {
	if m != nil {
		return m.GiveSkillToTargetCount
	}
	return nil
}

type GiveSkillCount struct {
	GiveSkillToTargetCount map[uint32]uint32 `protobuf:"bytes,1,rep,name=GiveSkillToTargetCount,proto3" json:"GiveSkillToTargetCount,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *GiveSkillCount) Reset()         { *m = GiveSkillCount{} }
func (m *GiveSkillCount) String() string { return proto.CompactTextString(m) }
func (*GiveSkillCount) ProtoMessage()    {}
func (*GiveSkillCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{5}
}
func (m *GiveSkillCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GiveSkillCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GiveSkillCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GiveSkillCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GiveSkillCount.Merge(m, src)
}
func (m *GiveSkillCount) XXX_Size() int {
	return m.Size()
}
func (m *GiveSkillCount) XXX_DiscardUnknown() {
	xxx_messageInfo_GiveSkillCount.DiscardUnknown(m)
}

var xxx_messageInfo_GiveSkillCount proto.InternalMessageInfo

func (m *GiveSkillCount) GetGiveSkillToTargetCount() map[uint32]uint32 {
	if m != nil {
		return m.GiveSkillToTargetCount
	}
	return nil
}

// 技能请求数据
type RequestSkill struct {
	RequestMessageId        uint32            `protobuf:"varint,1,opt,name=RequestMessageId,proto3" json:"RequestMessageId,omitempty"`
	RequestCreateTimeStamp  int64             `protobuf:"varint,2,opt,name=RequestCreateTimeStamp,proto3" json:"RequestCreateTimeStamp,omitempty"`
	RequestSkillItemId      uint32            `protobuf:"varint,3,opt,name=RequestSkillItemId,proto3" json:"RequestSkillItemId,omitempty"`
	SkillCurLevel           uint32            `protobuf:"varint,4,opt,name=SkillCurLevel,proto3" json:"SkillCurLevel,omitempty"`
	ReceivedSkillCount      uint32            `protobuf:"varint,5,opt,name=ReceivedSkillCount,proto3" json:"ReceivedSkillCount,omitempty"`
	SkillReceivedCountLimit uint32            `protobuf:"varint,6,opt,name=SkillReceivedCountLimit,proto3" json:"SkillReceivedCountLimit,omitempty"`
	RequestTimeOutTimeStamp int64             `protobuf:"varint,7,opt,name=RequestTimeOutTimeStamp,proto3" json:"RequestTimeOutTimeStamp,omitempty"`
	TeamMateGiveSkillCount  map[string]uint32 `protobuf:"bytes,8,rep,name=TeamMateGiveSkillCount,proto3" json:"TeamMateGiveSkillCount,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *RequestSkill) Reset()         { *m = RequestSkill{} }
func (m *RequestSkill) String() string { return proto.CompactTextString(m) }
func (*RequestSkill) ProtoMessage()    {}
func (*RequestSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{6}
}
func (m *RequestSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestSkill.Merge(m, src)
}
func (m *RequestSkill) XXX_Size() int {
	return m.Size()
}
func (m *RequestSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestSkill.DiscardUnknown(m)
}

var xxx_messageInfo_RequestSkill proto.InternalMessageInfo

func (m *RequestSkill) GetRequestMessageId() uint32 {
	if m != nil {
		return m.RequestMessageId
	}
	return 0
}

func (m *RequestSkill) GetRequestCreateTimeStamp() int64 {
	if m != nil {
		return m.RequestCreateTimeStamp
	}
	return 0
}

func (m *RequestSkill) GetRequestSkillItemId() uint32 {
	if m != nil {
		return m.RequestSkillItemId
	}
	return 0
}

func (m *RequestSkill) GetSkillCurLevel() uint32 {
	if m != nil {
		return m.SkillCurLevel
	}
	return 0
}

func (m *RequestSkill) GetReceivedSkillCount() uint32 {
	if m != nil {
		return m.ReceivedSkillCount
	}
	return 0
}

func (m *RequestSkill) GetSkillReceivedCountLimit() uint32 {
	if m != nil {
		return m.SkillReceivedCountLimit
	}
	return 0
}

func (m *RequestSkill) GetRequestTimeOutTimeStamp() int64 {
	if m != nil {
		return m.RequestTimeOutTimeStamp
	}
	return 0
}

func (m *RequestSkill) GetTeamMateGiveSkillCount() map[string]uint32 {
	if m != nil {
		return m.TeamMateGiveSkillCount
	}
	return nil
}

type FastBattle struct {
	StageInfo   map[uint32]*FastBattleStageInfo `protobuf:"bytes,1,rep,name=StageInfo,proto3" json:"StageInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	EnergizeNum uint32                          `protobuf:"varint,2,opt,name=EnergizeNum,proto3" json:"EnergizeNum,omitempty"`
	AwardMulti  float32                         `protobuf:"fixed32,3,opt,name=AwardMulti,proto3" json:"AwardMulti,omitempty"`
}

func (m *FastBattle) Reset()         { *m = FastBattle{} }
func (m *FastBattle) String() string { return proto.CompactTextString(m) }
func (*FastBattle) ProtoMessage()    {}
func (*FastBattle) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{7}
}
func (m *FastBattle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FastBattle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FastBattle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FastBattle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FastBattle.Merge(m, src)
}
func (m *FastBattle) XXX_Size() int {
	return m.Size()
}
func (m *FastBattle) XXX_DiscardUnknown() {
	xxx_messageInfo_FastBattle.DiscardUnknown(m)
}

var xxx_messageInfo_FastBattle proto.InternalMessageInfo

func (m *FastBattle) GetStageInfo() map[uint32]*FastBattleStageInfo {
	if m != nil {
		return m.StageInfo
	}
	return nil
}

func (m *FastBattle) GetEnergizeNum() uint32 {
	if m != nil {
		return m.EnergizeNum
	}
	return 0
}

func (m *FastBattle) GetAwardMulti() float32 {
	if m != nil {
		return m.AwardMulti
	}
	return 0
}

type FastBattleStageInfo struct {
	MyTimes       uint32 `protobuf:"varint,1,opt,name=MyTimes,proto3" json:"MyTimes,omitempty"`
	MaxMyTimes    uint32 `protobuf:"varint,2,opt,name=MaxMyTimes,proto3" json:"MaxMyTimes,omitempty"`
	OtherTimes    uint32 `protobuf:"varint,3,opt,name=OtherTimes,proto3" json:"OtherTimes,omitempty"`
	MaxOtherTimes uint32 `protobuf:"varint,4,opt,name=MaxOtherTimes,proto3" json:"MaxOtherTimes,omitempty"`
}

func (m *FastBattleStageInfo) Reset()         { *m = FastBattleStageInfo{} }
func (m *FastBattleStageInfo) String() string { return proto.CompactTextString(m) }
func (*FastBattleStageInfo) ProtoMessage()    {}
func (*FastBattleStageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{8}
}
func (m *FastBattleStageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FastBattleStageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FastBattleStageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FastBattleStageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FastBattleStageInfo.Merge(m, src)
}
func (m *FastBattleStageInfo) XXX_Size() int {
	return m.Size()
}
func (m *FastBattleStageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FastBattleStageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FastBattleStageInfo proto.InternalMessageInfo

func (m *FastBattleStageInfo) GetMyTimes() uint32 {
	if m != nil {
		return m.MyTimes
	}
	return 0
}

func (m *FastBattleStageInfo) GetMaxMyTimes() uint32 {
	if m != nil {
		return m.MaxMyTimes
	}
	return 0
}

func (m *FastBattleStageInfo) GetOtherTimes() uint32 {
	if m != nil {
		return m.OtherTimes
	}
	return 0
}

func (m *FastBattleStageInfo) GetMaxOtherTimes() uint32 {
	if m != nil {
		return m.MaxOtherTimes
	}
	return 0
}

type SupplyInfo struct {
	BoxMold     map[uint32]*State `protobuf:"bytes,1,rep,name=BoxMold,proto3" json:"BoxMold,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DiscountNum map[uint32]uint32 `protobuf:"bytes,2,rep,name=DiscountNum,proto3" json:"DiscountNum,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *SupplyInfo) Reset()         { *m = SupplyInfo{} }
func (m *SupplyInfo) String() string { return proto.CompactTextString(m) }
func (*SupplyInfo) ProtoMessage()    {}
func (*SupplyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{9}
}
func (m *SupplyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyInfo.Merge(m, src)
}
func (m *SupplyInfo) XXX_Size() int {
	return m.Size()
}
func (m *SupplyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyInfo proto.InternalMessageInfo

func (m *SupplyInfo) GetBoxMold() map[uint32]*State {
	if m != nil {
		return m.BoxMold
	}
	return nil
}

func (m *SupplyInfo) GetDiscountNum() map[uint32]uint32 {
	if m != nil {
		return m.DiscountNum
	}
	return nil
}

type State struct {
	HoldNum uint32 `protobuf:"varint,1,opt,name=HoldNum,proto3" json:"HoldNum,omitempty"`
	OpenNum uint32 `protobuf:"varint,2,opt,name=OpenNum,proto3" json:"OpenNum,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{10}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(m, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

func (m *State) GetHoldNum() uint32 {
	if m != nil {
		return m.HoldNum
	}
	return 0
}

func (m *State) GetOpenNum() uint32 {
	if m != nil {
		return m.OpenNum
	}
	return 0
}

// 补给收益道具
type SupplyAwardItem struct {
	ID   string        `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Type ItemEnum_Type `protobuf:"varint,2,opt,name=Type,proto3,enum=ItemEnum_Type" json:"Type,omitempty"`
	Num  uint32        `protobuf:"varint,3,opt,name=Num,proto3" json:"Num,omitempty"`
}

func (m *SupplyAwardItem) Reset()         { *m = SupplyAwardItem{} }
func (m *SupplyAwardItem) String() string { return proto.CompactTextString(m) }
func (*SupplyAwardItem) ProtoMessage()    {}
func (*SupplyAwardItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{11}
}
func (m *SupplyAwardItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyAwardItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyAwardItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyAwardItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyAwardItem.Merge(m, src)
}
func (m *SupplyAwardItem) XXX_Size() int {
	return m.Size()
}
func (m *SupplyAwardItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyAwardItem.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyAwardItem proto.InternalMessageInfo

func (m *SupplyAwardItem) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *SupplyAwardItem) GetType() ItemEnum_Type {
	if m != nil {
		return m.Type
	}
	return ItemEnum_ZeroNoUse
}

func (m *SupplyAwardItem) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type SupplyAwardData struct {
	SupplyAwardItems []*SupplyAwardItem `protobuf:"bytes,1,rep,name=SupplyAwardItems,proto3" json:"SupplyAwardItems,omitempty"`
	SupplyAwardMail  []*Item            `protobuf:"bytes,2,rep,name=SupplyAwardMail,proto3" json:"SupplyAwardMail,omitempty"`
}

func (m *SupplyAwardData) Reset()         { *m = SupplyAwardData{} }
func (m *SupplyAwardData) String() string { return proto.CompactTextString(m) }
func (*SupplyAwardData) ProtoMessage()    {}
func (*SupplyAwardData) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{12}
}
func (m *SupplyAwardData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyAwardData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyAwardData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyAwardData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyAwardData.Merge(m, src)
}
func (m *SupplyAwardData) XXX_Size() int {
	return m.Size()
}
func (m *SupplyAwardData) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyAwardData.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyAwardData proto.InternalMessageInfo

func (m *SupplyAwardData) GetSupplyAwardItems() []*SupplyAwardItem {
	if m != nil {
		return m.SupplyAwardItems
	}
	return nil
}

func (m *SupplyAwardData) GetSupplyAwardMail() []*Item {
	if m != nil {
		return m.SupplyAwardMail
	}
	return nil
}

//称号
type Title struct {
	TitleID   uint32                `protobuf:"varint,1,opt,name=TitleID,proto3" json:"TitleID,omitempty"`
	TitleList map[uint32]*TitleInfo `protobuf:"bytes,2,rep,name=TitleList,proto3" json:"TitleList,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Title) Reset()         { *m = Title{} }
func (m *Title) String() string { return proto.CompactTextString(m) }
func (*Title) ProtoMessage()    {}
func (*Title) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{13}
}
func (m *Title) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Title) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Title.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Title) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Title.Merge(m, src)
}
func (m *Title) XXX_Size() int {
	return m.Size()
}
func (m *Title) XXX_DiscardUnknown() {
	xxx_messageInfo_Title.DiscardUnknown(m)
}

var xxx_messageInfo_Title proto.InternalMessageInfo

func (m *Title) GetTitleID() uint32 {
	if m != nil {
		return m.TitleID
	}
	return 0
}

func (m *Title) GetTitleList() map[uint32]*TitleInfo {
	if m != nil {
		return m.TitleList
	}
	return nil
}

type TitleInfo struct {
	TitleID   uint32 `protobuf:"varint,1,opt,name=TitleID,proto3" json:"TitleID,omitempty"`
	StartTime int64  `protobuf:"varint,2,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	LostTime  int64  `protobuf:"varint,3,opt,name=LostTime,proto3" json:"LostTime,omitempty"`
}

func (m *TitleInfo) Reset()         { *m = TitleInfo{} }
func (m *TitleInfo) String() string { return proto.CompactTextString(m) }
func (*TitleInfo) ProtoMessage()    {}
func (*TitleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_03a75359bbd62449, []int{14}
}
func (m *TitleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TitleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TitleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TitleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TitleInfo.Merge(m, src)
}
func (m *TitleInfo) XXX_Size() int {
	return m.Size()
}
func (m *TitleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TitleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TitleInfo proto.InternalMessageInfo

func (m *TitleInfo) GetTitleID() uint32 {
	if m != nil {
		return m.TitleID
	}
	return 0
}

func (m *TitleInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *TitleInfo) GetLostTime() int64 {
	if m != nil {
		return m.LostTime
	}
	return 0
}

func init() {
	proto.RegisterType((*Role)(nil), "Role")
	proto.RegisterMapType((map[string]*BuildData)(nil), "Role.BuildMapEntry")
	proto.RegisterMapType((map[string]*RoleInviteInfo)(nil), "Role.InvitesEntry")
	proto.RegisterMapType((map[int32]*ItemContainer)(nil), "Role.ItemContainerMapEntry")
	proto.RegisterMapType((map[string]*RedPointInfo)(nil), "Role.RedPointsDataEntry")
	proto.RegisterMapType((map[uint32]*SkillData)(nil), "Role.SkillsLearnedEntry")
	proto.RegisterMapType((map[uint32]*SpecialAgent)(nil), "Role.SpecialAgentListEntry")
	proto.RegisterType((*RoleBase)(nil), "RoleBase")
	proto.RegisterType((*RoleInviteInfo)(nil), "RoleInviteInfo")
	proto.RegisterType((*RoleChat)(nil), "RoleChat")
	proto.RegisterMapType((map[string]bool)(nil), "RoleChat.ChatChannelsEntry")
	proto.RegisterType((*ShareSpoils)(nil), "ShareSpoils")
	proto.RegisterMapType((map[string]*GiveSkillCount)(nil), "ShareSpoils.GiveSkillToTargetCountEntry")
	proto.RegisterMapType((map[string]*RequestSkill)(nil), "ShareSpoils.RequestSkillDataEntry")
	proto.RegisterType((*GiveSkillCount)(nil), "GiveSkillCount")
	proto.RegisterMapType((map[uint32]uint32)(nil), "GiveSkillCount.GiveSkillToTargetCountEntry")
	proto.RegisterType((*RequestSkill)(nil), "RequestSkill")
	proto.RegisterMapType((map[string]uint32)(nil), "RequestSkill.TeamMateGiveSkillCountEntry")
	proto.RegisterType((*FastBattle)(nil), "FastBattle")
	proto.RegisterMapType((map[uint32]*FastBattleStageInfo)(nil), "FastBattle.StageInfoEntry")
	proto.RegisterType((*FastBattleStageInfo)(nil), "FastBattleStageInfo")
	proto.RegisterType((*SupplyInfo)(nil), "SupplyInfo")
	proto.RegisterMapType((map[uint32]*State)(nil), "SupplyInfo.BoxMoldEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "SupplyInfo.DiscountNumEntry")
	proto.RegisterType((*State)(nil), "State")
	proto.RegisterType((*SupplyAwardItem)(nil), "SupplyAwardItem")
	proto.RegisterType((*SupplyAwardData)(nil), "SupplyAwardData")
	proto.RegisterType((*Title)(nil), "Title")
	proto.RegisterMapType((map[uint32]*TitleInfo)(nil), "Title.TitleListEntry")
	proto.RegisterType((*TitleInfo)(nil), "TitleInfo")
}

func init() { proto.RegisterFile("RoleDef.proto", fileDescriptor_03a75359bbd62449) }

var fileDescriptor_03a75359bbd62449 = []byte{
	// 1647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x0e, 0x65, 0xc9, 0x96, 0x47, 0xa6, 0x6c, 0xaf, 0x3f, 0x5e, 0x42, 0xf1, 0xeb, 0x1a, 0x6a,
	0x5a, 0x38, 0x1f, 0x60, 0x8a, 0x04, 0x28, 0x82, 0xb6, 0x70, 0x10, 0x5b, 0x8e, 0x23, 0x54, 0x8a,
	0x8d, 0x95, 0x83, 0x02, 0xb9, 0xb4, 0x5b, 0x6b, 0x2d, 0x13, 0xa1, 0x48, 0x85, 0x5c, 0x39, 0x76,
	0x4f, 0x3d, 0xf4, 0xd8, 0x43, 0x2f, 0xbd, 0xf4, 0xd4, 0x43, 0x7f, 0x48, 0x8f, 0x3d, 0xa6, 0xb7,
	0x1e, 0x7a, 0x28, 0x92, 0x3f, 0x52, 0xcc, 0xee, 0x52, 0x5a, 0x52, 0x54, 0xea, 0xf6, 0x24, 0xee,
	0xf3, 0xcc, 0x3e, 0x3b, 0x3b, 0x3b, 0x33, 0x5c, 0x0a, 0x6c, 0x1a, 0xfa, 0xbc, 0xc1, 0x4f, 0xdd,
	0x41, 0x14, 0x8a, 0xb0, 0xb6, 0xd6, 0x19, 0xf0, 0x13, 0x8f, 0xf9, 0x8f, 0x7a, 0x3c, 0x10, 0x63,
	0xd8, 0x6e, 0x0a, 0xde, 0x1f, 0x0f, 0xab, 0x38, 0xdc, 0x65, 0x31, 0x4f, 0xc6, 0x8f, 0xbd, 0xde,
	0x99, 0x61, 0x5e, 0xa5, 0xbc, 0x7b, 0x14, 0x7a, 0x81, 0x48, 0xa6, 0xb7, 0x99, 0xe7, 0x8f, 0xe9,
	0xc5, 0xc7, 0x91, 0xc7, 0x83, 0xae, 0x01, 0x74, 0x38, 0x8b, 0xc3, 0xc0, 0x10, 0x78, 0xf4, 0x8a,
	0x45, 0x63, 0x83, 0xfa, 0x2f, 0x15, 0x28, 0xa2, 0xa3, 0xe4, 0xff, 0x50, 0xc4, 0x75, 0x1d, 0x6b,
	0xcb, 0xda, 0xae, 0xdc, 0x9b, 0x77, 0x11, 0x44, 0x80, 0x4a, 0x98, 0xdc, 0x81, 0xb9, 0x66, 0x70,
	0xee, 0x09, 0x1e, 0x3b, 0x85, 0xad, 0x99, 0xed, 0xca, 0x3d, 0x22, 0x2d, 0x5c, 0x0d, 0xee, 0x07,
	0x22, 0xba, 0xa4, 0x89, 0x09, 0xd9, 0x04, 0x68, 0x06, 0x9e, 0xe0, 0xdd, 0xc3, 0xe0, 0x84, 0x3b,
	0xc5, 0x2d, 0x6b, 0xbb, 0x4c, 0x0d, 0x84, 0x1c, 0xc0, 0x92, 0x19, 0x8e, 0x96, 0x17, 0x0b, 0xa7,
	0x24, 0x65, 0xaf, 0x2b, 0xd9, 0x2c, 0xab, 0xf4, 0x27, 0x26, 0x91, 0xbb, 0x50, 0xde, 0x1d, 0x7a,
	0x7e, 0xb7, 0xcd, 0x06, 0xce, 0xac, 0x14, 0x58, 0x51, 0x02, 0x09, 0xaa, 0x26, 0x8e, 0x8c, 0xc8,
	0x36, 0x2c, 0xca, 0x90, 0x7a, 0x41, 0x4f, 0x62, 0xcd, 0x86, 0x33, 0xb7, 0x65, 0x6d, 0xcf, 0xd3,
	0x2c, 0x8c, 0x3e, 0xe2, 0x61, 0xec, 0x85, 0x81, 0x60, 0x5e, 0xc0, 0x23, 0x5c, 0xa2, 0x6c, 0xfa,
	0x98, 0x65, 0xb5, 0x8f, 0x59, 0x18, 0x23, 0xbb, 0x77, 0xc6, 0x84, 0x33, 0x6f, 0x44, 0x16, 0x01,
	0x2a, 0x61, 0xe2, 0x42, 0xa5, 0x19, 0x9c, 0xf1, 0xc8, 0x13, 0x8f, 0x84, 0x88, 0x1c, 0x90, 0x56,
	0x0b, 0xee, 0x11, 0x7b, 0x15, 0x68, 0x9c, 0x9a, 0x06, 0x84, 0x40, 0xf1, 0x20, 0xf4, 0xbb, 0x4e,
	0x65, 0xcb, 0xda, 0x2e, 0x52, 0xf9, 0x4c, 0x1c, 0x98, 0x6b, 0x78, 0xac, 0x1f, 0x06, 0x5d, 0x67,
	0x41, 0xc2, 0xc9, 0x90, 0x3c, 0x84, 0xe5, 0xc3, 0xd3, 0x53, 0xdf, 0x0b, 0xb8, 0x3a, 0x78, 0x26,
	0x58, 0xec, 0xd8, 0x72, 0x8d, 0x65, 0x37, 0xcb, 0xd0, 0x49, 0x5b, 0xb2, 0x03, 0x76, 0xe7, 0x85,
	0xe7, 0xfb, 0x71, 0x8b, 0xb3, 0x28, 0xe0, 0x5d, 0xa7, 0x2a, 0x63, 0xe0, 0xe8, 0x73, 0x32, 0x29,
	0x15, 0x80, 0xb4, 0x39, 0xce, 0x4f, 0x72, 0x36, 0x46, 0x45, 0x67, 0xd1, 0x9c, 0x9f, 0xa2, 0xf4,
	0xfc, 0x14, 0x46, 0x6e, 0x03, 0x3c, 0x66, 0xb1, 0xd8, 0x65, 0x42, 0xf8, 0xdc, 0x59, 0x92, 0x9e,
	0x57, 0xdc, 0x31, 0x44, 0x0d, 0x9a, 0xd4, 0x61, 0x0e, 0x0b, 0x62, 0x37, 0xbc, 0x70, 0x96, 0xa5,
	0x65, 0xd9, 0xd5, 0x63, 0x9a, 0x10, 0x18, 0xef, 0xce, 0x19, 0x8b, 0x78, 0x67, 0x10, 0x7a, 0x7e,
	0xec, 0x10, 0x1d, 0x6f, 0x03, 0xa3, 0xa6, 0x01, 0xd9, 0x80, 0xd2, 0xb1, 0x87, 0x6b, 0xaf, 0x48,
	0xcb, 0x59, 0x57, 0x8e, 0xa8, 0x02, 0xd1, 0xbd, 0xce, 0x70, 0x30, 0xf0, 0x2f, 0x9b, 0xc1, 0x69,
	0xe8, 0xac, 0x6a, 0xf7, 0xc6, 0x10, 0x35, 0x68, 0x72, 0x13, 0xe6, 0x54, 0x81, 0xc6, 0xce, 0x9a,
	0xb4, 0x5c, 0x74, 0xd5, 0x18, 0x73, 0x59, 0x1e, 0x40, 0xc2, 0x93, 0xbb, 0x00, 0xaa, 0x74, 0xa5,
	0xee, 0xba, 0xb6, 0xc6, 0x98, 0x8d, 0x61, 0x6a, 0x98, 0xd4, 0x3e, 0x87, 0x05, 0xb3, 0x16, 0xc9,
	0x12, 0xcc, 0xbc, 0xe0, 0x97, 0xb2, 0x9c, 0xe7, 0x29, 0x3e, 0x92, 0x0f, 0xa0, 0x74, 0xce, 0xfc,
	0x21, 0x77, 0x0a, 0x86, 0x9a, 0x9a, 0x23, 0xd5, 0x14, 0xfb, 0x49, 0xe1, 0x81, 0x55, 0xa3, 0xb0,
	0x96, 0x5b, 0x81, 0xa6, 0xaa, 0xad, 0x54, 0xdf, 0x4f, 0xab, 0xda, 0xa9, 0xd2, 0x35, 0x35, 0x0f,
	0xc0, 0x4e, 0x15, 0x65, 0x8e, 0x87, 0x5b, 0x69, 0x2d, 0x50, 0x55, 0x2c, 0x03, 0x63, 0x08, 0x75,
	0x60, 0x2d, 0xb7, 0xf4, 0x4c, 0xc1, 0x92, 0x12, 0xbc, 0x91, 0x16, 0xac, 0xa6, 0x6b, 0xd6, 0x14,
	0x6d, 0x01, 0x99, 0xcc, 0xe5, 0x9c, 0xed, 0x4e, 0xb8, 0x28, 0x67, 0x65, 0x5d, 0x3c, 0x04, 0x32,
	0x99, 0xd9, 0x39, 0x1b, 0x9e, 0x08, 0x5e, 0x32, 0x2b, 0x73, 0x20, 0xf5, 0x5f, 0x0b, 0x50, 0x4e,
	0x3a, 0x32, 0x76, 0x80, 0xa7, 0xac, 0xcf, 0xb5, 0x90, 0x7c, 0x46, 0xed, 0xfd, 0x8b, 0x81, 0xd4,
	0x29, 0x52, 0x7c, 0x44, 0xa4, 0xc3, 0x2f, 0x9c, 0x19, 0xe5, 0x7b, 0x87, 0x5f, 0x60, 0x57, 0xde,
	0x8b, 0x38, 0x13, 0xfc, 0xd8, 0xeb, 0xab, 0xae, 0x3c, 0x43, 0x0d, 0x84, 0x7c, 0x08, 0xd5, 0x16,
	0x8b, 0x45, 0x2b, 0xec, 0x85, 0x43, 0x21, 0x6d, 0x4a, 0xd2, 0x26, 0x83, 0x92, 0x1b, 0x60, 0x6b,
	0xc4, 0x0b, 0xa4, 0xd9, 0xac, 0x34, 0x4b, 0x83, 0x64, 0x15, 0x4a, 0x2d, 0x7e, 0xce, 0x7d, 0xd9,
	0x5f, 0x6d, 0xaa, 0x06, 0x64, 0x1d, 0x66, 0x8f, 0x39, 0xeb, 0x37, 0x1b, 0x4e, 0x59, 0x7a, 0xaf,
	0x47, 0xa4, 0x0e, 0x0b, 0x94, 0x79, 0xdd, 0xa3, 0x28, 0xec, 0x45, 0x3c, 0x8e, 0x65, 0xb3, 0xb4,
	0x69, 0x0a, 0xc3, 0xb9, 0x87, 0x01, 0xb6, 0x27, 0xd9, 0x24, 0xcb, 0x54, 0x8f, 0x30, 0x1e, 0x4f,
	0x38, 0xeb, 0xca, 0xb6, 0x66, 0x53, 0xf9, 0x8c, 0xbb, 0x7f, 0xd6, 0x6c, 0x38, 0x55, 0x15, 0x8f,
	0x67, 0xcd, 0x46, 0xbd, 0x01, 0xd5, 0x74, 0xc2, 0xab, 0xb7, 0x54, 0x2c, 0xbc, 0x1e, 0x13, 0x61,
	0xa4, 0xa3, 0x69, 0x20, 0xa8, 0x2b, 0xb7, 0x57, 0x90, 0xdb, 0x93, 0xcf, 0xf5, 0xef, 0x2d, 0x75,
	0x10, 0xb2, 0x75, 0x3f, 0x84, 0x05, 0xfc, 0xdd, 0x3b, 0x63, 0x41, 0xc0, 0xfd, 0xd8, 0xb1, 0x8c,
	0xd7, 0x03, 0x12, 0xae, 0xc9, 0xaa, 0xee, 0x96, 0x9a, 0x50, 0x7b, 0x08, 0xcb, 0x13, 0x26, 0x39,
	0x69, 0xb2, 0x6a, 0xa6, 0x49, 0xd9, 0xcc, 0x8b, 0xdf, 0x4b, 0xa9, 0x6e, 0x86, 0x47, 0x78, 0xe0,
	0x9d, 0xf3, 0xfd, 0x97, 0x43, 0x6f, 0xb0, 0x17, 0x0e, 0x03, 0xa1, 0x73, 0x37, 0x83, 0x92, 0x1d,
	0xa8, 0x51, 0xfe, 0x72, 0xc8, 0x63, 0x21, 0xf3, 0x97, 0xf2, 0x98, 0xcb, 0xb3, 0xed, 0x08, 0xd6,
	0x1f, 0xe8, 0x0d, 0xbf, 0xc3, 0x82, 0xdc, 0x81, 0x65, 0x93, 0x55, 0x4b, 0xa9, 0x54, 0x9b, 0x24,
	0xc8, 0xc7, 0xb0, 0x3e, 0x01, 0xb6, 0xbc, 0xbe, 0x27, 0x64, 0x12, 0xda, 0x74, 0x0a, 0x4b, 0x1e,
	0xc0, 0xff, 0xd0, 0xef, 0x3c, 0x17, 0x55, 0x66, 0x4e, 0xa3, 0x93, 0x38, 0x18, 0xce, 0xcd, 0x8e,
	0xe3, 0x60, 0x78, 0xf6, 0x11, 0xac, 0xa4, 0x11, 0xe5, 0x96, 0x4a, 0xd9, 0x3c, 0x8a, 0x3c, 0x85,
	0x25, 0xd3, 0x5b, 0xf9, 0x4a, 0x53, 0xd7, 0x82, 0xba, 0xf9, 0x0e, 0x71, 0xb3, 0x46, 0xfa, 0x76,
	0x90, 0x85, 0xc9, 0x57, 0xb0, 0x3e, 0x5a, 0xe6, 0x38, 0x3c, 0x66, 0x51, 0x8f, 0x0b, 0xe5, 0xf1,
	0xbc, 0x54, 0xdd, 0x4e, 0xa9, 0xe6, 0x9b, 0x2a, 0xed, 0x29, 0x3a, 0xd8, 0xcc, 0x73, 0x9d, 0xb9,
	0x5a, 0x3f, 0x32, 0x52, 0xc0, 0x68, 0x70, 0xcf, 0xe1, 0xfa, 0x3b, 0x5c, 0xb9, 0xca, 0xcb, 0x27,
	0x1d, 0xdb, 0x54, 0xaf, 0xb3, 0xb2, 0x87, 0x47, 0x4e, 0xa6, 0x06, 0x49, 0x95, 0xdc, 0xed, 0x8c,
	0xdc, 0x7f, 0x8a, 0x53, 0xf3, 0xca, 0x7b, 0xb2, 0x73, 0xca, 0xd2, 0x36, 0xb7, 0xf0, 0x53, 0x11,
	0x16, 0xcc, 0xd0, 0x91, 0x5b, 0xa3, 0xac, 0x69, 0xf3, 0x38, 0x66, 0x3d, 0xde, 0xec, 0x6a, 0xa5,
	0x09, 0xdc, 0xa8, 0x96, 0x71, 0x6f, 0x36, 0xeb, 0x72, 0x0a, 0x4b, 0x5c, 0x7c, 0xe9, 0x8c, 0xd7,
	0xc4, 0x57, 0x5d, 0xb3, 0xab, 0x8b, 0x32, 0x87, 0xc1, 0x36, 0xae, 0x22, 0x36, 0x8c, 0x54, 0xa3,
	0x56, 0xc5, 0x98, 0x06, 0x95, 0xea, 0x09, 0xf7, 0xce, 0x79, 0xd7, 0xa8, 0xa6, 0x52, 0xa2, 0x9a,
	0x65, 0xb0, 0x66, 0x75, 0x41, 0x2a, 0xca, 0xa8, 0x2a, 0x55, 0x82, 0xd3, 0x68, 0x9c, 0xa9, 0xbd,
	0xc4, 0x3d, 0x1d, 0x0e, 0x8d, 0x6a, 0x9f, 0x53, 0xd5, 0x3e, 0x85, 0x26, 0x0c, 0xd6, 0xf1, 0x35,
	0xd2, 0x66, 0x82, 0x67, 0xaa, 0x5e, 0x55, 0xe6, 0xcd, 0x54, 0x1e, 0xbb, 0xf9, 0xb6, 0x3a, 0x39,
	0xf2, 0x49, 0x4c, 0x8e, 0x77, 0x4c, 0xfb, 0xa7, 0x9e, 0x9d, 0x4a, 0x8e, 0x3f, 0x2d, 0xf3, 0x4a,
	0x4b, 0x1e, 0xc0, 0x7c, 0x47, 0xe0, 0xc9, 0xe3, 0x45, 0x4f, 0xa5, 0x73, 0xcd, 0xb8, 0xdf, 0xba,
	0x23, 0x52, 0x39, 0x38, 0x36, 0x26, 0x5b, 0x50, 0xd9, 0x0f, 0x78, 0xd4, 0xf3, 0xbe, 0xe1, 0x4f,
	0x87, 0x7d, 0xbd, 0x90, 0x09, 0xe1, 0x1b, 0x4e, 0x5e, 0xe5, 0xdb, 0x43, 0x5f, 0x78, 0x32, 0x15,
	0x0a, 0xd4, 0x40, 0x6a, 0x14, 0xaa, 0x69, 0xf9, 0x9c, 0x2c, 0xbf, 0x95, 0xae, 0xdc, 0x55, 0xc3,
	0xb7, 0xd1, 0x5c, 0x73, 0x7b, 0x3f, 0x5a, 0xb0, 0x92, 0x63, 0x82, 0xdf, 0x28, 0xed, 0x4b, 0x3c,
	0xb3, 0x58, 0xab, 0x27, 0x43, 0xf4, 0xb2, 0xcd, 0x2e, 0x12, 0x52, 0x6d, 0xc3, 0x40, 0x90, 0x3f,
	0x14, 0x67, 0x3c, 0x52, 0xbc, 0x4a, 0x68, 0x03, 0xc1, 0x44, 0x6e, 0xb3, 0x0b, 0xc3, 0x44, 0x27,
	0x72, 0x0a, 0xac, 0x7f, 0x57, 0x30, 0xaf, 0xea, 0xe4, 0x1e, 0xcc, 0xed, 0x86, 0x17, 0x6d, 0xfc,
	0x92, 0xb2, 0xf4, 0x17, 0xc9, 0x98, 0x75, 0x35, 0xa5, 0x3f, 0x6b, 0xf5, 0x88, 0xec, 0x40, 0xa5,
	0xe1, 0xc5, 0x27, 0x78, 0xec, 0x2a, 0xe0, 0x38, 0x6f, 0xc3, 0x9c, 0x67, 0xd0, 0x6a, 0xae, 0x39,
	0xa1, 0xb6, 0x0b, 0x0b, 0xa6, 0x70, 0x4e, 0xb0, 0x37, 0xd2, 0xc1, 0x9e, 0xc5, 0xd3, 0x17, 0xdc,
	0xec, 0xbc, 0x3b, 0xb0, 0x94, 0x5d, 0xe4, 0x5f, 0xb5, 0xa6, 0x4f, 0xa1, 0x24, 0x35, 0xf1, 0x3c,
	0x9e, 0x84, 0x7e, 0x17, 0x37, 0xa2, 0xcf, 0x43, 0x0f, 0x91, 0x39, 0x1c, 0xf0, 0x60, 0x9c, 0x53,
	0xc9, 0xb0, 0xfe, 0x05, 0x2c, 0xaa, 0xcd, 0xca, 0x1c, 0xc2, 0x3e, 0x42, 0xaa, 0x50, 0x68, 0x36,
	0x74, 0xe2, 0x17, 0xe4, 0x45, 0xae, 0x78, 0x7c, 0x39, 0x50, 0x0b, 0x57, 0xf5, 0x8d, 0x7b, 0x3f,
	0x18, 0xf6, 0x5d, 0x44, 0xa9, 0xe4, 0xd0, 0x5f, 0x14, 0xd7, 0x57, 0x53, 0x14, 0xfe, 0xd6, 0x4a,
	0x29, 0xcb, 0x37, 0xe3, 0x67, 0xb0, 0x94, 0x59, 0x2c, 0xb9, 0x61, 0x2d, 0xb9, 0x19, 0x82, 0x4e,
	0x58, 0x92, 0xbb, 0x29, 0x41, 0xfc, 0xf8, 0xd3, 0xe7, 0x55, 0x92, 0x2e, 0xd1, 0x2c, 0x5b, 0xff,
	0xd9, 0xd2, 0x1f, 0x7a, 0xb8, 0x7f, 0xf9, 0xa0, 0xf7, 0x65, 0xd3, 0x64, 0x48, 0xee, 0xc3, 0xbc,
	0x7c, 0x94, 0x7f, 0x58, 0x28, 0xb9, 0x35, 0xf5, 0x3d, 0xe8, 0x8e, 0x70, 0x5d, 0xa6, 0xa3, 0x71,
	0xed, 0x09, 0x54, 0xd3, 0xe4, 0x55, 0x3e, 0x2b, 0xd4, 0x8a, 0x99, 0xd2, 0xfa, 0x52, 0x2f, 0x9f,
	0xd4, 0xd3, 0x14, 0x2f, 0x37, 0x64, 0x47, 0x89, 0x84, 0x71, 0x79, 0x1d, 0x03, 0xa4, 0x06, 0xe5,
	0x56, 0xa8, 0x9a, 0xa8, 0x3c, 0x81, 0x19, 0x3a, 0x1a, 0xef, 0xbe, 0xf7, 0xdb, 0x9b, 0x4d, 0xeb,
	0xf5, 0x9b, 0x4d, 0xeb, 0xaf, 0x37, 0x9b, 0xd6, 0x0f, 0x6f, 0x37, 0xaf, 0xbd, 0x7e, 0xbb, 0x79,
	0xed, 0x8f, 0xb7, 0x9b, 0xd7, 0x9e, 0x97, 0x8e, 0xa2, 0x50, 0x84, 0x5f, 0xcf, 0xca, 0x7f, 0x8d,
	0xee, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x38, 0x12, 0xb9, 0x23, 0xdd, 0x12, 0x00, 0x00,
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Role) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeasonInfo != nil {
		{
			size, err := m.SeasonInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Friends != nil {
		{
			size, err := m.Friends.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.SupplyInfo != nil {
		{
			size, err := m.SupplyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Title != nil {
		{
			size, err := m.Title.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ShareSpoils != nil {
		{
			size, err := m.ShareSpoils.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.MailBox != nil {
		{
			size, err := m.MailBox.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.FastBattle != nil {
		{
			size, err := m.FastBattle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RedPointsData) > 0 {
		for k := range m.RedPointsData {
			v := m.RedPointsData[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.SkillsLearned) > 0 {
		for k := range m.SkillsLearned {
			v := m.SkillsLearned[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.OfflineAwardDatas != nil {
		{
			size, err := m.OfflineAwardDatas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Diamond != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x60
	}
	if m.Gold != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Gold))
		i--
		dAtA[i] = 0x58
	}
	if m.InheritAttr != nil {
		{
			size, err := m.InheritAttr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Chat != nil {
		{
			size, err := m.Chat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ItemContainerMap) > 0 {
		for k := range m.ItemContainerMap {
			v := m.ItemContainerMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FightingBuildID) > 0 {
		i -= len(m.FightingBuildID)
		copy(dAtA[i:], m.FightingBuildID)
		i = encodeVarintRoleDef(dAtA, i, uint64(len(m.FightingBuildID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BuildMap) > 0 {
		for k := range m.BuildMap {
			v := m.BuildMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SpecialAgentList) > 0 {
		for k := range m.SpecialAgentList {
			v := m.SpecialAgentList[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.InitedOnce {
		i--
		if m.InitedOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Invites) > 0 {
		for k := range m.Invites {
			v := m.Invites[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRoleDef(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x70
	}
	if m.Head != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Head))
		i--
		dAtA[i] = 0x68
	}
	if m.Online {
		i--
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.RaidProgress != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RaidProgress))
		i--
		dAtA[i] = 0x48
	}
	if len(m.TeamID) > 0 {
		i -= len(m.TeamID)
		copy(dAtA[i:], m.TeamID)
		i = encodeVarintRoleDef(dAtA, i, uint64(len(m.TeamID)))
		i--
		dAtA[i] = 0x42
	}
	if m.Level != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x38
	}
	if m.LastLoginTime != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.LastLoginTime))
		i--
		dAtA[i] = 0x30
	}
	if m.LastLogoutTime != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.LastLogoutTime))
		i--
		dAtA[i] = 0x28
	}
	if m.CreateTime != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Sex != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Sex))
		i--
		dAtA[i] = 0x18
	}
	if m.Exp != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Exp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoleDef(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleInviteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleInviteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleInviteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Instigator) > 0 {
		i -= len(m.Instigator)
		copy(dAtA[i:], m.Instigator)
		i = encodeVarintRoleDef(dAtA, i, uint64(len(m.Instigator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleChat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleChat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChatChannels) > 0 {
		for k := range m.ChatChannels {
			v := m.ChatChannels[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShareSpoils) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareSpoils) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareSpoils) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GiveSkillToTargetCount) > 0 {
		for k := range m.GiveSkillToTargetCount {
			v := m.GiveSkillToTargetCount[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RequestSkillData) > 0 {
		for k := range m.RequestSkillData {
			v := m.RequestSkillData[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.GiveSkillCountLimit != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.GiveSkillCountLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.GiveSkillCount != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.GiveSkillCount))
		i--
		dAtA[i] = 0x30
	}
	if m.GiveSkillResetTimeStamp != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.GiveSkillResetTimeStamp))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestSkillCountLimit != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestSkillCountLimit))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestSkillCount != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestSkillCount))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestSkillResetTimeStamp != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestSkillResetTimeStamp))
		i--
		dAtA[i] = 0x10
	}
	if m.GiveEquipCount != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.GiveEquipCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GiveSkillCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiveSkillCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GiveSkillCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GiveSkillToTargetCount) > 0 {
		for k := range m.GiveSkillToTargetCount {
			v := m.GiveSkillToTargetCount[k]
			baseI := i
			i = encodeVarintRoleDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TeamMateGiveSkillCount) > 0 {
		for k := range m.TeamMateGiveSkillCount {
			v := m.TeamMateGiveSkillCount[k]
			baseI := i
			i = encodeVarintRoleDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRoleDef(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.RequestTimeOutTimeStamp != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestTimeOutTimeStamp))
		i--
		dAtA[i] = 0x38
	}
	if m.SkillReceivedCountLimit != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.SkillReceivedCountLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.ReceivedSkillCount != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.ReceivedSkillCount))
		i--
		dAtA[i] = 0x28
	}
	if m.SkillCurLevel != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.SkillCurLevel))
		i--
		dAtA[i] = 0x20
	}
	if m.RequestSkillItemId != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestSkillItemId))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestCreateTimeStamp != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestCreateTimeStamp))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestMessageId != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.RequestMessageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FastBattle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FastBattle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FastBattle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AwardMulti != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AwardMulti))))
		i--
		dAtA[i] = 0x1d
	}
	if m.EnergizeNum != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.EnergizeNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StageInfo) > 0 {
		for k := range m.StageInfo {
			v := m.StageInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FastBattleStageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FastBattleStageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FastBattleStageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxOtherTimes != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.MaxOtherTimes))
		i--
		dAtA[i] = 0x20
	}
	if m.OtherTimes != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.OtherTimes))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxMyTimes != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.MaxMyTimes))
		i--
		dAtA[i] = 0x10
	}
	if m.MyTimes != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.MyTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SupplyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DiscountNum) > 0 {
		for k := range m.DiscountNum {
			v := m.DiscountNum[k]
			baseI := i
			i = encodeVarintRoleDef(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BoxMold) > 0 {
		for k := range m.BoxMold {
			v := m.BoxMold[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenNum != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.OpenNum))
		i--
		dAtA[i] = 0x10
	}
	if m.HoldNum != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.HoldNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SupplyAwardItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyAwardItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyAwardItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRoleDef(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SupplyAwardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyAwardData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyAwardData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupplyAwardMail) > 0 {
		for iNdEx := len(m.SupplyAwardMail) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupplyAwardMail[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoleDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SupplyAwardItems) > 0 {
		for iNdEx := len(m.SupplyAwardItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupplyAwardItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoleDef(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Title) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Title) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Title) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TitleList) > 0 {
		for k := range m.TitleList {
			v := m.TitleList[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintRoleDef(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRoleDef(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRoleDef(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TitleID != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.TitleID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TitleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TitleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TitleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LostTime != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.LostTime))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTime != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x10
	}
	if m.TitleID != 0 {
		i = encodeVarintRoleDef(dAtA, i, uint64(m.TitleID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRoleDef(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoleDef(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Role) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if len(m.Invites) > 0 {
		for k, v := range m.Invites {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if m.InitedOnce {
		n += 2
	}
	if len(m.SpecialAgentList) > 0 {
		for k, v := range m.SpecialAgentList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if len(m.BuildMap) > 0 {
		for k, v := range m.BuildMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	l = len(m.FightingBuildID)
	if l > 0 {
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if len(m.ItemContainerMap) > 0 {
		for k, v := range m.ItemContainerMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if m.Chat != nil {
		l = m.Chat.Size()
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.InheritAttr != nil {
		l = m.InheritAttr.Size()
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.Gold != 0 {
		n += 1 + sovRoleDef(uint64(m.Gold))
	}
	if m.Diamond != 0 {
		n += 1 + sovRoleDef(uint64(m.Diamond))
	}
	if m.OfflineAwardDatas != nil {
		l = m.OfflineAwardDatas.Size()
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if len(m.SkillsLearned) > 0 {
		for k, v := range m.SkillsLearned {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if len(m.RedPointsData) > 0 {
		for k, v := range m.RedPointsData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if m.FastBattle != nil {
		l = m.FastBattle.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.MailBox != nil {
		l = m.MailBox.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.ShareSpoils != nil {
		l = m.ShareSpoils.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.Title != nil {
		l = m.Title.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.SupplyInfo != nil {
		l = m.SupplyInfo.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.Friends != nil {
		l = m.Friends.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	if m.SeasonInfo != nil {
		l = m.SeasonInfo.Size()
		n += 2 + l + sovRoleDef(uint64(l))
	}
	return n
}

func (m *RoleBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.Exp != 0 {
		n += 1 + sovRoleDef(uint64(m.Exp))
	}
	if m.Sex != 0 {
		n += 1 + sovRoleDef(uint64(m.Sex))
	}
	if m.CreateTime != 0 {
		n += 1 + sovRoleDef(uint64(m.CreateTime))
	}
	if m.LastLogoutTime != 0 {
		n += 1 + sovRoleDef(uint64(m.LastLogoutTime))
	}
	if m.LastLoginTime != 0 {
		n += 1 + sovRoleDef(uint64(m.LastLoginTime))
	}
	if m.Level != 0 {
		n += 1 + sovRoleDef(uint64(m.Level))
	}
	l = len(m.TeamID)
	if l > 0 {
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.RaidProgress != 0 {
		n += 1 + sovRoleDef(uint64(m.RaidProgress))
	}
	if m.Online {
		n += 2
	}
	if m.Head != 0 {
		n += 1 + sovRoleDef(uint64(m.Head))
	}
	if m.UID != 0 {
		n += 1 + sovRoleDef(uint64(m.UID))
	}
	return n
}

func (m *RoleInviteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Instigator)
	if l > 0 {
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovRoleDef(uint64(m.Time))
	}
	return n
}

func (m *RoleChat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChatChannels) > 0 {
		for k, v := range m.ChatChannels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ShareSpoils) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GiveEquipCount != 0 {
		n += 1 + sovRoleDef(uint64(m.GiveEquipCount))
	}
	if m.RequestSkillResetTimeStamp != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestSkillResetTimeStamp))
	}
	if m.RequestSkillCount != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestSkillCount))
	}
	if m.RequestSkillCountLimit != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestSkillCountLimit))
	}
	if m.GiveSkillResetTimeStamp != 0 {
		n += 1 + sovRoleDef(uint64(m.GiveSkillResetTimeStamp))
	}
	if m.GiveSkillCount != 0 {
		n += 1 + sovRoleDef(uint64(m.GiveSkillCount))
	}
	if m.GiveSkillCountLimit != 0 {
		n += 1 + sovRoleDef(uint64(m.GiveSkillCountLimit))
	}
	if len(m.RequestSkillData) > 0 {
		for k, v := range m.RequestSkillData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if len(m.GiveSkillToTargetCount) > 0 {
		for k, v := range m.GiveSkillToTargetCount {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GiveSkillCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GiveSkillToTargetCount) > 0 {
		for k, v := range m.GiveSkillToTargetCount {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + 1 + sovRoleDef(uint64(v))
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RequestSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestMessageId != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestMessageId))
	}
	if m.RequestCreateTimeStamp != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestCreateTimeStamp))
	}
	if m.RequestSkillItemId != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestSkillItemId))
	}
	if m.SkillCurLevel != 0 {
		n += 1 + sovRoleDef(uint64(m.SkillCurLevel))
	}
	if m.ReceivedSkillCount != 0 {
		n += 1 + sovRoleDef(uint64(m.ReceivedSkillCount))
	}
	if m.SkillReceivedCountLimit != 0 {
		n += 1 + sovRoleDef(uint64(m.SkillReceivedCountLimit))
	}
	if m.RequestTimeOutTimeStamp != 0 {
		n += 1 + sovRoleDef(uint64(m.RequestTimeOutTimeStamp))
	}
	if len(m.TeamMateGiveSkillCount) > 0 {
		for k, v := range m.TeamMateGiveSkillCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRoleDef(uint64(len(k))) + 1 + sovRoleDef(uint64(v))
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FastBattle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StageInfo) > 0 {
		for k, v := range m.StageInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if m.EnergizeNum != 0 {
		n += 1 + sovRoleDef(uint64(m.EnergizeNum))
	}
	if m.AwardMulti != 0 {
		n += 5
	}
	return n
}

func (m *FastBattleStageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MyTimes != 0 {
		n += 1 + sovRoleDef(uint64(m.MyTimes))
	}
	if m.MaxMyTimes != 0 {
		n += 1 + sovRoleDef(uint64(m.MaxMyTimes))
	}
	if m.OtherTimes != 0 {
		n += 1 + sovRoleDef(uint64(m.OtherTimes))
	}
	if m.MaxOtherTimes != 0 {
		n += 1 + sovRoleDef(uint64(m.MaxOtherTimes))
	}
	return n
}

func (m *SupplyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BoxMold) > 0 {
		for k, v := range m.BoxMold {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	if len(m.DiscountNum) > 0 {
		for k, v := range m.DiscountNum {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + 1 + sovRoleDef(uint64(v))
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HoldNum != 0 {
		n += 1 + sovRoleDef(uint64(m.HoldNum))
	}
	if m.OpenNum != 0 {
		n += 1 + sovRoleDef(uint64(m.OpenNum))
	}
	return n
}

func (m *SupplyAwardItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRoleDef(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRoleDef(uint64(m.Type))
	}
	if m.Num != 0 {
		n += 1 + sovRoleDef(uint64(m.Num))
	}
	return n
}

func (m *SupplyAwardData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupplyAwardItems) > 0 {
		for _, e := range m.SupplyAwardItems {
			l = e.Size()
			n += 1 + l + sovRoleDef(uint64(l))
		}
	}
	if len(m.SupplyAwardMail) > 0 {
		for _, e := range m.SupplyAwardMail {
			l = e.Size()
			n += 1 + l + sovRoleDef(uint64(l))
		}
	}
	return n
}

func (m *Title) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TitleID != 0 {
		n += 1 + sovRoleDef(uint64(m.TitleID))
	}
	if len(m.TitleList) > 0 {
		for k, v := range m.TitleList {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoleDef(uint64(l))
			}
			mapEntrySize := 1 + sovRoleDef(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoleDef(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TitleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TitleID != 0 {
		n += 1 + sovRoleDef(uint64(m.TitleID))
	}
	if m.StartTime != 0 {
		n += 1 + sovRoleDef(uint64(m.StartTime))
	}
	if m.LostTime != 0 {
		n += 1 + sovRoleDef(uint64(m.LostTime))
	}
	return n
}

func sovRoleDef(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoleDef(x uint64) (n int) {
	return sovRoleDef(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Role) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &RoleBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invites == nil {
				m.Invites = make(map[string]*RoleInviteInfo)
			}
			var mapkey string
			var mapvalue *RoleInviteInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoleInviteInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Invites[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitedOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitedOnce = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialAgentList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecialAgentList == nil {
				m.SpecialAgentList = make(map[uint32]*SpecialAgent)
			}
			var mapkey uint32
			var mapvalue *SpecialAgent
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SpecialAgent{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SpecialAgentList[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildMap == nil {
				m.BuildMap = make(map[string]*BuildData)
			}
			var mapkey string
			var mapvalue *BuildData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BuildData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuildMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightingBuildID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightingBuildID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemContainerMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemContainerMap == nil {
				m.ItemContainerMap = make(map[int32]*ItemContainer)
			}
			var mapkey int32
			var mapvalue *ItemContainer
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ItemContainer{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ItemContainerMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chat == nil {
				m.Chat = &RoleChat{}
			}
			if err := m.Chat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InheritAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InheritAttr == nil {
				m.InheritAttr = &PawnInherit{}
			}
			if err := m.InheritAttr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfflineAwardDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OfflineAwardDatas == nil {
				m.OfflineAwardDatas = &OfflineAwardData{}
			}
			if err := m.OfflineAwardDatas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillsLearned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillsLearned == nil {
				m.SkillsLearned = make(map[uint32]*SkillData)
			}
			var mapkey uint32
			var mapvalue *SkillData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillsLearned[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedPointsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedPointsData == nil {
				m.RedPointsData = make(map[string]*RedPointInfo)
			}
			var mapkey string
			var mapvalue *RedPointInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RedPointInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RedPointsData[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastBattle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FastBattle == nil {
				m.FastBattle = &FastBattle{}
			}
			if err := m.FastBattle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailBox", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailBox == nil {
				m.MailBox = &MailBox{}
			}
			if err := m.MailBox.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareSpoils", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShareSpoils == nil {
				m.ShareSpoils = &ShareSpoils{}
			}
			if err := m.ShareSpoils.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Title == nil {
				m.Title = &Title{}
			}
			if err := m.Title.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupplyInfo == nil {
				m.SupplyInfo = &SupplyInfo{}
			}
			if err := m.SupplyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Friends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Friends == nil {
				m.Friends = &FriendListData{}
			}
			if err := m.Friends.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeasonInfo == nil {
				m.SeasonInfo = &RoleSeasonInfo{}
			}
			if err := m.SeasonInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogoutTime", wireType)
			}
			m.LastLogoutTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogoutTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginTime", wireType)
			}
			m.LastLoginTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLoginTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaidProgress", wireType)
			}
			m.RaidProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaidProgress |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleInviteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleInviteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleInviteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instigator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instigator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatChannels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChatChannels == nil {
				m.ChatChannels = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChatChannels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareSpoils) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareSpoils: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareSpoils: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveEquipCount", wireType)
			}
			m.GiveEquipCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiveEquipCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSkillResetTimeStamp", wireType)
			}
			m.RequestSkillResetTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSkillResetTimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSkillCount", wireType)
			}
			m.RequestSkillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSkillCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSkillCountLimit", wireType)
			}
			m.RequestSkillCountLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSkillCountLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveSkillResetTimeStamp", wireType)
			}
			m.GiveSkillResetTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiveSkillResetTimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveSkillCount", wireType)
			}
			m.GiveSkillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiveSkillCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveSkillCountLimit", wireType)
			}
			m.GiveSkillCountLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiveSkillCountLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSkillData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestSkillData == nil {
				m.RequestSkillData = make(map[string]*RequestSkill)
			}
			var mapkey string
			var mapvalue *RequestSkill
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RequestSkill{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequestSkillData[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveSkillToTargetCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GiveSkillToTargetCount == nil {
				m.GiveSkillToTargetCount = make(map[string]*GiveSkillCount)
			}
			var mapkey string
			var mapvalue *GiveSkillCount
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GiveSkillCount{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GiveSkillToTargetCount[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiveSkillCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiveSkillCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiveSkillCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiveSkillToTargetCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GiveSkillToTargetCount == nil {
				m.GiveSkillToTargetCount = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GiveSkillToTargetCount[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestMessageId", wireType)
			}
			m.RequestMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestMessageId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCreateTimeStamp", wireType)
			}
			m.RequestCreateTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestCreateTimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSkillItemId", wireType)
			}
			m.RequestSkillItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestSkillItemId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillCurLevel", wireType)
			}
			m.SkillCurLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillCurLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedSkillCount", wireType)
			}
			m.ReceivedSkillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedSkillCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillReceivedCountLimit", wireType)
			}
			m.SkillReceivedCountLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillReceivedCountLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTimeOutTimeStamp", wireType)
			}
			m.RequestTimeOutTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTimeOutTimeStamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamMateGiveSkillCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TeamMateGiveSkillCount == nil {
				m.TeamMateGiveSkillCount = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TeamMateGiveSkillCount[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FastBattle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastBattle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastBattle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StageInfo == nil {
				m.StageInfo = make(map[uint32]*FastBattleStageInfo)
			}
			var mapkey uint32
			var mapvalue *FastBattleStageInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FastBattleStageInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StageInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnergizeNum", wireType)
			}
			m.EnergizeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnergizeNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwardMulti", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AwardMulti = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FastBattleStageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastBattleStageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastBattleStageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyTimes", wireType)
			}
			m.MyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MyTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMyTimes", wireType)
			}
			m.MaxMyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMyTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherTimes", wireType)
			}
			m.OtherTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOtherTimes", wireType)
			}
			m.MaxOtherTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxOtherTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoxMold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoxMold == nil {
				m.BoxMold = make(map[uint32]*State)
			}
			var mapkey uint32
			var mapvalue *State
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &State{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BoxMold[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountNum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiscountNum == nil {
				m.DiscountNum = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DiscountNum[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldNum", wireType)
			}
			m.HoldNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenNum", wireType)
			}
			m.OpenNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyAwardItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyAwardItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyAwardItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ItemEnum_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyAwardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyAwardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyAwardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyAwardItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyAwardItems = append(m.SupplyAwardItems, &SupplyAwardItem{})
			if err := m.SupplyAwardItems[len(m.SupplyAwardItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplyAwardMail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupplyAwardMail = append(m.SupplyAwardMail, &Item{})
			if err := m.SupplyAwardMail[len(m.SupplyAwardMail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Title) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Title: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Title: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleID", wireType)
			}
			m.TitleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoleDef
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoleDef
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TitleList == nil {
				m.TitleList = make(map[uint32]*TitleInfo)
			}
			var mapkey uint32
			var mapvalue *TitleInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoleDef
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoleDef
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoleDef
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRoleDef
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TitleInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoleDef(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoleDef
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TitleList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TitleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TitleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TitleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TitleID", wireType)
			}
			m.TitleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TitleID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostTime", wireType)
			}
			m.LostTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoleDef(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRoleDef
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoleDef(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoleDef
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoleDef
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoleDef
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRoleDef
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRoleDef
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRoleDef        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoleDef          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRoleDef = fmt.Errorf("proto: unexpected end of group")
)
