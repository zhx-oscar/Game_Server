// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Buff_Config.proto

package DataTables

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BuffMain_Config struct {
	//* buffID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* Buff名称
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	//* 类型
	//1-BUFF
	//2-DEBUFF
	BuffKind uint32 `protobuf:"varint,3,opt,name=BuffKind,proto3" json:"BuffKind,omitempty"`
	//* 是否可叠加
	Overlap bool `protobuf:"varint,4,opt,name=Overlap,proto3" json:"Overlap,omitempty"`
	//* 叠加条件
	//0-同一个施法者
	//1-同队伍施法者
	OverlapCondition uint32 `protobuf:"varint,5,opt,name=OverlapCondition,proto3" json:"OverlapCondition,omitempty"`
	//* 最大叠加层数
	OverlapLimit int32 `protobuf:"varint,6,opt,name=OverlapLimit,proto3" json:"OverlapLimit,omitempty"`
	//* 叠加时是否刷新持续时间
	OverlapRefreshDuration bool `protobuf:"varint,7,opt,name=OverlapRefreshDuration,proto3" json:"OverlapRefreshDuration,omitempty"`
	//* 替换组ID
	ReplaceGroup uint32 `protobuf:"varint,8,opt,name=ReplaceGroup,proto3" json:"ReplaceGroup,omitempty"`
	//* 替换类型
	//0-新的替换旧的
	//1-高效果替换低效果
	ReplaceType uint32 `protobuf:"varint,9,opt,name=ReplaceType,proto3" json:"ReplaceType,omitempty"`
	//* 消失类型
	//0-时间到消失
	//1-死亡后消失
	//2-发动攻击后消失
	//3-受到伤害后消失
	//4-出区域后消失
	//5-永久
	DisappearType []uint32 `protobuf:"varint,10,rep,packed,name=DisappearType,proto3" json:"DisappearType,omitempty"`
	//* buff效果参数(必须要是数组形式,所以要加中括号)
	//属性叠加时，只有BRF的属性才能调整Rate，其他都是Fix
	BuffEffect string `protobuf:"bytes,11,opt,name=BuffEffect,proto3" json:"BuffEffect,omitempty"`
	//* 目标类型
	//0-单位
	//1-圆形（可先不做）
	//2-矩形（可先不做）
	TargetType uint32 `protobuf:"varint,13,opt,name=TargetType,proto3" json:"TargetType,omitempty"`
	//* 区域范围参数
	//半径、长&宽、半径&角度
	PlaceParam string `protobuf:"bytes,14,opt,name=PlaceParam,proto3" json:"PlaceParam,omitempty"`
	//* 持续时间
	//单位：ms
	Time uint32 `protobuf:"varint,15,opt,name=Time,proto3" json:"Time,omitempty"`
	//* 是否显示剩余时间
	//0-是
	//1-否
	IsTimeLeft bool `protobuf:"varint,16,opt,name=IsTimeLeft,proto3" json:"IsTimeLeft,omitempty"`
	//* 驱散组ID
	ClearGroup uint32 `protobuf:"varint,17,opt,name=ClearGroup,proto3" json:"ClearGroup,omitempty"`
	//* 组ID
	Group uint32 `protobuf:"varint,18,opt,name=Group,proto3" json:"Group,omitempty"`
	//* 免疫指定组ID效果
	ImmuneGroupID []uint32 `protobuf:"varint,19,rep,packed,name=ImmuneGroupID,proto3" json:"ImmuneGroupID,omitempty"`
	//* 死亡不删除
	DeadNoDestroy bool `protobuf:"varint,22,opt,name=DeadNoDestroy,proto3" json:"DeadNoDestroy,omitempty"`
}

func (m *BuffMain_Config) Reset()         { *m = BuffMain_Config{} }
func (m *BuffMain_Config) String() string { return proto.CompactTextString(m) }
func (*BuffMain_Config) ProtoMessage()    {}
func (*BuffMain_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_6310261a0a13b1f3, []int{0}
}
func (m *BuffMain_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuffMain_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuffMain_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuffMain_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuffMain_Config.Merge(m, src)
}
func (m *BuffMain_Config) XXX_Size() int {
	return m.Size()
}
func (m *BuffMain_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_BuffMain_Config.DiscardUnknown(m)
}

var xxx_messageInfo_BuffMain_Config proto.InternalMessageInfo

func (m *BuffMain_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *BuffMain_Config) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BuffMain_Config) GetBuffKind() uint32 {
	if m != nil {
		return m.BuffKind
	}
	return 0
}

func (m *BuffMain_Config) GetOverlap() bool {
	if m != nil {
		return m.Overlap
	}
	return false
}

func (m *BuffMain_Config) GetOverlapCondition() uint32 {
	if m != nil {
		return m.OverlapCondition
	}
	return 0
}

func (m *BuffMain_Config) GetOverlapLimit() int32 {
	if m != nil {
		return m.OverlapLimit
	}
	return 0
}

func (m *BuffMain_Config) GetOverlapRefreshDuration() bool {
	if m != nil {
		return m.OverlapRefreshDuration
	}
	return false
}

func (m *BuffMain_Config) GetReplaceGroup() uint32 {
	if m != nil {
		return m.ReplaceGroup
	}
	return 0
}

func (m *BuffMain_Config) GetReplaceType() uint32 {
	if m != nil {
		return m.ReplaceType
	}
	return 0
}

func (m *BuffMain_Config) GetDisappearType() []uint32 {
	if m != nil {
		return m.DisappearType
	}
	return nil
}

func (m *BuffMain_Config) GetBuffEffect() string {
	if m != nil {
		return m.BuffEffect
	}
	return ""
}

func (m *BuffMain_Config) GetTargetType() uint32 {
	if m != nil {
		return m.TargetType
	}
	return 0
}

func (m *BuffMain_Config) GetPlaceParam() string {
	if m != nil {
		return m.PlaceParam
	}
	return ""
}

func (m *BuffMain_Config) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *BuffMain_Config) GetIsTimeLeft() bool {
	if m != nil {
		return m.IsTimeLeft
	}
	return false
}

func (m *BuffMain_Config) GetClearGroup() uint32 {
	if m != nil {
		return m.ClearGroup
	}
	return 0
}

func (m *BuffMain_Config) GetGroup() uint32 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *BuffMain_Config) GetImmuneGroupID() []uint32 {
	if m != nil {
		return m.ImmuneGroupID
	}
	return nil
}

func (m *BuffMain_Config) GetDeadNoDestroy() bool {
	if m != nil {
		return m.DeadNoDestroy
	}
	return false
}

type Buff_Config_Data struct {
	BuffMain_ConfigItems map[uint32]*BuffMain_Config `protobuf:"bytes,1,rep,name=BuffMain_Config_items,json=BuffMainConfigItems,proto3" json:"BuffMain_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Buff_Config_Data) Reset()         { *m = Buff_Config_Data{} }
func (m *Buff_Config_Data) String() string { return proto.CompactTextString(m) }
func (*Buff_Config_Data) ProtoMessage()    {}
func (*Buff_Config_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_6310261a0a13b1f3, []int{1}
}
func (m *Buff_Config_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Buff_Config_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Buff_Config_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Buff_Config_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Buff_Config_Data.Merge(m, src)
}
func (m *Buff_Config_Data) XXX_Size() int {
	return m.Size()
}
func (m *Buff_Config_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Buff_Config_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Buff_Config_Data proto.InternalMessageInfo

func (m *Buff_Config_Data) GetBuffMain_ConfigItems() map[uint32]*BuffMain_Config {
	if m != nil {
		return m.BuffMain_ConfigItems
	}
	return nil
}

func init() {
	proto.RegisterType((*BuffMain_Config)(nil), "DataTables.BuffMain_Config")
	proto.RegisterType((*Buff_Config_Data)(nil), "DataTables.Buff_Config_Data")
	proto.RegisterMapType((map[uint32]*BuffMain_Config)(nil), "DataTables.Buff_Config_Data.BuffMainConfigItemsEntry")
}

func init() { proto.RegisterFile("Buff_Config.proto", fileDescriptor_6310261a0a13b1f3) }

var fileDescriptor_6310261a0a13b1f3 = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0x4d, 0x6f, 0xd3, 0x4c,
	0x10, 0xc7, 0xb3, 0x79, 0x69, 0xd3, 0xc9, 0x93, 0x36, 0xdd, 0x3e, 0xad, 0x56, 0x45, 0xb2, 0xac,
	0x88, 0x83, 0xc5, 0xc1, 0x88, 0x22, 0x10, 0xe2, 0xd8, 0xb8, 0x42, 0x16, 0xa5, 0x54, 0x56, 0xee,
	0xd1, 0x36, 0x19, 0x97, 0x15, 0xf1, 0x8b, 0xd6, 0x9b, 0x48, 0xf9, 0x16, 0x7c, 0x2c, 0x8e, 0x3d,
	0x72, 0x44, 0xc9, 0x67, 0xe0, 0x8e, 0x76, 0xd7, 0x25, 0x76, 0xa0, 0xb7, 0x99, 0xdf, 0x7f, 0xfe,
	0x9e, 0xdd, 0xf1, 0x2c, 0x1c, 0x5f, 0x2e, 0xe2, 0x78, 0x32, 0xca, 0xd2, 0x58, 0xdc, 0xfb, 0xb9,
	0xcc, 0x54, 0x46, 0x21, 0xe0, 0x8a, 0x8f, 0xf9, 0xdd, 0x1c, 0x8b, 0xe1, 0xaf, 0x36, 0x1c, 0xe9,
	0x8a, 0x4f, 0x5c, 0xa4, 0x65, 0x15, 0x3d, 0x84, 0x66, 0x18, 0x30, 0xe2, 0x12, 0xaf, 0x1f, 0x35,
	0xc3, 0x80, 0x52, 0x68, 0xdf, 0xf0, 0x04, 0x59, 0xd3, 0x25, 0xde, 0x41, 0x64, 0x62, 0x7a, 0x0e,
	0x5d, 0x6d, 0xfb, 0x28, 0xd2, 0x19, 0x6b, 0x99, 0xca, 0x3f, 0x39, 0x65, 0xb0, 0xff, 0x79, 0x89,
	0x72, 0xce, 0x73, 0xd6, 0x76, 0x89, 0xd7, 0x8d, 0x1e, 0x53, 0xfa, 0x02, 0x06, 0x65, 0x38, 0xca,
	0xd2, 0x99, 0x50, 0x22, 0x4b, 0x59, 0xc7, 0xb8, 0xff, 0xe2, 0x74, 0x08, 0xff, 0x95, 0xec, 0x5a,
	0x24, 0x42, 0xb1, 0x3d, 0x97, 0x78, 0x9d, 0xa8, 0xc6, 0xe8, 0x5b, 0x38, 0x2b, 0xf3, 0x08, 0x63,
	0x89, 0xc5, 0x97, 0x60, 0x21, 0xb9, 0xf9, 0xea, 0xbe, 0x69, 0xfc, 0x84, 0xaa, 0xbf, 0x1d, 0x61,
	0x3e, 0xe7, 0x53, 0xfc, 0x20, 0xb3, 0x45, 0xce, 0xba, 0xe6, 0x0c, 0x35, 0x46, 0x5d, 0xe8, 0x95,
	0xf9, 0x78, 0x95, 0x23, 0x3b, 0x30, 0x25, 0x55, 0x44, 0x9f, 0x43, 0x3f, 0x10, 0x05, 0xcf, 0x73,
	0xe4, 0xd2, 0xd4, 0x80, 0xdb, 0xf2, 0xfa, 0x51, 0x1d, 0x52, 0x07, 0x40, 0x4f, 0xe6, 0x2a, 0x8e,
	0x71, 0xaa, 0x58, 0xcf, 0xcc, 0xb0, 0x42, 0xb4, 0x3e, 0xe6, 0xf2, 0x1e, 0x95, 0xf9, 0x44, 0xdf,
	0xb4, 0xa9, 0x10, 0xad, 0xdf, 0xea, 0x96, 0xb7, 0x5c, 0xf2, 0x84, 0x1d, 0x5a, 0xff, 0x96, 0xe8,
	0xbf, 0x33, 0x16, 0x09, 0xb2, 0x23, 0xe3, 0x34, 0xb1, 0xf6, 0x84, 0x85, 0x8e, 0xae, 0x31, 0x56,
	0x6c, 0x60, 0x66, 0x51, 0x21, 0x5a, 0x1f, 0xcd, 0x91, 0x4b, 0x7b, 0xfb, 0x63, 0xdb, 0x73, 0x4b,
	0xe8, 0xff, 0xd0, 0xb1, 0x12, 0x35, 0x92, 0x4d, 0xf4, 0x7d, 0xc3, 0x24, 0x59, 0xa4, 0x76, 0x40,
	0x61, 0xc0, 0x4e, 0xec, 0x7d, 0x6b, 0xd0, 0x4c, 0x05, 0xf9, 0xec, 0x26, 0x0b, 0xb0, 0x50, 0x32,
	0x5b, 0xb1, 0x33, 0xd3, 0xbe, 0x0e, 0x87, 0x6b, 0x02, 0x83, 0xca, 0x66, 0x4e, 0xf4, 0x4a, 0x52,
	0x01, 0xa7, 0x3b, 0xbb, 0x38, 0x11, 0x0a, 0x93, 0x82, 0x11, 0xb7, 0xe5, 0xf5, 0x2e, 0xde, 0xf8,
	0xdb, 0xc5, 0xf5, 0x77, 0xcd, 0xfe, 0xa3, 0xd3, 0xb2, 0x50, 0xfb, 0xae, 0x52, 0x25, 0x57, 0xd1,
	0xc9, 0x3f, 0x94, 0xf3, 0x29, 0xb0, 0xa7, 0x0c, 0x74, 0x00, 0xad, 0xaf, 0xb8, 0x2a, 0x1f, 0x80,
	0x0e, 0xe9, 0x2b, 0xe8, 0x2c, 0xf9, 0x7c, 0x61, 0x9f, 0x40, 0xef, 0xe2, 0xd9, 0xee, 0x41, 0x2a,
	0x27, 0x8e, 0x6c, 0xe5, 0xfb, 0xe6, 0x3b, 0x72, 0xf9, 0xf2, 0xfb, 0xda, 0x21, 0x0f, 0x6b, 0x87,
	0xfc, 0x5c, 0x3b, 0xe4, 0xdb, 0xc6, 0x69, 0x3c, 0x6c, 0x9c, 0xc6, 0x8f, 0x8d, 0xd3, 0x80, 0xd3,
	0x69, 0x96, 0xf8, 0x01, 0x17, 0xc5, 0xca, 0x2f, 0x50, 0x2e, 0x51, 0xfa, 0x33, 0xae, 0xf8, 0xdd,
	0x9e, 0x79, 0xa0, 0xaf, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x6f, 0xd4, 0xdc, 0xda, 0xb5, 0x03,
	0x00, 0x00,
}

func (m *BuffMain_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffMain_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuffMain_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeadNoDestroy {
		i--
		if m.DeadNoDestroy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.ImmuneGroupID) > 0 {
		dAtA2 := make([]byte, len(m.ImmuneGroupID)*10)
		var j1 int
		for _, num := range m.ImmuneGroupID {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintBuff_Config(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Group != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ClearGroup != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.ClearGroup))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsTimeLeft {
		i--
		if m.IsTimeLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Time != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x78
	}
	if len(m.PlaceParam) > 0 {
		i -= len(m.PlaceParam)
		copy(dAtA[i:], m.PlaceParam)
		i = encodeVarintBuff_Config(dAtA, i, uint64(len(m.PlaceParam)))
		i--
		dAtA[i] = 0x72
	}
	if m.TargetType != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.TargetType))
		i--
		dAtA[i] = 0x68
	}
	if len(m.BuffEffect) > 0 {
		i -= len(m.BuffEffect)
		copy(dAtA[i:], m.BuffEffect)
		i = encodeVarintBuff_Config(dAtA, i, uint64(len(m.BuffEffect)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.DisappearType) > 0 {
		dAtA4 := make([]byte, len(m.DisappearType)*10)
		var j3 int
		for _, num := range m.DisappearType {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintBuff_Config(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x52
	}
	if m.ReplaceType != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.ReplaceType))
		i--
		dAtA[i] = 0x48
	}
	if m.ReplaceGroup != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.ReplaceGroup))
		i--
		dAtA[i] = 0x40
	}
	if m.OverlapRefreshDuration {
		i--
		if m.OverlapRefreshDuration {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.OverlapLimit != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.OverlapLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.OverlapCondition != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.OverlapCondition))
		i--
		dAtA[i] = 0x28
	}
	if m.Overlap {
		i--
		if m.Overlap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.BuffKind != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.BuffKind))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBuff_Config(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintBuff_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Buff_Config_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Buff_Config_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Buff_Config_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BuffMain_ConfigItems) > 0 {
		for k := range m.BuffMain_ConfigItems {
			v := m.BuffMain_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBuff_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintBuff_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBuff_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBuff_Config(dAtA []byte, offset int, v uint64) int {
	offset -= sovBuff_Config(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BuffMain_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBuff_Config(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBuff_Config(uint64(l))
	}
	if m.BuffKind != 0 {
		n += 1 + sovBuff_Config(uint64(m.BuffKind))
	}
	if m.Overlap {
		n += 2
	}
	if m.OverlapCondition != 0 {
		n += 1 + sovBuff_Config(uint64(m.OverlapCondition))
	}
	if m.OverlapLimit != 0 {
		n += 1 + sovBuff_Config(uint64(m.OverlapLimit))
	}
	if m.OverlapRefreshDuration {
		n += 2
	}
	if m.ReplaceGroup != 0 {
		n += 1 + sovBuff_Config(uint64(m.ReplaceGroup))
	}
	if m.ReplaceType != 0 {
		n += 1 + sovBuff_Config(uint64(m.ReplaceType))
	}
	if len(m.DisappearType) > 0 {
		l = 0
		for _, e := range m.DisappearType {
			l += sovBuff_Config(uint64(e))
		}
		n += 1 + sovBuff_Config(uint64(l)) + l
	}
	l = len(m.BuffEffect)
	if l > 0 {
		n += 1 + l + sovBuff_Config(uint64(l))
	}
	if m.TargetType != 0 {
		n += 1 + sovBuff_Config(uint64(m.TargetType))
	}
	l = len(m.PlaceParam)
	if l > 0 {
		n += 1 + l + sovBuff_Config(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovBuff_Config(uint64(m.Time))
	}
	if m.IsTimeLeft {
		n += 3
	}
	if m.ClearGroup != 0 {
		n += 2 + sovBuff_Config(uint64(m.ClearGroup))
	}
	if m.Group != 0 {
		n += 2 + sovBuff_Config(uint64(m.Group))
	}
	if len(m.ImmuneGroupID) > 0 {
		l = 0
		for _, e := range m.ImmuneGroupID {
			l += sovBuff_Config(uint64(e))
		}
		n += 2 + sovBuff_Config(uint64(l)) + l
	}
	if m.DeadNoDestroy {
		n += 3
	}
	return n
}

func (m *Buff_Config_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BuffMain_ConfigItems) > 0 {
		for k, v := range m.BuffMain_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBuff_Config(uint64(l))
			}
			mapEntrySize := 1 + sovBuff_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovBuff_Config(uint64(mapEntrySize))
		}
	}
	return n
}

func sovBuff_Config(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBuff_Config(x uint64) (n int) {
	return sovBuff_Config(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BuffMain_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuff_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffMain_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffMain_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuff_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffKind", wireType)
			}
			m.BuffKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuffKind |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overlap = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapCondition", wireType)
			}
			m.OverlapCondition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapCondition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapLimit", wireType)
			}
			m.OverlapLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapRefreshDuration", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverlapRefreshDuration = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceGroup", wireType)
			}
			m.ReplaceGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceGroup |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceType", wireType)
			}
			m.ReplaceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuff_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DisappearType = append(m.DisappearType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuff_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBuff_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBuff_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DisappearType) == 0 {
					m.DisappearType = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuff_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DisappearType = append(m.DisappearType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DisappearType", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffEffect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuff_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuffEffect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			m.TargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaceParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuff_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaceParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTimeLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTimeLeft = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearGroup", wireType)
			}
			m.ClearGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearGroup |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuff_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ImmuneGroupID = append(m.ImmuneGroupID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuff_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBuff_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBuff_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ImmuneGroupID) == 0 {
					m.ImmuneGroupID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuff_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ImmuneGroupID = append(m.ImmuneGroupID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmuneGroupID", wireType)
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadNoDestroy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeadNoDestroy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBuff_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Buff_Config_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuff_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Buff_Config_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Buff_Config_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffMain_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuff_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuffMain_ConfigItems == nil {
				m.BuffMain_ConfigItems = make(map[uint32]*BuffMain_Config)
			}
			var mapkey uint32
			var mapvalue *BuffMain_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuff_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuff_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuff_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBuff_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBuff_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BuffMain_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBuff_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBuff_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuffMain_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuff_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBuff_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBuff_Config(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBuff_Config
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuff_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBuff_Config
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBuff_Config
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBuff_Config
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBuff_Config        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBuff_Config          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBuff_Config = fmt.Errorf("proto: unexpected end of group")
)
