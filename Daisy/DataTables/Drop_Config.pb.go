// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Drop_Config.proto

package DataTables

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Drop_Config struct {
	//* 流水ID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 掉落库ID
	//1-10000=测试
	//10001-100000=关卡掉落
	//200001-n=词缀掉落
	DropBoxID uint32 `protobuf:"varint,2,opt,name=DropBoxID,proto3" json:"DropBoxID,omitempty"`
	//* 掉落条件1
	//1-特工类型
	//2-等级区间
	Condition1 uint32 `protobuf:"varint,3,opt,name=Condition1,proto3" json:"Condition1,omitempty"`
	//* 条件参数1
	Param1 string `protobuf:"bytes,4,opt,name=Param1,proto3" json:"Param1,omitempty"`
	//* 掉落条件2
	//1-特工类型
	//2-等级区间
	Condition2 uint32 `protobuf:"varint,5,opt,name=Condition2,proto3" json:"Condition2,omitempty"`
	//* 条件参数2
	Param2 string `protobuf:"bytes,6,opt,name=Param2,proto3" json:"Param2,omitempty"`
	//* 条件之间关系
	//0-与
	//1-或
	Relation bool `protobuf:"varint,7,opt,name=Relation,proto3" json:"Relation,omitempty"`
	//* 计算规则
	//1-权重掉落
	//2-独立掉落
	Rule uint32 `protobuf:"varint,8,opt,name=Rule,proto3" json:"Rule,omitempty"`
	//* 掉落类型
	//1-道具
	//2-掉落库
	Type uint32 `protobuf:"varint,9,opt,name=Type,proto3" json:"Type,omitempty"`
	//* 道具ID或掉落库ID
	Key uint32 `protobuf:"varint,10,opt,name=Key,proto3" json:"Key,omitempty"`
	//* 道具类型
	ItemType uint32 `protobuf:"varint,11,opt,name=ItemType,proto3" json:"ItemType,omitempty"`
	//* 掉落概率
	Probability uint32 `protobuf:"varint,12,opt,name=Probability,proto3" json:"Probability,omitempty"`
	//* 最小掉落数量
	MinNum uint32 `protobuf:"varint,13,opt,name=MinNum,proto3" json:"MinNum,omitempty"`
	//* 最大掉落数量
	MaxNum uint32 `protobuf:"varint,14,opt,name=MaxNum,proto3" json:"MaxNum,omitempty"`
	//* 掉落次数
	Times uint32 `protobuf:"varint,15,opt,name=Times,proto3" json:"Times,omitempty"`
	//* 公告ID
	NoticeID uint32 `protobuf:"varint,16,opt,name=NoticeID,proto3" json:"NoticeID,omitempty"`
}

func (m *Drop_Config) Reset()         { *m = Drop_Config{} }
func (m *Drop_Config) String() string { return proto.CompactTextString(m) }
func (*Drop_Config) ProtoMessage()    {}
func (*Drop_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a8eaaca3881845f, []int{0}
}
func (m *Drop_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Drop_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Drop_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Drop_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Drop_Config.Merge(m, src)
}
func (m *Drop_Config) XXX_Size() int {
	return m.Size()
}
func (m *Drop_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Drop_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Drop_Config proto.InternalMessageInfo

func (m *Drop_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Drop_Config) GetDropBoxID() uint32 {
	if m != nil {
		return m.DropBoxID
	}
	return 0
}

func (m *Drop_Config) GetCondition1() uint32 {
	if m != nil {
		return m.Condition1
	}
	return 0
}

func (m *Drop_Config) GetParam1() string {
	if m != nil {
		return m.Param1
	}
	return ""
}

func (m *Drop_Config) GetCondition2() uint32 {
	if m != nil {
		return m.Condition2
	}
	return 0
}

func (m *Drop_Config) GetParam2() string {
	if m != nil {
		return m.Param2
	}
	return ""
}

func (m *Drop_Config) GetRelation() bool {
	if m != nil {
		return m.Relation
	}
	return false
}

func (m *Drop_Config) GetRule() uint32 {
	if m != nil {
		return m.Rule
	}
	return 0
}

func (m *Drop_Config) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Drop_Config) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Drop_Config) GetItemType() uint32 {
	if m != nil {
		return m.ItemType
	}
	return 0
}

func (m *Drop_Config) GetProbability() uint32 {
	if m != nil {
		return m.Probability
	}
	return 0
}

func (m *Drop_Config) GetMinNum() uint32 {
	if m != nil {
		return m.MinNum
	}
	return 0
}

func (m *Drop_Config) GetMaxNum() uint32 {
	if m != nil {
		return m.MaxNum
	}
	return 0
}

func (m *Drop_Config) GetTimes() uint32 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *Drop_Config) GetNoticeID() uint32 {
	if m != nil {
		return m.NoticeID
	}
	return 0
}

type Drop_Config_Data struct {
	Drop_ConfigItems map[uint32]*Drop_Config `protobuf:"bytes,1,rep,name=Drop_Config_items,json=DropConfigItems,proto3" json:"Drop_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Drop_Config_Data) Reset()         { *m = Drop_Config_Data{} }
func (m *Drop_Config_Data) String() string { return proto.CompactTextString(m) }
func (*Drop_Config_Data) ProtoMessage()    {}
func (*Drop_Config_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_4a8eaaca3881845f, []int{1}
}
func (m *Drop_Config_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Drop_Config_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Drop_Config_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Drop_Config_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Drop_Config_Data.Merge(m, src)
}
func (m *Drop_Config_Data) XXX_Size() int {
	return m.Size()
}
func (m *Drop_Config_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Drop_Config_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Drop_Config_Data proto.InternalMessageInfo

func (m *Drop_Config_Data) GetDrop_ConfigItems() map[uint32]*Drop_Config {
	if m != nil {
		return m.Drop_ConfigItems
	}
	return nil
}

func init() {
	proto.RegisterType((*Drop_Config)(nil), "DataTables.Drop_Config")
	proto.RegisterType((*Drop_Config_Data)(nil), "DataTables.Drop_Config_Data")
	proto.RegisterMapType((map[uint32]*Drop_Config)(nil), "DataTables.Drop_Config_Data.DropConfigItemsEntry")
}

func init() { proto.RegisterFile("Drop_Config.proto", fileDescriptor_4a8eaaca3881845f) }

var fileDescriptor_4a8eaaca3881845f = []byte{
	// 420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0xc1, 0xae, 0xd2, 0x40,
	0x14, 0x86, 0x99, 0xf6, 0x82, 0x70, 0xea, 0xbd, 0x17, 0x27, 0x57, 0x9d, 0x10, 0xd3, 0x34, 0xac,
	0xba, 0xb1, 0x86, 0xba, 0x31, 0x2e, 0xa1, 0x2e, 0x1a, 0x23, 0x21, 0x0d, 0x3b, 0x63, 0xc8, 0x14,
	0x46, 0x33, 0xb1, 0xed, 0x90, 0x76, 0x20, 0xf4, 0x2d, 0x7c, 0x05, 0xdf, 0xc6, 0x95, 0x61, 0xe9,
	0xd2, 0xc0, 0x8b, 0x98, 0x99, 0x56, 0x28, 0x44, 0x77, 0xe7, 0xff, 0xce, 0xff, 0x0f, 0x87, 0x9e,
	0x03, 0x4f, 0x82, 0x5c, 0xac, 0x17, 0x13, 0x91, 0x7d, 0xe6, 0x5f, 0xbc, 0x75, 0x2e, 0xa4, 0xc0,
	0x10, 0x50, 0x49, 0xe7, 0x34, 0x4e, 0x58, 0x31, 0xfc, 0x6e, 0x82, 0xd5, 0x70, 0xe0, 0x3b, 0x30,
	0xc2, 0x80, 0x20, 0x07, 0xb9, 0xb7, 0x91, 0x11, 0x06, 0xf8, 0x05, 0xf4, 0x54, 0x7b, 0x2c, 0x76,
	0x61, 0x40, 0x0c, 0x8d, 0xcf, 0x00, 0xdb, 0x00, 0x13, 0x91, 0xad, 0xb8, 0xe4, 0x22, 0x1b, 0x11,
	0x53, 0xb7, 0x1b, 0x04, 0x3f, 0x83, 0xce, 0x8c, 0xe6, 0x34, 0x1d, 0x91, 0x1b, 0x07, 0xb9, 0xbd,
	0xa8, 0x56, 0x17, 0x39, 0x9f, 0xb4, 0xaf, 0x72, 0xfe, 0x29, 0xe7, 0x93, 0x4e, 0x23, 0xe7, 0xe3,
	0x01, 0x74, 0x23, 0x96, 0x50, 0x65, 0x22, 0x8f, 0x1c, 0xe4, 0x76, 0xa3, 0x93, 0xc6, 0x18, 0x6e,
	0xa2, 0x4d, 0xc2, 0x48, 0x57, 0xbf, 0xa6, 0x6b, 0xc5, 0xe6, 0xe5, 0x9a, 0x91, 0x5e, 0xc5, 0x54,
	0x8d, 0xfb, 0x60, 0xbe, 0x67, 0x25, 0x01, 0x8d, 0x54, 0xa9, 0x5e, 0x0d, 0x25, 0x4b, 0xb5, 0xd3,
	0xd2, 0xf8, 0xa4, 0xb1, 0x03, 0xd6, 0x2c, 0x17, 0x31, 0x8d, 0x79, 0xc2, 0x65, 0x49, 0x1e, 0xeb,
	0x76, 0x13, 0xa9, 0x59, 0x3f, 0xf0, 0x6c, 0xba, 0x49, 0xc9, 0xad, 0x6e, 0xd6, 0x4a, 0x73, 0xba,
	0x53, 0xfc, 0xae, 0xe6, 0x5a, 0xe1, 0x07, 0x68, 0xcf, 0x79, 0xca, 0x0a, 0x72, 0xaf, 0x71, 0x25,
	0xd4, 0x0c, 0x53, 0x21, 0xf9, 0x92, 0x85, 0x01, 0xe9, 0x57, 0x33, 0xfc, 0xd5, 0xc3, 0x9f, 0x08,
	0xfa, 0x8d, 0x1d, 0x2d, 0xd4, 0xfa, 0xf0, 0xa7, 0x8b, 0xcd, 0x2e, 0xb8, 0x64, 0x69, 0x41, 0x90,
	0x63, 0xba, 0x96, 0x3f, 0xf2, 0xce, 0x0b, 0xf6, 0xae, 0x83, 0x1a, 0x54, 0x5a, 0xfd, 0xc9, 0xe2,
	0x5d, 0x26, 0xf3, 0x32, 0xba, 0xbf, 0xa2, 0x83, 0x8f, 0xf0, 0xf0, 0x2f, 0xa3, 0xfa, 0x7a, 0x5f,
	0x59, 0x59, 0x1f, 0x88, 0x2a, 0xf1, 0x4b, 0x68, 0x6f, 0x69, 0xb2, 0x61, 0xfa, 0x3a, 0x2c, 0xff,
	0xf9, 0x7f, 0x7e, 0x3c, 0xaa, 0x5c, 0x6f, 0x8d, 0x37, 0x68, 0xfc, 0xea, 0xc7, 0xc1, 0x46, 0xfb,
	0x83, 0x8d, 0x7e, 0x1f, 0x6c, 0xf4, 0xed, 0x68, 0xb7, 0xf6, 0x47, 0xbb, 0xf5, 0xeb, 0x68, 0xb7,
	0xe0, 0xe9, 0x52, 0xa4, 0x5e, 0x40, 0x79, 0x51, 0x7a, 0x05, 0xcb, 0xb7, 0x2c, 0xf7, 0x56, 0x54,
	0xd2, 0xb8, 0xa3, 0x0f, 0xf7, 0xf5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4f, 0x28, 0xb7, 0x87,
	0xcd, 0x02, 0x00, 0x00,
}

func (m *Drop_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Drop_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Drop_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoticeID != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.NoticeID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Times != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x78
	}
	if m.MaxNum != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.MaxNum))
		i--
		dAtA[i] = 0x70
	}
	if m.MinNum != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.MinNum))
		i--
		dAtA[i] = 0x68
	}
	if m.Probability != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Probability))
		i--
		dAtA[i] = 0x60
	}
	if m.ItemType != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.ItemType))
		i--
		dAtA[i] = 0x58
	}
	if m.Key != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x50
	}
	if m.Type != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x48
	}
	if m.Rule != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Rule))
		i--
		dAtA[i] = 0x40
	}
	if m.Relation {
		i--
		if m.Relation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Param2) > 0 {
		i -= len(m.Param2)
		copy(dAtA[i:], m.Param2)
		i = encodeVarintDrop_Config(dAtA, i, uint64(len(m.Param2)))
		i--
		dAtA[i] = 0x32
	}
	if m.Condition2 != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Condition2))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Param1) > 0 {
		i -= len(m.Param1)
		copy(dAtA[i:], m.Param1)
		i = encodeVarintDrop_Config(dAtA, i, uint64(len(m.Param1)))
		i--
		dAtA[i] = 0x22
	}
	if m.Condition1 != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.Condition1))
		i--
		dAtA[i] = 0x18
	}
	if m.DropBoxID != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.DropBoxID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintDrop_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Drop_Config_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Drop_Config_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Drop_Config_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Drop_ConfigItems) > 0 {
		for k := range m.Drop_ConfigItems {
			v := m.Drop_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintDrop_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintDrop_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintDrop_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDrop_Config(dAtA []byte, offset int, v uint64) int {
	offset -= sovDrop_Config(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Drop_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovDrop_Config(uint64(m.ID))
	}
	if m.DropBoxID != 0 {
		n += 1 + sovDrop_Config(uint64(m.DropBoxID))
	}
	if m.Condition1 != 0 {
		n += 1 + sovDrop_Config(uint64(m.Condition1))
	}
	l = len(m.Param1)
	if l > 0 {
		n += 1 + l + sovDrop_Config(uint64(l))
	}
	if m.Condition2 != 0 {
		n += 1 + sovDrop_Config(uint64(m.Condition2))
	}
	l = len(m.Param2)
	if l > 0 {
		n += 1 + l + sovDrop_Config(uint64(l))
	}
	if m.Relation {
		n += 2
	}
	if m.Rule != 0 {
		n += 1 + sovDrop_Config(uint64(m.Rule))
	}
	if m.Type != 0 {
		n += 1 + sovDrop_Config(uint64(m.Type))
	}
	if m.Key != 0 {
		n += 1 + sovDrop_Config(uint64(m.Key))
	}
	if m.ItemType != 0 {
		n += 1 + sovDrop_Config(uint64(m.ItemType))
	}
	if m.Probability != 0 {
		n += 1 + sovDrop_Config(uint64(m.Probability))
	}
	if m.MinNum != 0 {
		n += 1 + sovDrop_Config(uint64(m.MinNum))
	}
	if m.MaxNum != 0 {
		n += 1 + sovDrop_Config(uint64(m.MaxNum))
	}
	if m.Times != 0 {
		n += 1 + sovDrop_Config(uint64(m.Times))
	}
	if m.NoticeID != 0 {
		n += 2 + sovDrop_Config(uint64(m.NoticeID))
	}
	return n
}

func (m *Drop_Config_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Drop_ConfigItems) > 0 {
		for k, v := range m.Drop_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDrop_Config(uint64(l))
			}
			mapEntrySize := 1 + sovDrop_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovDrop_Config(uint64(mapEntrySize))
		}
	}
	return n
}

func sovDrop_Config(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDrop_Config(x uint64) (n int) {
	return sovDrop_Config(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Drop_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrop_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Drop_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Drop_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropBoxID", wireType)
			}
			m.DropBoxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DropBoxID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition1", wireType)
			}
			m.Condition1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Condition1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrop_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition2", wireType)
			}
			m.Condition2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Condition2 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDrop_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Relation = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			m.Rule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rule |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemType", wireType)
			}
			m.ItemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Probability", wireType)
			}
			m.Probability = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Probability |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinNum", wireType)
			}
			m.MinNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			m.MaxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoticeID", wireType)
			}
			m.NoticeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoticeID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDrop_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Drop_Config_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDrop_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Drop_Config_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Drop_Config_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDrop_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Drop_ConfigItems == nil {
				m.Drop_ConfigItems = make(map[uint32]*Drop_Config)
			}
			var mapkey uint32
			var mapvalue *Drop_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDrop_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrop_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDrop_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDrop_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDrop_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Drop_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDrop_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDrop_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Drop_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDrop_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDrop_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDrop_Config(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDrop_Config
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDrop_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDrop_Config
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDrop_Config
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDrop_Config
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDrop_Config        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDrop_Config          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDrop_Config = fmt.Errorf("proto: unexpected end of group")
)
