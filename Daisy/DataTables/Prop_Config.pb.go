// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Prop_Config.proto

package DataTables

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PropValue_Config struct {
	//* ID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 类型
	//0-无
	//1-力量
	//2-敏捷
	//3-念力
	Type uint32 `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	//* 力量
	//[0,+∞]
	//BRF
	//整数
	Strength float64 `protobuf:"fixed64,3,opt,name=Strength,proto3" json:"Strength,omitempty"`
	//* 敏捷
	//[0,+∞]
	//BRF
	//整数
	Agility float64 `protobuf:"fixed64,4,opt,name=Agility,proto3" json:"Agility,omitempty"`
	//* 智力
	//[0,+∞]
	//BRF
	//整数
	Intelligence float64 `protobuf:"fixed64,5,opt,name=Intelligence,proto3" json:"Intelligence,omitempty"`
	//* 体力
	//[0,+∞]
	//BRF
	//整数
	Vitality float64 `protobuf:"fixed64,6,opt,name=Vitality,proto3" json:"Vitality,omitempty"`
	//* 最大生命
	//[1,+∞]
	//BRF
	//整数
	MaxHP int64 `protobuf:"varint,7,opt,name=MaxHP,proto3" json:"MaxHP,omitempty"`
	//* 必杀技能量上限
	//[0,+∞]
	//BRF
	//整数
	SkillPowerLimit int32 `protobuf:"varint,8,opt,name=SkillPowerLimit,proto3" json:"SkillPowerLimit,omitempty"`
	//* 攻击
	//[0,+∞]
	//BRF
	//整数
	Attack float64 `protobuf:"fixed64,9,opt,name=Attack,proto3" json:"Attack,omitempty"`
	//* 物理伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackNoramlAdd float64 `protobuf:"fixed64,10,opt,name=AttackNoramlAdd,proto3" json:"AttackNoramlAdd,omitempty"`
	//* 物理伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	AttackNoramlDecr float64 `protobuf:"fixed64,11,opt,name=AttackNoramlDecr,proto3" json:"AttackNoramlDecr,omitempty"`
	//* 火焰伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackFireAdd float64 `protobuf:"fixed64,12,opt,name=AttackFireAdd,proto3" json:"AttackFireAdd,omitempty"`
	//* 火焰伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	AttackFireDecr float64 `protobuf:"fixed64,13,opt,name=AttackFireDecr,proto3" json:"AttackFireDecr,omitempty"`
	//* 冰霜伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackColdAdd float64 `protobuf:"fixed64,14,opt,name=AttackColdAdd,proto3" json:"AttackColdAdd,omitempty"`
	//* 冰霜伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	AttackColdDecr float64 `protobuf:"fixed64,15,opt,name=AttackColdDecr,proto3" json:"AttackColdDecr,omitempty"`
	//* 毒素伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackPoisonAdd float64 `protobuf:"fixed64,16,opt,name=AttackPoisonAdd,proto3" json:"AttackPoisonAdd,omitempty"`
	//* 毒素伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	AttackPoisonDecr float64 `protobuf:"fixed64,17,opt,name=AttackPoisonDecr,proto3" json:"AttackPoisonDecr,omitempty"`
	//* 闪电伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackLightningAdd float64 `protobuf:"fixed64,18,opt,name=AttackLightningAdd,proto3" json:"AttackLightningAdd,omitempty"`
	//* 闪电伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	AttackLightningDecr float64 `protobuf:"fixed64,19,opt,name=AttackLightningDecr,proto3" json:"AttackLightningDecr,omitempty"`
	//* 命中率
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	HitRate float32 `protobuf:"fixed32,20,opt,name=HitRate,proto3" json:"HitRate,omitempty"`
	//* 闪避率
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	DodgeRate float32 `protobuf:"fixed32,21,opt,name=DodgeRate,proto3" json:"DodgeRate,omitempty"`
	//* 暴击率
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	CritRate float32 `protobuf:"fixed32,22,opt,name=CritRate,proto3" json:"CritRate,omitempty"`
	//* 格挡率
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	BlockRate float32 `protobuf:"fixed32,23,opt,name=BlockRate,proto3" json:"BlockRate,omitempty"`
	//* 格挡伤害定值
	//[0,+∞]
	//最高生效
	//整数
	BlockValue float64 `protobuf:"fixed64,24,opt,name=BlockValue,proto3" json:"BlockValue,omitempty"`
	//* 暴击增伤比例
	//[1,+∞]
	//加法叠加
	//小数点后4位
	CritDamageRate float32 `protobuf:"fixed32,25,opt,name=CritDamageRate,proto3" json:"CritDamageRate,omitempty"`
	//* 护甲
	//[0,+∞]
	//BRF
	//整数
	Armor float64 `protobuf:"fixed64,26,opt,name=Armor,proto3" json:"Armor,omitempty"`
	//* 火焰抗性
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	ResistanceFire float32 `protobuf:"fixed32,27,opt,name=ResistanceFire,proto3" json:"ResistanceFire,omitempty"`
	//* 冰霜抗性
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	ResistanceCold float32 `protobuf:"fixed32,28,opt,name=ResistanceCold,proto3" json:"ResistanceCold,omitempty"`
	//* 毒素抗性
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	ResistancePoison float32 `protobuf:"fixed32,29,opt,name=ResistancePoison,proto3" json:"ResistancePoison,omitempty"`
	//* 闪电抗性
	//[0,1]
	//反向乘法叠加
	//小数点后4位
	ResistanceLightning float32 `protobuf:"fixed32,30,opt,name=ResistanceLightning,proto3" json:"ResistanceLightning,omitempty"`
	//* 受物理伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	BeDamageNormalAdd float64 `protobuf:"fixed64,31,opt,name=BeDamageNormalAdd,proto3" json:"BeDamageNormalAdd,omitempty"`
	//* 受物理伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	BeDamageNormalDecr float64 `protobuf:"fixed64,32,opt,name=BeDamageNormalDecr,proto3" json:"BeDamageNormalDecr,omitempty"`
	//* 受火焰伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	BeDamageFireAdd float64 `protobuf:"fixed64,33,opt,name=BeDamageFireAdd,proto3" json:"BeDamageFireAdd,omitempty"`
	//* 受火焰伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	BeDamageFireDecr float64 `protobuf:"fixed64,34,opt,name=BeDamageFireDecr,proto3" json:"BeDamageFireDecr,omitempty"`
	//* 受冰霜伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	BeDamageColdAdd float64 `protobuf:"fixed64,35,opt,name=BeDamageColdAdd,proto3" json:"BeDamageColdAdd,omitempty"`
	//* 受冰霜伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	BeDamageColdDecr float64 `protobuf:"fixed64,36,opt,name=BeDamageColdDecr,proto3" json:"BeDamageColdDecr,omitempty"`
	//* 受毒素伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	BeDamagePoisonAdd float64 `protobuf:"fixed64,37,opt,name=BeDamagePoisonAdd,proto3" json:"BeDamagePoisonAdd,omitempty"`
	//* 受毒素伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	BeDamagePoisonDecr float64 `protobuf:"fixed64,38,opt,name=BeDamagePoisonDecr,proto3" json:"BeDamagePoisonDecr,omitempty"`
	//* 受闪电伤害加深
	//[0,+∞]
	//加法叠加
	//小数点后4位
	BeDamageLightningAdd float64 `protobuf:"fixed64,39,opt,name=BeDamageLightningAdd,proto3" json:"BeDamageLightningAdd,omitempty"`
	//* 受闪电伤害降低
	//[-∞,0]
	//加法叠加
	//小数点后4位
	BeDamageLightningDecr float64 `protobuf:"fixed64,40,opt,name=BeDamageLightningDecr,proto3" json:"BeDamageLightningDecr,omitempty"`
	//* 幸运值
	//[0,+∞]
	//BRF
	//整数
	Lucky uint32 `protobuf:"varint,41,opt,name=Lucky,proto3" json:"Lucky,omitempty"`
	//* 普攻速度
	//[0.1,2]
	//反向乘法叠加
	//小数点后2位
	NormalAttackSpeed float32 `protobuf:"fixed32,42,opt,name=NormalAttackSpeed,proto3" json:"NormalAttackSpeed,omitempty"`
	//* 攻击幸运值
	//[0,1]
	//加法叠加
	//小数点后4位
	AttackLucky float32 `protobuf:"fixed32,43,opt,name=AttackLucky,proto3" json:"AttackLucky,omitempty"`
	//* 吸血比例
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackBloodsuckerRate float32 `protobuf:"fixed32,44,opt,name=AttackBloodsuckerRate,proto3" json:"AttackBloodsuckerRate,omitempty"`
	//* 分裂伤害比例
	//[0,+∞]
	//加法叠加
	//小数点后4位
	AttackSputteringRate float32 `protobuf:"fixed32,45,opt,name=AttackSputteringRate,proto3" json:"AttackSputteringRate,omitempty"`
	//* 必杀技能量偷取值
	//[0,+∞]
	//BRF
	//整数
	AttackStealUltimateSkillPower int32 `protobuf:"varint,46,opt,name=AttackStealUltimateSkillPower,proto3" json:"AttackStealUltimateSkillPower,omitempty"`
	//* 物理伤害抵挡
	//[0,+∞]
	//BRF
	//整数
	BeDamageNormalDeduct float64 `protobuf:"fixed64,47,opt,name=BeDamageNormalDeduct,proto3" json:"BeDamageNormalDeduct,omitempty"`
	//* 反弹伤害值
	//[0,+∞]
	//BRF
	//整数
	BeDamageThorns float64 `protobuf:"fixed64,48,opt,name=BeDamageThorns,proto3" json:"BeDamageThorns,omitempty"`
	//* 每秒HP恢复
	//[0,+∞]
	//BRF
	//整数
	RecoverHP int64 `protobuf:"varint,49,opt,name=RecoverHP,proto3" json:"RecoverHP,omitempty"`
	//* 每秒必杀技能量恢复比例
	//[0,1]
	//加法叠加
	//小数点后4位
	RecoverUltimateSkillPowerRate float32 `protobuf:"fixed32,50,opt,name=RecoverUltimateSkillPowerRate,proto3" json:"RecoverUltimateSkillPowerRate,omitempty"`
	//* 离子护盾生命
	//[0,+∞]
	//BRF
	//整数
	PowerShieldHP int64 `protobuf:"varint,51,opt,name=PowerShieldHP,proto3" json:"PowerShieldHP,omitempty"`
	//* 离子护盾恢复速度(每秒恢复最大护盾值的比例)
	//[0,1]
	//加法叠加
	//小数点后4位
	PowerShieldRecoverSpeed float32 `protobuf:"fixed32,52,opt,name=PowerShieldRecoverSpeed,proto3" json:"PowerShieldRecoverSpeed,omitempty"`
	//* 最高元素伤害附加值
	//[0,+∞]
	//BRF
	//整数
	TopAttackElementPlus float64 `protobuf:"fixed64,53,opt,name=TopAttackElementPlus,proto3" json:"TopAttackElementPlus,omitempty"`
	//* 超载上限值
	//[0,+∞]
	//BRF
	//整数
	OverDriveLimit int32 `protobuf:"varint,54,opt,name=OverDriveLimit,proto3" json:"OverDriveLimit,omitempty"`
	//* 损失1%生命增加的超载值
	//[0,+∞]
	//BRF
	//整数
	OverDriveAddEfficiency int32 `protobuf:"varint,55,opt,name=OverDriveAddEfficiency,proto3" json:"OverDriveAddEfficiency,omitempty"`
	//* 超载持续时间：ms
	//[0,+∞]
	//BRF
	//整数
	OverDriveTime uint32 `protobuf:"varint,56,opt,name=OverDriveTime,proto3" json:"OverDriveTime,omitempty"`
	//* 虚弱持续时间：ms
	//[0,+∞]
	//BRF
	//整数
	WeakTime uint32 `protobuf:"varint,57,opt,name=WeakTime,proto3" json:"WeakTime,omitempty"`
	//* 受击崩溃值
	//[0,+∞]
	//BRF
	//整数
	BreakValueLimit int32 `protobuf:"varint,58,opt,name=BreakValueLimit,proto3" json:"BreakValueLimit,omitempty"`
	//* 受击失衡状态持续时间ms
	//[0,+∞]
	//BRF
	//整数
	BreakStateTime uint32 `protobuf:"varint,59,opt,name=BreakStateTime,proto3" json:"BreakStateTime,omitempty"`
	//* 武器最小攻击
	//[0,+∞]
	//BRF
	//整数
	EquipMinAttack float64 `protobuf:"fixed64,60,opt,name=EquipMinAttack,proto3" json:"EquipMinAttack,omitempty"`
	//* 武器最大攻击
	//[0,+∞]
	//BRF
	//整数
	EquipMaxAttack float64 `protobuf:"fixed64,61,opt,name=EquipMaxAttack,proto3" json:"EquipMaxAttack,omitempty"`
	//* 武器攻击百分比
	//[0,+∞]
	//BRF
	//小数点后4位
	EquipAttackRate float64 `protobuf:"fixed64,62,opt,name=EquipAttackRate,proto3" json:"EquipAttackRate,omitempty"`
	//* 武器附加物理攻击力
	//[0,+∞]
	//BRF
	//整数
	EquipAttackNormalPlus float64 `protobuf:"fixed64,63,opt,name=EquipAttackNormalPlus,proto3" json:"EquipAttackNormalPlus,omitempty"`
	//* 武器附加火焰攻击力
	//[0,+∞]
	//BRF
	//整数
	EquipAttackFirePlus float64 `protobuf:"fixed64,64,opt,name=EquipAttackFirePlus,proto3" json:"EquipAttackFirePlus,omitempty"`
	//* 武器附加冰霜攻击力
	//[0,+∞]
	//BRF
	//整数
	EquipAttackColdPlus float64 `protobuf:"fixed64,65,opt,name=EquipAttackColdPlus,proto3" json:"EquipAttackColdPlus,omitempty"`
	//* 武器附加毒素攻击力
	//[0,+∞]
	//BRF
	//整数
	EquipAttackPoisonPlus float64 `protobuf:"fixed64,66,opt,name=EquipAttackPoisonPlus,proto3" json:"EquipAttackPoisonPlus,omitempty"`
	//* 武器附加闪电攻击力
	//[0,+∞]
	//BRF
	//整数
	EquipAttackLightningPlus float64 `protobuf:"fixed64,67,opt,name=EquipAttackLightningPlus,proto3" json:"EquipAttackLightningPlus,omitempty"`
	//* 额外附加物理攻击力
	//[0,+∞]
	//BRF
	//整数
	AttackNormalPlus float64 `protobuf:"fixed64,68,opt,name=AttackNormalPlus,proto3" json:"AttackNormalPlus,omitempty"`
	//* 额外附加火焰攻击力
	//[0,+∞]
	//BRF
	//整数
	AttackFirePlus float64 `protobuf:"fixed64,69,opt,name=AttackFirePlus,proto3" json:"AttackFirePlus,omitempty"`
	//* 额外附加冰霜攻击力
	//[0,+∞]
	//BRF
	//整数
	AttackColdPlus float64 `protobuf:"fixed64,70,opt,name=AttackColdPlus,proto3" json:"AttackColdPlus,omitempty"`
	//* 额外附加毒素攻击力
	//[0,+∞]
	//BRF
	//整数
	AttackPoisonPlus float64 `protobuf:"fixed64,71,opt,name=AttackPoisonPlus,proto3" json:"AttackPoisonPlus,omitempty"`
	//* 额外附加闪电攻击力
	//[0,+∞]
	//BRF
	//整数
	AttackLightningPlus float64 `protobuf:"fixed64,72,opt,name=AttackLightningPlus,proto3" json:"AttackLightningPlus,omitempty"`
}

func (m *PropValue_Config) Reset()         { *m = PropValue_Config{} }
func (m *PropValue_Config) String() string { return proto.CompactTextString(m) }
func (*PropValue_Config) ProtoMessage()    {}
func (*PropValue_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd17248065ac144d, []int{0}
}
func (m *PropValue_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropValue_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropValue_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropValue_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropValue_Config.Merge(m, src)
}
func (m *PropValue_Config) XXX_Size() int {
	return m.Size()
}
func (m *PropValue_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_PropValue_Config.DiscardUnknown(m)
}

var xxx_messageInfo_PropValue_Config proto.InternalMessageInfo

func (m *PropValue_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PropValue_Config) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *PropValue_Config) GetStrength() float64 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *PropValue_Config) GetAgility() float64 {
	if m != nil {
		return m.Agility
	}
	return 0
}

func (m *PropValue_Config) GetIntelligence() float64 {
	if m != nil {
		return m.Intelligence
	}
	return 0
}

func (m *PropValue_Config) GetVitality() float64 {
	if m != nil {
		return m.Vitality
	}
	return 0
}

func (m *PropValue_Config) GetMaxHP() int64 {
	if m != nil {
		return m.MaxHP
	}
	return 0
}

func (m *PropValue_Config) GetSkillPowerLimit() int32 {
	if m != nil {
		return m.SkillPowerLimit
	}
	return 0
}

func (m *PropValue_Config) GetAttack() float64 {
	if m != nil {
		return m.Attack
	}
	return 0
}

func (m *PropValue_Config) GetAttackNoramlAdd() float64 {
	if m != nil {
		return m.AttackNoramlAdd
	}
	return 0
}

func (m *PropValue_Config) GetAttackNoramlDecr() float64 {
	if m != nil {
		return m.AttackNoramlDecr
	}
	return 0
}

func (m *PropValue_Config) GetAttackFireAdd() float64 {
	if m != nil {
		return m.AttackFireAdd
	}
	return 0
}

func (m *PropValue_Config) GetAttackFireDecr() float64 {
	if m != nil {
		return m.AttackFireDecr
	}
	return 0
}

func (m *PropValue_Config) GetAttackColdAdd() float64 {
	if m != nil {
		return m.AttackColdAdd
	}
	return 0
}

func (m *PropValue_Config) GetAttackColdDecr() float64 {
	if m != nil {
		return m.AttackColdDecr
	}
	return 0
}

func (m *PropValue_Config) GetAttackPoisonAdd() float64 {
	if m != nil {
		return m.AttackPoisonAdd
	}
	return 0
}

func (m *PropValue_Config) GetAttackPoisonDecr() float64 {
	if m != nil {
		return m.AttackPoisonDecr
	}
	return 0
}

func (m *PropValue_Config) GetAttackLightningAdd() float64 {
	if m != nil {
		return m.AttackLightningAdd
	}
	return 0
}

func (m *PropValue_Config) GetAttackLightningDecr() float64 {
	if m != nil {
		return m.AttackLightningDecr
	}
	return 0
}

func (m *PropValue_Config) GetHitRate() float32 {
	if m != nil {
		return m.HitRate
	}
	return 0
}

func (m *PropValue_Config) GetDodgeRate() float32 {
	if m != nil {
		return m.DodgeRate
	}
	return 0
}

func (m *PropValue_Config) GetCritRate() float32 {
	if m != nil {
		return m.CritRate
	}
	return 0
}

func (m *PropValue_Config) GetBlockRate() float32 {
	if m != nil {
		return m.BlockRate
	}
	return 0
}

func (m *PropValue_Config) GetBlockValue() float64 {
	if m != nil {
		return m.BlockValue
	}
	return 0
}

func (m *PropValue_Config) GetCritDamageRate() float32 {
	if m != nil {
		return m.CritDamageRate
	}
	return 0
}

func (m *PropValue_Config) GetArmor() float64 {
	if m != nil {
		return m.Armor
	}
	return 0
}

func (m *PropValue_Config) GetResistanceFire() float32 {
	if m != nil {
		return m.ResistanceFire
	}
	return 0
}

func (m *PropValue_Config) GetResistanceCold() float32 {
	if m != nil {
		return m.ResistanceCold
	}
	return 0
}

func (m *PropValue_Config) GetResistancePoison() float32 {
	if m != nil {
		return m.ResistancePoison
	}
	return 0
}

func (m *PropValue_Config) GetResistanceLightning() float32 {
	if m != nil {
		return m.ResistanceLightning
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageNormalAdd() float64 {
	if m != nil {
		return m.BeDamageNormalAdd
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageNormalDecr() float64 {
	if m != nil {
		return m.BeDamageNormalDecr
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageFireAdd() float64 {
	if m != nil {
		return m.BeDamageFireAdd
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageFireDecr() float64 {
	if m != nil {
		return m.BeDamageFireDecr
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageColdAdd() float64 {
	if m != nil {
		return m.BeDamageColdAdd
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageColdDecr() float64 {
	if m != nil {
		return m.BeDamageColdDecr
	}
	return 0
}

func (m *PropValue_Config) GetBeDamagePoisonAdd() float64 {
	if m != nil {
		return m.BeDamagePoisonAdd
	}
	return 0
}

func (m *PropValue_Config) GetBeDamagePoisonDecr() float64 {
	if m != nil {
		return m.BeDamagePoisonDecr
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageLightningAdd() float64 {
	if m != nil {
		return m.BeDamageLightningAdd
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageLightningDecr() float64 {
	if m != nil {
		return m.BeDamageLightningDecr
	}
	return 0
}

func (m *PropValue_Config) GetLucky() uint32 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func (m *PropValue_Config) GetNormalAttackSpeed() float32 {
	if m != nil {
		return m.NormalAttackSpeed
	}
	return 0
}

func (m *PropValue_Config) GetAttackLucky() float32 {
	if m != nil {
		return m.AttackLucky
	}
	return 0
}

func (m *PropValue_Config) GetAttackBloodsuckerRate() float32 {
	if m != nil {
		return m.AttackBloodsuckerRate
	}
	return 0
}

func (m *PropValue_Config) GetAttackSputteringRate() float32 {
	if m != nil {
		return m.AttackSputteringRate
	}
	return 0
}

func (m *PropValue_Config) GetAttackStealUltimateSkillPower() int32 {
	if m != nil {
		return m.AttackStealUltimateSkillPower
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageNormalDeduct() float64 {
	if m != nil {
		return m.BeDamageNormalDeduct
	}
	return 0
}

func (m *PropValue_Config) GetBeDamageThorns() float64 {
	if m != nil {
		return m.BeDamageThorns
	}
	return 0
}

func (m *PropValue_Config) GetRecoverHP() int64 {
	if m != nil {
		return m.RecoverHP
	}
	return 0
}

func (m *PropValue_Config) GetRecoverUltimateSkillPowerRate() float32 {
	if m != nil {
		return m.RecoverUltimateSkillPowerRate
	}
	return 0
}

func (m *PropValue_Config) GetPowerShieldHP() int64 {
	if m != nil {
		return m.PowerShieldHP
	}
	return 0
}

func (m *PropValue_Config) GetPowerShieldRecoverSpeed() float32 {
	if m != nil {
		return m.PowerShieldRecoverSpeed
	}
	return 0
}

func (m *PropValue_Config) GetTopAttackElementPlus() float64 {
	if m != nil {
		return m.TopAttackElementPlus
	}
	return 0
}

func (m *PropValue_Config) GetOverDriveLimit() int32 {
	if m != nil {
		return m.OverDriveLimit
	}
	return 0
}

func (m *PropValue_Config) GetOverDriveAddEfficiency() int32 {
	if m != nil {
		return m.OverDriveAddEfficiency
	}
	return 0
}

func (m *PropValue_Config) GetOverDriveTime() uint32 {
	if m != nil {
		return m.OverDriveTime
	}
	return 0
}

func (m *PropValue_Config) GetWeakTime() uint32 {
	if m != nil {
		return m.WeakTime
	}
	return 0
}

func (m *PropValue_Config) GetBreakValueLimit() int32 {
	if m != nil {
		return m.BreakValueLimit
	}
	return 0
}

func (m *PropValue_Config) GetBreakStateTime() uint32 {
	if m != nil {
		return m.BreakStateTime
	}
	return 0
}

func (m *PropValue_Config) GetEquipMinAttack() float64 {
	if m != nil {
		return m.EquipMinAttack
	}
	return 0
}

func (m *PropValue_Config) GetEquipMaxAttack() float64 {
	if m != nil {
		return m.EquipMaxAttack
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackRate() float64 {
	if m != nil {
		return m.EquipAttackRate
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackNormalPlus() float64 {
	if m != nil {
		return m.EquipAttackNormalPlus
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackFirePlus() float64 {
	if m != nil {
		return m.EquipAttackFirePlus
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackColdPlus() float64 {
	if m != nil {
		return m.EquipAttackColdPlus
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackPoisonPlus() float64 {
	if m != nil {
		return m.EquipAttackPoisonPlus
	}
	return 0
}

func (m *PropValue_Config) GetEquipAttackLightningPlus() float64 {
	if m != nil {
		return m.EquipAttackLightningPlus
	}
	return 0
}

func (m *PropValue_Config) GetAttackNormalPlus() float64 {
	if m != nil {
		return m.AttackNormalPlus
	}
	return 0
}

func (m *PropValue_Config) GetAttackFirePlus() float64 {
	if m != nil {
		return m.AttackFirePlus
	}
	return 0
}

func (m *PropValue_Config) GetAttackColdPlus() float64 {
	if m != nil {
		return m.AttackColdPlus
	}
	return 0
}

func (m *PropValue_Config) GetAttackPoisonPlus() float64 {
	if m != nil {
		return m.AttackPoisonPlus
	}
	return 0
}

func (m *PropValue_Config) GetAttackLightningPlus() float64 {
	if m != nil {
		return m.AttackLightningPlus
	}
	return 0
}

type JobPropLimit_Config struct {
}

func (m *JobPropLimit_Config) Reset()         { *m = JobPropLimit_Config{} }
func (m *JobPropLimit_Config) String() string { return proto.CompactTextString(m) }
func (*JobPropLimit_Config) ProtoMessage()    {}
func (*JobPropLimit_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd17248065ac144d, []int{1}
}
func (m *JobPropLimit_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobPropLimit_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobPropLimit_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobPropLimit_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobPropLimit_Config.Merge(m, src)
}
func (m *JobPropLimit_Config) XXX_Size() int {
	return m.Size()
}
func (m *JobPropLimit_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_JobPropLimit_Config.DiscardUnknown(m)
}

var xxx_messageInfo_JobPropLimit_Config proto.InternalMessageInfo

type PropIntro_Config struct {
}

func (m *PropIntro_Config) Reset()         { *m = PropIntro_Config{} }
func (m *PropIntro_Config) String() string { return proto.CompactTextString(m) }
func (*PropIntro_Config) ProtoMessage()    {}
func (*PropIntro_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd17248065ac144d, []int{2}
}
func (m *PropIntro_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropIntro_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropIntro_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropIntro_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropIntro_Config.Merge(m, src)
}
func (m *PropIntro_Config) XXX_Size() int {
	return m.Size()
}
func (m *PropIntro_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_PropIntro_Config.DiscardUnknown(m)
}

var xxx_messageInfo_PropIntro_Config proto.InternalMessageInfo

type Prop_Config_Data struct {
	PropValue_ConfigItems    map[uint32]*PropValue_Config    `protobuf:"bytes,1,rep,name=PropValue_Config_items,json=PropValueConfigItems,proto3" json:"PropValue_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	JobPropLimit_ConfigItems map[uint32]*JobPropLimit_Config `protobuf:"bytes,2,rep,name=JobPropLimit_Config_items,json=JobPropLimitConfigItems,proto3" json:"JobPropLimit_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PropIntro_ConfigItems    map[uint32]*PropIntro_Config    `protobuf:"bytes,3,rep,name=PropIntro_Config_items,json=PropIntroConfigItems,proto3" json:"PropIntro_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Prop_Config_Data) Reset()         { *m = Prop_Config_Data{} }
func (m *Prop_Config_Data) String() string { return proto.CompactTextString(m) }
func (*Prop_Config_Data) ProtoMessage()    {}
func (*Prop_Config_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd17248065ac144d, []int{3}
}
func (m *Prop_Config_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prop_Config_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prop_Config_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prop_Config_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prop_Config_Data.Merge(m, src)
}
func (m *Prop_Config_Data) XXX_Size() int {
	return m.Size()
}
func (m *Prop_Config_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Prop_Config_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Prop_Config_Data proto.InternalMessageInfo

func (m *Prop_Config_Data) GetPropValue_ConfigItems() map[uint32]*PropValue_Config {
	if m != nil {
		return m.PropValue_ConfigItems
	}
	return nil
}

func (m *Prop_Config_Data) GetJobPropLimit_ConfigItems() map[uint32]*JobPropLimit_Config {
	if m != nil {
		return m.JobPropLimit_ConfigItems
	}
	return nil
}

func (m *Prop_Config_Data) GetPropIntro_ConfigItems() map[uint32]*PropIntro_Config {
	if m != nil {
		return m.PropIntro_ConfigItems
	}
	return nil
}

func init() {
	proto.RegisterType((*PropValue_Config)(nil), "DataTables.PropValue_Config")
	proto.RegisterType((*JobPropLimit_Config)(nil), "DataTables.JobPropLimit_Config")
	proto.RegisterType((*PropIntro_Config)(nil), "DataTables.PropIntro_Config")
	proto.RegisterType((*Prop_Config_Data)(nil), "DataTables.Prop_Config_Data")
	proto.RegisterMapType((map[uint32]*JobPropLimit_Config)(nil), "DataTables.Prop_Config_Data.JobPropLimitConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*PropIntro_Config)(nil), "DataTables.Prop_Config_Data.PropIntroConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*PropValue_Config)(nil), "DataTables.Prop_Config_Data.PropValueConfigItemsEntry")
}

func init() { proto.RegisterFile("Prop_Config.proto", fileDescriptor_bd17248065ac144d) }

var fileDescriptor_bd17248065ac144d = []byte{
	// 1277 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xeb, 0x56, 0x1b, 0x37,
	0x10, 0xce, 0x9a, 0x90, 0x8b, 0x08, 0x04, 0xc4, 0x4d, 0x50, 0xe2, 0xb8, 0x34, 0x4d, 0xdd, 0x34,
	0x75, 0x52, 0x92, 0x50, 0x42, 0xaf, 0x06, 0x93, 0x42, 0x0f, 0x49, 0x7d, 0x0c, 0x4d, 0x7f, 0x72,
	0xc4, 0x5a, 0x18, 0x1d, 0xaf, 0x77, 0x5d, 0x59, 0xa6, 0xf1, 0x5b, 0xf4, 0x11, 0xfa, 0x20, 0x7d,
	0x80, 0xfe, 0xcc, 0xcf, 0xfe, 0xec, 0x81, 0x17, 0xe9, 0x99, 0xd1, 0x5e, 0xb4, 0x17, 0x38, 0x3d,
	0xfd, 0xb7, 0xf3, 0x7d, 0x73, 0xd1, 0x8c, 0x66, 0x24, 0x2d, 0x99, 0x69, 0xaa, 0xa0, 0x7f, 0xb4,
	0x1d, 0xf8, 0x27, 0xb2, 0x53, 0xeb, 0xab, 0x40, 0x07, 0x94, 0x34, 0xb8, 0xe6, 0x87, 0xfc, 0xd8,
	0x13, 0x83, 0xd5, 0x3f, 0x17, 0xc9, 0x34, 0x68, 0xbc, 0xe5, 0xde, 0x50, 0x84, 0x6a, 0x74, 0x8a,
	0x94, 0xf6, 0x1a, 0xcc, 0xa9, 0x38, 0xd5, 0xc9, 0x56, 0x69, 0xaf, 0x41, 0x29, 0xb9, 0x7e, 0x38,
	0xea, 0x0b, 0x56, 0x42, 0x04, 0xbf, 0xe9, 0x32, 0xb9, 0x75, 0xa0, 0x95, 0xf0, 0x3b, 0xfa, 0x94,
	0x8d, 0x55, 0x9c, 0xaa, 0xd3, 0x8a, 0x65, 0xca, 0xc8, 0xcd, 0x7a, 0x47, 0x7a, 0x52, 0x8f, 0xd8,
	0x75, 0xa4, 0x22, 0x91, 0xae, 0x92, 0x3b, 0x7b, 0xbe, 0x16, 0x9e, 0x27, 0x3b, 0xc2, 0x77, 0x05,
	0x1b, 0x47, 0x3a, 0x85, 0x81, 0xe7, 0xb7, 0x52, 0x73, 0x34, 0xbf, 0x61, 0x3c, 0x47, 0x32, 0x9d,
	0x23, 0xe3, 0xaf, 0xf9, 0xbb, 0xdd, 0x26, 0xbb, 0x59, 0x71, 0xaa, 0x63, 0x2d, 0x23, 0xd0, 0x2a,
	0xb9, 0x7b, 0xd0, 0x95, 0x9e, 0xd7, 0x0c, 0x7e, 0x13, 0x6a, 0x5f, 0xf6, 0xa4, 0x66, 0xb7, 0x2a,
	0x4e, 0x75, 0xbc, 0x95, 0x85, 0xe9, 0x02, 0xb9, 0x51, 0xd7, 0x9a, 0xbb, 0x5d, 0x76, 0x1b, 0x3d,
	0x87, 0x12, 0x78, 0x30, 0x5f, 0x6f, 0x02, 0xc5, 0x7b, 0x5e, 0xbd, 0xdd, 0x66, 0x04, 0x15, 0xb2,
	0x30, 0x7d, 0x44, 0xa6, 0x6d, 0xa8, 0x21, 0x5c, 0xc5, 0x26, 0x50, 0x35, 0x87, 0xd3, 0x07, 0x64,
	0xd2, 0x60, 0xaf, 0xa4, 0x12, 0xe0, 0xf3, 0x0e, 0x2a, 0xa6, 0x41, 0xfa, 0x90, 0x4c, 0x25, 0x00,
	0xfa, 0x9b, 0x44, 0xb5, 0x0c, 0x9a, 0x78, 0xdb, 0x0e, 0xbc, 0x36, 0x78, 0x9b, 0xb2, 0xbd, 0x85,
	0x60, 0xe2, 0x0d, 0x00, 0xf4, 0x76, 0xd7, 0xf6, 0x16, 0xa1, 0x49, 0xc6, 0xcd, 0x40, 0x0e, 0x02,
	0x1f, 0xfc, 0x4d, 0xdb, 0x19, 0xc7, 0x70, 0x92, 0xb1, 0x81, 0xd0, 0xe7, 0x8c, 0x9d, 0x71, 0x82,
	0xd3, 0x1a, 0xa1, 0x06, 0xdb, 0x97, 0x9d, 0x53, 0xed, 0x4b, 0xbf, 0x03, 0x8e, 0x29, 0x6a, 0x17,
	0x30, 0xf4, 0x29, 0x99, 0xcd, 0xa0, 0xe8, 0x7e, 0x16, 0x0d, 0x8a, 0x28, 0xe8, 0xad, 0x5d, 0xa9,
	0x5b, 0x5c, 0x0b, 0x36, 0x57, 0x71, 0xaa, 0xa5, 0x56, 0x24, 0xd2, 0x15, 0x72, 0xbb, 0x11, 0xb4,
	0x3b, 0x02, 0xb9, 0x79, 0xe4, 0x12, 0x00, 0xba, 0x6a, 0x5b, 0x85, 0x86, 0x0b, 0x48, 0xc6, 0x32,
	0x58, 0x6e, 0x79, 0x81, 0xdb, 0x45, 0x72, 0xd1, 0x58, 0xc6, 0x00, 0x2d, 0x13, 0x82, 0x02, 0x8e,
	0x08, 0x63, 0xb8, 0x34, 0x0b, 0x81, 0x8a, 0x83, 0xa7, 0x06, 0xef, 0xf1, 0x30, 0xf8, 0x12, 0xba,
	0xc8, 0xa0, 0xd0, 0xbb, 0x75, 0xd5, 0x0b, 0x14, 0x5b, 0x46, 0x17, 0x46, 0x00, 0xeb, 0x96, 0x18,
	0xc8, 0x81, 0xe6, 0xbe, 0x2b, 0x60, 0xaf, 0xd9, 0x07, 0xc6, 0x3a, 0x8d, 0xa6, 0xf5, 0x60, 0x17,
	0xd9, 0x4a, 0x56, 0x0f, 0x50, 0xd8, 0xad, 0x04, 0x31, 0x3b, 0xc3, 0xee, 0xa1, 0x66, 0x0e, 0x87,
	0xea, 0x27, 0x58, 0x5c, 0x66, 0x56, 0x46, 0xf5, 0x22, 0x8a, 0x3e, 0x26, 0x33, 0x5b, 0xc2, 0xe4,
	0xf4, 0x26, 0x50, 0x3d, 0x8e, 0x93, 0x72, 0x1f, 0xf3, 0xc9, 0x13, 0xd0, 0x0d, 0x69, 0x10, 0x37,
	0xb7, 0x62, 0xba, 0x21, 0xcf, 0x40, 0x4f, 0x46, 0x68, 0x34, 0x31, 0x1f, 0x9a, 0x9e, 0xcc, 0xc0,
	0x90, 0xa5, 0x0d, 0xa1, 0xdf, 0x55, 0xd3, 0x93, 0x59, 0xdc, 0xf6, 0x1a, 0x4d, 0xce, 0x47, 0x69,
	0xaf, 0xd1, 0xec, 0x58, 0x5e, 0xe3, 0xe9, 0x79, 0x90, 0xf6, 0x1a, 0xcf, 0x8f, 0x55, 0x89, 0x64,
	0x82, 0x3e, 0x4e, 0x57, 0x22, 0x99, 0x21, 0xab, 0x12, 0xd6, 0x14, 0x3d, 0x4c, 0x57, 0xc2, 0x9a,
	0xa3, 0x35, 0x32, 0x17, 0xa1, 0xa9, 0x49, 0xfa, 0x04, 0x2d, 0x0a, 0x39, 0xfa, 0x9c, 0xcc, 0xe7,
	0x70, 0x0c, 0x53, 0x45, 0xa3, 0x62, 0x12, 0xba, 0x72, 0x7f, 0xe8, 0x76, 0x47, 0xec, 0x53, 0x3c,
	0xdc, 0x8d, 0x00, 0xd9, 0x85, 0xdb, 0x88, 0x23, 0x78, 0xd0, 0x17, 0xa2, 0xcd, 0x1e, 0x61, 0x5f,
	0xe4, 0x09, 0x5a, 0x21, 0x13, 0xe1, 0xa8, 0xa2, 0xa7, 0xcf, 0x50, 0xcf, 0x86, 0x60, 0x6d, 0x46,
	0xdc, 0xf2, 0x82, 0xa0, 0x3d, 0x18, 0xba, 0x5d, 0xa1, 0x70, 0x54, 0x1e, 0xa3, 0x6e, 0x31, 0x09,
	0x55, 0x88, 0xc2, 0x0c, 0xb5, 0x16, 0x4a, 0xfa, 0x1d, 0x34, 0xfa, 0x1c, 0x8d, 0x0a, 0x39, 0xda,
	0x20, 0xf7, 0x42, 0x5c, 0x0b, 0xee, 0xfd, 0xec, 0x69, 0xd9, 0xe3, 0x5a, 0x24, 0xf7, 0x00, 0xab,
	0xe1, 0xcd, 0x70, 0xb5, 0x92, 0x5d, 0xff, 0xa8, 0x3f, 0xdb, 0x43, 0x57, 0xb3, 0x27, 0xe9, 0xfa,
	0xdb, 0x1c, 0x4c, 0x68, 0x84, 0x1f, 0x9e, 0x06, 0xca, 0x1f, 0xb0, 0xa7, 0xe6, 0xe4, 0x4d, 0xa3,
	0x70, 0xda, 0xb4, 0x84, 0x1b, 0x9c, 0x09, 0xb5, 0xdb, 0x64, 0x5f, 0xe0, 0x3d, 0x96, 0x00, 0xb0,
	0xfe, 0x50, 0xc8, 0x2f, 0x0b, 0x93, 0x5f, 0xc3, 0xe4, 0xaf, 0x56, 0x82, 0xbb, 0x02, 0x85, 0x83,
	0x53, 0x29, 0xbc, 0xf6, 0x6e, 0x93, 0x3d, 0xc3, 0x38, 0x69, 0x90, 0x6e, 0x90, 0x45, 0x0b, 0x08,
	0x3d, 0x9a, 0xbd, 0x7e, 0x8e, 0x51, 0x2e, 0xa3, 0xa1, 0x3e, 0x87, 0x41, 0xdf, 0xd4, 0x70, 0xc7,
	0x13, 0x3d, 0xe1, 0xeb, 0xa6, 0x37, 0x1c, 0xb0, 0x17, 0xa6, 0x3e, 0x45, 0x1c, 0xd4, 0xe7, 0xa7,
	0x33, 0xa1, 0x1a, 0x4a, 0x9e, 0x09, 0x73, 0x49, 0xaf, 0xe3, 0x56, 0x64, 0x50, 0xba, 0x4e, 0x16,
	0x62, 0xa4, 0xde, 0x6e, 0xef, 0x9c, 0x9c, 0x48, 0x57, 0x0a, 0xdf, 0x1d, 0xb1, 0x2f, 0x51, 0xff,
	0x12, 0x16, 0x72, 0x8e, 0x99, 0x43, 0xd9, 0x13, 0x6c, 0x03, 0x3b, 0x3a, 0x0d, 0xc2, 0x3d, 0xf0,
	0x8b, 0xe0, 0x5d, 0x54, 0x78, 0x89, 0x0a, 0xb1, 0x8c, 0x27, 0x85, 0x12, 0xdc, 0x9c, 0xeb, 0x66,
	0x89, 0x9b, 0xe6, 0x1d, 0x91, 0x81, 0x71, 0xaf, 0x01, 0x3a, 0xd0, 0x5c, 0x9b, 0x60, 0x5f, 0xa1,
	0xaf, 0x0c, 0x0a, 0x7a, 0x3b, 0xbf, 0x0e, 0x65, 0xff, 0xb5, 0xf4, 0xc3, 0x77, 0xc7, 0xd7, 0xa6,
	0x27, 0xd2, 0x68, 0xa2, 0xc7, 0xdf, 0x85, 0x7a, 0xdf, 0xd8, 0x7a, 0x11, 0x0a, 0x2b, 0x44, 0xc4,
	0x88, 0xd8, 0x0f, 0xdf, 0x9a, 0xb3, 0x2c, 0x03, 0xc3, 0xc4, 0x59, 0x90, 0x69, 0x54, 0xdc, 0xa2,
	0xef, 0xcc, 0x69, 0x50, 0x48, 0xc2, 0x8d, 0x60, 0x11, 0x70, 0x84, 0xa2, 0xcd, 0xf7, 0xe6, 0x3e,
	0x2e, 0xa0, 0x32, 0x16, 0x70, 0x3c, 0xa2, 0x45, 0x3d, 0x67, 0x11, 0x51, 0x99, 0x95, 0x99, 0x43,
	0x0f, 0x6d, 0xb6, 0x72, 0x2b, 0x4b, 0x48, 0xba, 0x49, 0x98, 0x45, 0xc4, 0x67, 0x18, 0x1a, 0x6e,
	0xa3, 0xe1, 0xa5, 0x7c, 0xea, 0xcd, 0x16, 0x95, 0xa1, 0x91, 0x79, 0xb3, 0x45, 0x15, 0x48, 0xbd,
	0xc6, 0x50, 0x73, 0x27, 0xfb, 0x1a, 0x4b, 0xeb, 0xc5, 0x29, 0xbf, 0xca, 0xbe, 0xb3, 0xd2, 0xb1,
	0xad, 0x44, 0x7f, 0xc8, 0xbf, 0x9e, 0xa2, 0x5a, 0x16, 0xa5, 0xb7, 0x5b, 0xf8, 0x1a, 0x02, 0x6a,
	0x75, 0x9e, 0xcc, 0xfe, 0x18, 0x1c, 0xc3, 0x03, 0x1e, 0xfb, 0x32, 0x7c, 0xc0, 0xaf, 0x52, 0xf3,
	0xa8, 0xdf, 0xf3, 0xb5, 0x0a, 0x22, 0xec, 0x8f, 0x71, 0x03, 0x86, 0xf2, 0x11, 0xfc, 0x04, 0x50,
	0x8f, 0x2c, 0x64, 0x5f, 0xff, 0x47, 0x52, 0x8b, 0xde, 0x80, 0x39, 0x95, 0xb1, 0xea, 0xc4, 0xda,
	0x7a, 0x2d, 0xf9, 0x57, 0xa8, 0x65, 0xad, 0x6b, 0xb1, 0xa9, 0x01, 0xf7, 0xc0, 0x70, 0xc7, 0xd7,
	0x6a, 0xd4, 0x9a, 0x2b, 0xa2, 0xe8, 0x90, 0x2c, 0x15, 0xac, 0x36, 0x0c, 0x58, 0xc2, 0x80, 0x2f,
	0xaf, 0x0c, 0x68, 0x5b, 0xe7, 0x62, 0x2e, 0x5e, 0xc2, 0x46, 0x49, 0xda, 0xd5, 0x08, 0x63, 0x8e,
	0xfd, 0xc7, 0x24, 0xd1, 0xb4, 0x38, 0xc9, 0x2c, 0xb5, 0x2c, 0xc8, 0xd2, 0xa5, 0x75, 0xa1, 0xd3,
	0x64, 0xac, 0x2b, 0x46, 0xe1, 0xaf, 0x15, 0x7c, 0xd2, 0x35, 0x32, 0x7e, 0x86, 0x0f, 0x4b, 0xf8,
	0xb9, 0x9a, 0x58, 0x5b, 0xc9, 0xae, 0xc5, 0xde, 0x9a, 0x96, 0x51, 0xdd, 0x2c, 0x6d, 0x38, 0xcb,
	0x5d, 0xb2, 0x72, 0x55, 0x35, 0x0a, 0x22, 0xbd, 0x48, 0x47, 0xba, 0x6f, 0x47, 0x2a, 0xd8, 0x16,
	0x3b, 0x58, 0x98, 0x53, 0x61, 0x19, 0xfe, 0x47, 0x4e, 0xf6, 0x4e, 0x58, 0x61, 0xb6, 0x9e, 0xfc,
	0x75, 0x5e, 0x76, 0xde, 0x9f, 0x97, 0x9d, 0x7f, 0xce, 0xcb, 0xce, 0xef, 0x17, 0xe5, 0x6b, 0xef,
	0x2f, 0xca, 0xd7, 0xfe, 0xbe, 0x28, 0x5f, 0x23, 0xf3, 0x6e, 0xd0, 0xab, 0x35, 0xb8, 0x1c, 0x8c,
	0x6a, 0x03, 0xa1, 0xce, 0x84, 0xaa, 0xb5, 0xb9, 0xe6, 0xc7, 0x37, 0xf0, 0x87, 0xf6, 0xd9, 0xbf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x36, 0xa8, 0x17, 0x7f, 0xe5, 0x0e, 0x00, 0x00,
}

func (m *PropValue_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropValue_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropValue_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AttackLightningPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackLightningPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xc1
	}
	if m.AttackPoisonPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackPoisonPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb9
	}
	if m.AttackColdPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackColdPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb1
	}
	if m.AttackFirePlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackFirePlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa9
	}
	if m.AttackNormalPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackNormalPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xa1
	}
	if m.EquipAttackLightningPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackLightningPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x99
	}
	if m.EquipAttackPoisonPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackPoisonPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x91
	}
	if m.EquipAttackColdPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackColdPlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x89
	}
	if m.EquipAttackFirePlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackFirePlus))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x81
	}
	if m.EquipAttackNormalPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackNormalPlus))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf9
	}
	if m.EquipAttackRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipAttackRate))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf1
	}
	if m.EquipMaxAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipMaxAttack))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe9
	}
	if m.EquipMinAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EquipMinAttack))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe1
	}
	if m.BreakStateTime != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.BreakStateTime))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd8
	}
	if m.BreakValueLimit != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.BreakValueLimit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xd0
	}
	if m.WeakTime != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.WeakTime))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc8
	}
	if m.OverDriveTime != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.OverDriveTime))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xc0
	}
	if m.OverDriveAddEfficiency != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.OverDriveAddEfficiency))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb8
	}
	if m.OverDriveLimit != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.OverDriveLimit))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb0
	}
	if m.TopAttackElementPlus != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TopAttackElementPlus))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa9
	}
	if m.PowerShieldRecoverSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PowerShieldRecoverSpeed))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.PowerShieldHP != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.PowerShieldHP))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.RecoverUltimateSkillPowerRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RecoverUltimateSkillPowerRate))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x95
	}
	if m.RecoverHP != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.RecoverHP))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.BeDamageThorns != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageThorns))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x81
	}
	if m.BeDamageNormalDeduct != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageNormalDeduct))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf9
	}
	if m.AttackStealUltimateSkillPower != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.AttackStealUltimateSkillPower))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.AttackSputteringRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackSputteringRate))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xed
	}
	if m.AttackBloodsuckerRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackBloodsuckerRate))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe5
	}
	if m.AttackLucky != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackLucky))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xdd
	}
	if m.NormalAttackSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NormalAttackSpeed))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd5
	}
	if m.Lucky != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.Lucky))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.BeDamageLightningDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageLightningDecr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc1
	}
	if m.BeDamageLightningAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageLightningAdd))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb9
	}
	if m.BeDamagePoisonDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamagePoisonDecr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb1
	}
	if m.BeDamagePoisonAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamagePoisonAdd))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa9
	}
	if m.BeDamageColdDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageColdDecr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa1
	}
	if m.BeDamageColdAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageColdAdd))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x99
	}
	if m.BeDamageFireDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageFireDecr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x91
	}
	if m.BeDamageFireAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageFireAdd))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x89
	}
	if m.BeDamageNormalDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageNormalDecr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x81
	}
	if m.BeDamageNormalAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeDamageNormalAdd))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf9
	}
	if m.ResistanceLightning != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceLightning))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.ResistancePoison != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistancePoison))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.ResistanceCold != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceCold))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.ResistanceFire != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResistanceFire))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.Armor != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Armor))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd1
	}
	if m.CritDamageRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CritDamageRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.BlockValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BlockValue))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if m.BlockRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BlockRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.CritRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CritRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.DodgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DodgeRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.HitRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HitRate))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.AttackLightningDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackLightningDecr))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x99
	}
	if m.AttackLightningAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackLightningAdd))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x91
	}
	if m.AttackPoisonDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackPoisonDecr))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.AttackPoisonAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackPoisonAdd))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.AttackColdDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackColdDecr))))
		i--
		dAtA[i] = 0x79
	}
	if m.AttackColdAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackColdAdd))))
		i--
		dAtA[i] = 0x71
	}
	if m.AttackFireDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackFireDecr))))
		i--
		dAtA[i] = 0x69
	}
	if m.AttackFireAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackFireAdd))))
		i--
		dAtA[i] = 0x61
	}
	if m.AttackNoramlDecr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackNoramlDecr))))
		i--
		dAtA[i] = 0x59
	}
	if m.AttackNoramlAdd != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AttackNoramlAdd))))
		i--
		dAtA[i] = 0x51
	}
	if m.Attack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Attack))))
		i--
		dAtA[i] = 0x49
	}
	if m.SkillPowerLimit != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.SkillPowerLimit))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxHP != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.MaxHP))
		i--
		dAtA[i] = 0x38
	}
	if m.Vitality != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Vitality))))
		i--
		dAtA[i] = 0x31
	}
	if m.Intelligence != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Intelligence))))
		i--
		dAtA[i] = 0x29
	}
	if m.Agility != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Agility))))
		i--
		dAtA[i] = 0x21
	}
	if m.Strength != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Strength))))
		i--
		dAtA[i] = 0x19
	}
	if m.Type != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintProp_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobPropLimit_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobPropLimit_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobPropLimit_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PropIntro_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropIntro_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropIntro_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Prop_Config_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prop_Config_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prop_Config_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PropIntro_ConfigItems) > 0 {
		for k := range m.PropIntro_ConfigItems {
			v := m.PropIntro_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProp_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintProp_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProp_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.JobPropLimit_ConfigItems) > 0 {
		for k := range m.JobPropLimit_ConfigItems {
			v := m.JobPropLimit_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProp_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintProp_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProp_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PropValue_ConfigItems) > 0 {
		for k := range m.PropValue_ConfigItems {
			v := m.PropValue_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintProp_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintProp_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintProp_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintProp_Config(dAtA []byte, offset int, v uint64) int {
	offset -= sovProp_Config(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PropValue_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovProp_Config(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovProp_Config(uint64(m.Type))
	}
	if m.Strength != 0 {
		n += 9
	}
	if m.Agility != 0 {
		n += 9
	}
	if m.Intelligence != 0 {
		n += 9
	}
	if m.Vitality != 0 {
		n += 9
	}
	if m.MaxHP != 0 {
		n += 1 + sovProp_Config(uint64(m.MaxHP))
	}
	if m.SkillPowerLimit != 0 {
		n += 1 + sovProp_Config(uint64(m.SkillPowerLimit))
	}
	if m.Attack != 0 {
		n += 9
	}
	if m.AttackNoramlAdd != 0 {
		n += 9
	}
	if m.AttackNoramlDecr != 0 {
		n += 9
	}
	if m.AttackFireAdd != 0 {
		n += 9
	}
	if m.AttackFireDecr != 0 {
		n += 9
	}
	if m.AttackColdAdd != 0 {
		n += 9
	}
	if m.AttackColdDecr != 0 {
		n += 9
	}
	if m.AttackPoisonAdd != 0 {
		n += 10
	}
	if m.AttackPoisonDecr != 0 {
		n += 10
	}
	if m.AttackLightningAdd != 0 {
		n += 10
	}
	if m.AttackLightningDecr != 0 {
		n += 10
	}
	if m.HitRate != 0 {
		n += 6
	}
	if m.DodgeRate != 0 {
		n += 6
	}
	if m.CritRate != 0 {
		n += 6
	}
	if m.BlockRate != 0 {
		n += 6
	}
	if m.BlockValue != 0 {
		n += 10
	}
	if m.CritDamageRate != 0 {
		n += 6
	}
	if m.Armor != 0 {
		n += 10
	}
	if m.ResistanceFire != 0 {
		n += 6
	}
	if m.ResistanceCold != 0 {
		n += 6
	}
	if m.ResistancePoison != 0 {
		n += 6
	}
	if m.ResistanceLightning != 0 {
		n += 6
	}
	if m.BeDamageNormalAdd != 0 {
		n += 10
	}
	if m.BeDamageNormalDecr != 0 {
		n += 10
	}
	if m.BeDamageFireAdd != 0 {
		n += 10
	}
	if m.BeDamageFireDecr != 0 {
		n += 10
	}
	if m.BeDamageColdAdd != 0 {
		n += 10
	}
	if m.BeDamageColdDecr != 0 {
		n += 10
	}
	if m.BeDamagePoisonAdd != 0 {
		n += 10
	}
	if m.BeDamagePoisonDecr != 0 {
		n += 10
	}
	if m.BeDamageLightningAdd != 0 {
		n += 10
	}
	if m.BeDamageLightningDecr != 0 {
		n += 10
	}
	if m.Lucky != 0 {
		n += 2 + sovProp_Config(uint64(m.Lucky))
	}
	if m.NormalAttackSpeed != 0 {
		n += 6
	}
	if m.AttackLucky != 0 {
		n += 6
	}
	if m.AttackBloodsuckerRate != 0 {
		n += 6
	}
	if m.AttackSputteringRate != 0 {
		n += 6
	}
	if m.AttackStealUltimateSkillPower != 0 {
		n += 2 + sovProp_Config(uint64(m.AttackStealUltimateSkillPower))
	}
	if m.BeDamageNormalDeduct != 0 {
		n += 10
	}
	if m.BeDamageThorns != 0 {
		n += 10
	}
	if m.RecoverHP != 0 {
		n += 2 + sovProp_Config(uint64(m.RecoverHP))
	}
	if m.RecoverUltimateSkillPowerRate != 0 {
		n += 6
	}
	if m.PowerShieldHP != 0 {
		n += 2 + sovProp_Config(uint64(m.PowerShieldHP))
	}
	if m.PowerShieldRecoverSpeed != 0 {
		n += 6
	}
	if m.TopAttackElementPlus != 0 {
		n += 10
	}
	if m.OverDriveLimit != 0 {
		n += 2 + sovProp_Config(uint64(m.OverDriveLimit))
	}
	if m.OverDriveAddEfficiency != 0 {
		n += 2 + sovProp_Config(uint64(m.OverDriveAddEfficiency))
	}
	if m.OverDriveTime != 0 {
		n += 2 + sovProp_Config(uint64(m.OverDriveTime))
	}
	if m.WeakTime != 0 {
		n += 2 + sovProp_Config(uint64(m.WeakTime))
	}
	if m.BreakValueLimit != 0 {
		n += 2 + sovProp_Config(uint64(m.BreakValueLimit))
	}
	if m.BreakStateTime != 0 {
		n += 2 + sovProp_Config(uint64(m.BreakStateTime))
	}
	if m.EquipMinAttack != 0 {
		n += 10
	}
	if m.EquipMaxAttack != 0 {
		n += 10
	}
	if m.EquipAttackRate != 0 {
		n += 10
	}
	if m.EquipAttackNormalPlus != 0 {
		n += 10
	}
	if m.EquipAttackFirePlus != 0 {
		n += 10
	}
	if m.EquipAttackColdPlus != 0 {
		n += 10
	}
	if m.EquipAttackPoisonPlus != 0 {
		n += 10
	}
	if m.EquipAttackLightningPlus != 0 {
		n += 10
	}
	if m.AttackNormalPlus != 0 {
		n += 10
	}
	if m.AttackFirePlus != 0 {
		n += 10
	}
	if m.AttackColdPlus != 0 {
		n += 10
	}
	if m.AttackPoisonPlus != 0 {
		n += 10
	}
	if m.AttackLightningPlus != 0 {
		n += 10
	}
	return n
}

func (m *JobPropLimit_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PropIntro_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Prop_Config_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PropValue_ConfigItems) > 0 {
		for k, v := range m.PropValue_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProp_Config(uint64(l))
			}
			mapEntrySize := 1 + sovProp_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovProp_Config(uint64(mapEntrySize))
		}
	}
	if len(m.JobPropLimit_ConfigItems) > 0 {
		for k, v := range m.JobPropLimit_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProp_Config(uint64(l))
			}
			mapEntrySize := 1 + sovProp_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovProp_Config(uint64(mapEntrySize))
		}
	}
	if len(m.PropIntro_ConfigItems) > 0 {
		for k, v := range m.PropIntro_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovProp_Config(uint64(l))
			}
			mapEntrySize := 1 + sovProp_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovProp_Config(uint64(mapEntrySize))
		}
	}
	return n
}

func sovProp_Config(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProp_Config(x uint64) (n int) {
	return sovProp_Config(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PropValue_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProp_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropValue_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropValue_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Strength = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agility", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Agility = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intelligence", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Intelligence = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vitality", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Vitality = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHP", wireType)
			}
			m.MaxHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillPowerLimit", wireType)
			}
			m.SkillPowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillPowerLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Attack = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackNoramlAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackNoramlAdd = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackNoramlDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackNoramlDecr = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackFireAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackFireAdd = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackFireDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackFireDecr = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackColdAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackColdAdd = float64(math.Float64frombits(v))
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackColdDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackColdDecr = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackPoisonAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackPoisonAdd = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackPoisonDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackPoisonDecr = float64(math.Float64frombits(v))
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLightningAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackLightningAdd = float64(math.Float64frombits(v))
		case 19:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLightningDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackLightningDecr = float64(math.Float64frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HitRate = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DodgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DodgeRate = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CritRate = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BlockRate = float32(math.Float32frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BlockValue = float64(math.Float64frombits(v))
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CritDamageRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CritDamageRate = float32(math.Float32frombits(v))
		case 26:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Armor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Armor = float64(math.Float64frombits(v))
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceFire", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceFire = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceCold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceCold = float32(math.Float32frombits(v))
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistancePoison", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistancePoison = float32(math.Float32frombits(v))
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResistanceLightning", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResistanceLightning = float32(math.Float32frombits(v))
		case 31:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageNormalAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageNormalAdd = float64(math.Float64frombits(v))
		case 32:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageNormalDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageNormalDecr = float64(math.Float64frombits(v))
		case 33:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageFireAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageFireAdd = float64(math.Float64frombits(v))
		case 34:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageFireDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageFireDecr = float64(math.Float64frombits(v))
		case 35:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageColdAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageColdAdd = float64(math.Float64frombits(v))
		case 36:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageColdDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageColdDecr = float64(math.Float64frombits(v))
		case 37:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamagePoisonAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamagePoisonAdd = float64(math.Float64frombits(v))
		case 38:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamagePoisonDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamagePoisonDecr = float64(math.Float64frombits(v))
		case 39:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageLightningAdd", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageLightningAdd = float64(math.Float64frombits(v))
		case 40:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageLightningDecr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageLightningDecr = float64(math.Float64frombits(v))
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalAttackSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NormalAttackSpeed = float32(math.Float32frombits(v))
		case 43:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLucky", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackLucky = float32(math.Float32frombits(v))
		case 44:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackBloodsuckerRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackBloodsuckerRate = float32(math.Float32frombits(v))
		case 45:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackSputteringRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackSputteringRate = float32(math.Float32frombits(v))
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackStealUltimateSkillPower", wireType)
			}
			m.AttackStealUltimateSkillPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackStealUltimateSkillPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageNormalDeduct", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageNormalDeduct = float64(math.Float64frombits(v))
		case 48:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeDamageThorns", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeDamageThorns = float64(math.Float64frombits(v))
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverHP", wireType)
			}
			m.RecoverHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverUltimateSkillPowerRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RecoverUltimateSkillPowerRate = float32(math.Float32frombits(v))
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerShieldHP", wireType)
			}
			m.PowerShieldHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerShieldHP |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerShieldRecoverSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PowerShieldRecoverSpeed = float32(math.Float32frombits(v))
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopAttackElementPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TopAttackElementPlus = float64(math.Float64frombits(v))
		case 54:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverDriveLimit", wireType)
			}
			m.OverDriveLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverDriveLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 55:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverDriveAddEfficiency", wireType)
			}
			m.OverDriveAddEfficiency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverDriveAddEfficiency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 56:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverDriveTime", wireType)
			}
			m.OverDriveTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverDriveTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 57:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeakTime", wireType)
			}
			m.WeakTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeakTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 58:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakValueLimit", wireType)
			}
			m.BreakValueLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BreakValueLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 59:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BreakStateTime", wireType)
			}
			m.BreakStateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BreakStateTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 60:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipMinAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipMinAttack = float64(math.Float64frombits(v))
		case 61:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipMaxAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipMaxAttack = float64(math.Float64frombits(v))
		case 62:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackRate = float64(math.Float64frombits(v))
		case 63:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackNormalPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackNormalPlus = float64(math.Float64frombits(v))
		case 64:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackFirePlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackFirePlus = float64(math.Float64frombits(v))
		case 65:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackColdPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackColdPlus = float64(math.Float64frombits(v))
		case 66:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackPoisonPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackPoisonPlus = float64(math.Float64frombits(v))
		case 67:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipAttackLightningPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EquipAttackLightningPlus = float64(math.Float64frombits(v))
		case 68:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackNormalPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackNormalPlus = float64(math.Float64frombits(v))
		case 69:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackFirePlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackFirePlus = float64(math.Float64frombits(v))
		case 70:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackColdPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackColdPlus = float64(math.Float64frombits(v))
		case 71:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackPoisonPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackPoisonPlus = float64(math.Float64frombits(v))
		case 72:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackLightningPlus", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AttackLightningPlus = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipProp_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobPropLimit_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProp_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobPropLimit_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobPropLimit_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProp_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropIntro_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProp_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropIntro_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropIntro_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProp_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prop_Config_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProp_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prop_Config_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prop_Config_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropValue_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProp_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProp_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PropValue_ConfigItems == nil {
				m.PropValue_ConfigItems = make(map[uint32]*PropValue_Config)
			}
			var mapkey uint32
			var mapvalue *PropValue_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProp_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProp_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProp_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropValue_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProp_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProp_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PropValue_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobPropLimit_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProp_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProp_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobPropLimit_ConfigItems == nil {
				m.JobPropLimit_ConfigItems = make(map[uint32]*JobPropLimit_Config)
			}
			var mapkey uint32
			var mapvalue *JobPropLimit_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProp_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProp_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProp_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &JobPropLimit_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProp_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProp_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobPropLimit_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropIntro_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProp_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProp_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PropIntro_ConfigItems == nil {
				m.PropIntro_ConfigItems = make(map[uint32]*PropIntro_Config)
			}
			var mapkey uint32
			var mapvalue *PropIntro_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProp_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProp_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthProp_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthProp_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PropIntro_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProp_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthProp_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PropIntro_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProp_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProp_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProp_Config(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProp_Config
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProp_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProp_Config
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProp_Config
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProp_Config
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProp_Config        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProp_Config          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProp_Config = fmt.Errorf("proto: unexpected end of group")
)
