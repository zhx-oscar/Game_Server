// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Skill_Config.proto

package DataTables

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SkillMain_Config struct {
	//* 技能逻辑ID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 技能名
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	//* 技能类型
	//1：主动技能
	//2：普攻
	//3：必杀技
	//4：合体技
	SkillKind uint32 `protobuf:"varint,5,opt,name=SkillKind,proto3" json:"SkillKind,omitempty"`
	//* 技能原型ID
	//第1位. 技能类型
	//第2位：BD
	//第3-5位：流水号
	ProtoID uint32 `protobuf:"varint,6,opt,name=ProtoID,proto3" json:"ProtoID,omitempty"`
	//* 技能BuildID：
	//1：原型
	//2：火焰bd
	//3：冰霜bd
	//等等
	BuildID uint32 `protobuf:"varint,7,opt,name=BuildID,proto3" json:"BuildID,omitempty"`
	//* 技能类型标签
	SkillLabel []uint32 `protobuf:"varint,8,rep,packed,name=SkillLabel,proto3" json:"SkillLabel,omitempty"`
	//* 最小射程
	MinCastDistance float32 `protobuf:"fixed32,9,opt,name=MinCastDistance,proto3" json:"MinCastDistance,omitempty"`
	//* 最大射程
	MaxCastDistance float32 `protobuf:"fixed32,10,opt,name=MaxCastDistance,proto3" json:"MaxCastDistance,omitempty"`
	//* 伤害体模板ID
	TemplateID uint32 `protobuf:"varint,11,opt,name=TemplateID,proto3" json:"TemplateID,omitempty"`
	//* 伤害体模板参数
	TemplateArgs string `protobuf:"bytes,12,opt,name=TemplateArgs,proto3" json:"TemplateArgs,omitempty"`
	//* 可以冲刺
	CanDash bool `protobuf:"varint,13,opt,name=CanDash,proto3" json:"CanDash,omitempty"`
	//* 触发被击时，将目标视为质量类型：（填写Mass表中的ID，不填表示不变）
	MassID uint32 `protobuf:"varint,14,opt,name=MassID,proto3" json:"MassID,omitempty"`
	//* 对目标施加Buff
	//（成功命中后）
	TargetBuff uint32 `protobuf:"varint,15,opt,name=TargetBuff,proto3" json:"TargetBuff,omitempty"`
	//* 给自己施加Buff
	//（发招阶段开始时）
	OwnBuff uint32 `protobuf:"varint,16,opt,name=OwnBuff,proto3" json:"OwnBuff,omitempty"`
	//* 技能Timeline
	Timeline string `protobuf:"bytes,17,opt,name=Timeline,proto3" json:"Timeline,omitempty"`
	//* 命中增加崩坏值
	HitAddBreakValue int32 `protobuf:"varint,18,opt,name=HitAddBreakValue,proto3" json:"HitAddBreakValue,omitempty"`
	//* 命中增加格挡失衡值
	HitAddBlockBreakValue int32 `protobuf:"varint,19,opt,name=HitAddBlockBreakValue,proto3" json:"HitAddBlockBreakValue,omitempty"`
	//* 清除buff组
	ClearGroup []uint32 `protobuf:"varint,20,rep,packed,name=ClearGroup,proto3" json:"ClearGroup,omitempty"`
}

func (m *SkillMain_Config) Reset()         { *m = SkillMain_Config{} }
func (m *SkillMain_Config) String() string { return proto.CompactTextString(m) }
func (*SkillMain_Config) ProtoMessage()    {}
func (*SkillMain_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{0}
}
func (m *SkillMain_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillMain_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillMain_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillMain_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillMain_Config.Merge(m, src)
}
func (m *SkillMain_Config) XXX_Size() int {
	return m.Size()
}
func (m *SkillMain_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillMain_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SkillMain_Config proto.InternalMessageInfo

func (m *SkillMain_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SkillMain_Config) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SkillMain_Config) GetSkillKind() uint32 {
	if m != nil {
		return m.SkillKind
	}
	return 0
}

func (m *SkillMain_Config) GetProtoID() uint32 {
	if m != nil {
		return m.ProtoID
	}
	return 0
}

func (m *SkillMain_Config) GetBuildID() uint32 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *SkillMain_Config) GetSkillLabel() []uint32 {
	if m != nil {
		return m.SkillLabel
	}
	return nil
}

func (m *SkillMain_Config) GetMinCastDistance() float32 {
	if m != nil {
		return m.MinCastDistance
	}
	return 0
}

func (m *SkillMain_Config) GetMaxCastDistance() float32 {
	if m != nil {
		return m.MaxCastDistance
	}
	return 0
}

func (m *SkillMain_Config) GetTemplateID() uint32 {
	if m != nil {
		return m.TemplateID
	}
	return 0
}

func (m *SkillMain_Config) GetTemplateArgs() string {
	if m != nil {
		return m.TemplateArgs
	}
	return ""
}

func (m *SkillMain_Config) GetCanDash() bool {
	if m != nil {
		return m.CanDash
	}
	return false
}

func (m *SkillMain_Config) GetMassID() uint32 {
	if m != nil {
		return m.MassID
	}
	return 0
}

func (m *SkillMain_Config) GetTargetBuff() uint32 {
	if m != nil {
		return m.TargetBuff
	}
	return 0
}

func (m *SkillMain_Config) GetOwnBuff() uint32 {
	if m != nil {
		return m.OwnBuff
	}
	return 0
}

func (m *SkillMain_Config) GetTimeline() string {
	if m != nil {
		return m.Timeline
	}
	return ""
}

func (m *SkillMain_Config) GetHitAddBreakValue() int32 {
	if m != nil {
		return m.HitAddBreakValue
	}
	return 0
}

func (m *SkillMain_Config) GetHitAddBlockBreakValue() int32 {
	if m != nil {
		return m.HitAddBlockBreakValue
	}
	return 0
}

func (m *SkillMain_Config) GetClearGroup() []uint32 {
	if m != nil {
		return m.ClearGroup
	}
	return nil
}

type SkillValue_Config struct {
	//* 技能ID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 逻辑ID
	SkillID uint32 `protobuf:"varint,2,opt,name=SkillID,proto3" json:"SkillID,omitempty"`
	//* 等级
	Level uint32 `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	//* 品质
	//1-普通的，白色
	//2-稀有的，蓝色
	//3-传说的，亮金
	//4-史诗的，暗金
	Quality uint32 `protobuf:"varint,4,opt,name=quality,proto3" json:"quality,omitempty"`
	//* 冷却时间
	//单位：ms
	CoolDown uint32 `protobuf:"varint,5,opt,name=CoolDown,proto3" json:"CoolDown,omitempty"`
	//* 施法时增加的必杀技能量
	CastAddUltimateSkillPower int32 `protobuf:"varint,6,opt,name=CastAddUltimateSkillPower,proto3" json:"CastAddUltimateSkillPower,omitempty"`
	//* 命中时增加的必杀技能量
	HitAddUltimateSkillPower int32 `protobuf:"varint,7,opt,name=HitAddUltimateSkillPower,proto3" json:"HitAddUltimateSkillPower,omitempty"`
	//* 物理伤害
	NormalAttack float64 `protobuf:"fixed64,8,opt,name=NormalAttack,proto3" json:"NormalAttack,omitempty"`
	//* 火焰伤害
	FireAttack float64 `protobuf:"fixed64,9,opt,name=FireAttack,proto3" json:"FireAttack,omitempty"`
	//* 冰霜伤害
	ColdAttack float64 `protobuf:"fixed64,10,opt,name=ColdAttack,proto3" json:"ColdAttack,omitempty"`
	//* 毒素伤害
	PoisonAttack float64 `protobuf:"fixed64,11,opt,name=PoisonAttack,proto3" json:"PoisonAttack,omitempty"`
	//* 闪电伤害
	LightningAttack float64 `protobuf:"fixed64,12,opt,name=LightningAttack,proto3" json:"LightningAttack,omitempty"`
	//* 技能事件触发行为，例：[{"Cond":1,"Target":1,"AddBuff":1001}]
	//Cond：触发条件 1-命中时触发
	//Target：作用目标 1-技能目标 2-自己 3-己方全体
	//AddBuff：施加的buffid
	TriggerActions string `protobuf:"bytes,13,opt,name=TriggerActions,proto3" json:"TriggerActions,omitempty"`
}

func (m *SkillValue_Config) Reset()         { *m = SkillValue_Config{} }
func (m *SkillValue_Config) String() string { return proto.CompactTextString(m) }
func (*SkillValue_Config) ProtoMessage()    {}
func (*SkillValue_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{1}
}
func (m *SkillValue_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillValue_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillValue_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillValue_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillValue_Config.Merge(m, src)
}
func (m *SkillValue_Config) XXX_Size() int {
	return m.Size()
}
func (m *SkillValue_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillValue_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SkillValue_Config proto.InternalMessageInfo

func (m *SkillValue_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SkillValue_Config) GetSkillID() uint32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *SkillValue_Config) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SkillValue_Config) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *SkillValue_Config) GetCoolDown() uint32 {
	if m != nil {
		return m.CoolDown
	}
	return 0
}

func (m *SkillValue_Config) GetCastAddUltimateSkillPower() int32 {
	if m != nil {
		return m.CastAddUltimateSkillPower
	}
	return 0
}

func (m *SkillValue_Config) GetHitAddUltimateSkillPower() int32 {
	if m != nil {
		return m.HitAddUltimateSkillPower
	}
	return 0
}

func (m *SkillValue_Config) GetNormalAttack() float64 {
	if m != nil {
		return m.NormalAttack
	}
	return 0
}

func (m *SkillValue_Config) GetFireAttack() float64 {
	if m != nil {
		return m.FireAttack
	}
	return 0
}

func (m *SkillValue_Config) GetColdAttack() float64 {
	if m != nil {
		return m.ColdAttack
	}
	return 0
}

func (m *SkillValue_Config) GetPoisonAttack() float64 {
	if m != nil {
		return m.PoisonAttack
	}
	return 0
}

func (m *SkillValue_Config) GetLightningAttack() float64 {
	if m != nil {
		return m.LightningAttack
	}
	return 0
}

func (m *SkillValue_Config) GetTriggerActions() string {
	if m != nil {
		return m.TriggerActions
	}
	return ""
}

type SkillItem_Config struct {
	//* itemid
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 技能MainID
	SkillID uint32 `protobuf:"varint,2,opt,name=SkillID,proto3" json:"SkillID,omitempty"`
	//* 最大拥有数量
	MaxNum uint32 `protobuf:"varint,3,opt,name=MaxNum,proto3" json:"MaxNum,omitempty"`
	//* 最大堆叠数量
	MaxPileNum uint32 `protobuf:"varint,4,opt,name=MaxPileNum,proto3" json:"MaxPileNum,omitempty"`
	//* 捐赠获得指挥官经验
	GiftGotCommanderExp uint32 `protobuf:"varint,7,opt,name=GiftGotCommanderExp,proto3" json:"GiftGotCommanderExp,omitempty"`
	//* 捐赠获得当前上阵特工经验
	GiftGotSpecialAgentExp uint32 `protobuf:"varint,8,opt,name=GiftGotSpecialAgentExp,proto3" json:"GiftGotSpecialAgentExp,omitempty"`
	//* 捐赠获得金币
	GiftGotGold uint32 `protobuf:"varint,9,opt,name=GiftGotGold,proto3" json:"GiftGotGold,omitempty"`
}

func (m *SkillItem_Config) Reset()         { *m = SkillItem_Config{} }
func (m *SkillItem_Config) String() string { return proto.CompactTextString(m) }
func (*SkillItem_Config) ProtoMessage()    {}
func (*SkillItem_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{2}
}
func (m *SkillItem_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillItem_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillItem_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillItem_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillItem_Config.Merge(m, src)
}
func (m *SkillItem_Config) XXX_Size() int {
	return m.Size()
}
func (m *SkillItem_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillItem_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SkillItem_Config proto.InternalMessageInfo

func (m *SkillItem_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SkillItem_Config) GetSkillID() uint32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *SkillItem_Config) GetMaxNum() uint32 {
	if m != nil {
		return m.MaxNum
	}
	return 0
}

func (m *SkillItem_Config) GetMaxPileNum() uint32 {
	if m != nil {
		return m.MaxPileNum
	}
	return 0
}

func (m *SkillItem_Config) GetGiftGotCommanderExp() uint32 {
	if m != nil {
		return m.GiftGotCommanderExp
	}
	return 0
}

func (m *SkillItem_Config) GetGiftGotSpecialAgentExp() uint32 {
	if m != nil {
		return m.GiftGotSpecialAgentExp
	}
	return 0
}

func (m *SkillItem_Config) GetGiftGotGold() uint32 {
	if m != nil {
		return m.GiftGotGold
	}
	return 0
}

type SkillEntity_Config struct {
	//* Main ID
	ID uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	//* 职业要求
	//空-通用
	//1-力量型
	//2-敏捷型
	//3-念力型
	SpecialAgentType []uint32 `protobuf:"varint,2,rep,packed,name=SpecialAgentType,proto3" json:"SpecialAgentType,omitempty"`
	//* 技能所属特工
	//空-通用
	//非空-特工ID
	SpecialAgentID []uint32 `protobuf:"varint,3,rep,packed,name=SpecialAgentID,proto3" json:"SpecialAgentID,omitempty"`
	//* 技能最高等级
	TopSkillLevel uint32 `protobuf:"varint,4,opt,name=TopSkillLevel,proto3" json:"TopSkillLevel,omitempty"`
	//* 升级材料ID(SkillItemConfig)
	UpItemID uint32 `protobuf:"varint,5,opt,name=UpItemID,proto3" json:"UpItemID,omitempty"`
	//* 升级技能材料数量
	UpItemNum []uint32 `protobuf:"varint,6,rep,packed,name=UpItemNum,proto3" json:"UpItemNum,omitempty"`
	//* 升级技能消耗的货币类型
	UpCoinType uint32 `protobuf:"varint,7,opt,name=UpCoinType,proto3" json:"UpCoinType,omitempty"`
	//* 升级技能消耗的货币数量
	UpCoinNum []uint32 `protobuf:"varint,8,rep,packed,name=UpCoinNum,proto3" json:"UpCoinNum,omitempty"`
}

func (m *SkillEntity_Config) Reset()         { *m = SkillEntity_Config{} }
func (m *SkillEntity_Config) String() string { return proto.CompactTextString(m) }
func (*SkillEntity_Config) ProtoMessage()    {}
func (*SkillEntity_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{3}
}
func (m *SkillEntity_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillEntity_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillEntity_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillEntity_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillEntity_Config.Merge(m, src)
}
func (m *SkillEntity_Config) XXX_Size() int {
	return m.Size()
}
func (m *SkillEntity_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillEntity_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SkillEntity_Config proto.InternalMessageInfo

func (m *SkillEntity_Config) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SkillEntity_Config) GetSpecialAgentType() []uint32 {
	if m != nil {
		return m.SpecialAgentType
	}
	return nil
}

func (m *SkillEntity_Config) GetSpecialAgentID() []uint32 {
	if m != nil {
		return m.SpecialAgentID
	}
	return nil
}

func (m *SkillEntity_Config) GetTopSkillLevel() uint32 {
	if m != nil {
		return m.TopSkillLevel
	}
	return 0
}

func (m *SkillEntity_Config) GetUpItemID() uint32 {
	if m != nil {
		return m.UpItemID
	}
	return 0
}

func (m *SkillEntity_Config) GetUpItemNum() []uint32 {
	if m != nil {
		return m.UpItemNum
	}
	return nil
}

func (m *SkillEntity_Config) GetUpCoinType() uint32 {
	if m != nil {
		return m.UpCoinType
	}
	return 0
}

func (m *SkillEntity_Config) GetUpCoinNum() []uint32 {
	if m != nil {
		return m.UpCoinNum
	}
	return nil
}

type SkillLevelUp_Config struct {
}

func (m *SkillLevelUp_Config) Reset()         { *m = SkillLevelUp_Config{} }
func (m *SkillLevelUp_Config) String() string { return proto.CompactTextString(m) }
func (*SkillLevelUp_Config) ProtoMessage()    {}
func (*SkillLevelUp_Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{4}
}
func (m *SkillLevelUp_Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillLevelUp_Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillLevelUp_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillLevelUp_Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillLevelUp_Config.Merge(m, src)
}
func (m *SkillLevelUp_Config) XXX_Size() int {
	return m.Size()
}
func (m *SkillLevelUp_Config) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillLevelUp_Config.DiscardUnknown(m)
}

var xxx_messageInfo_SkillLevelUp_Config proto.InternalMessageInfo

type Skill_Config_Data struct {
	SkillMain_ConfigItems    map[uint32]*SkillMain_Config    `protobuf:"bytes,1,rep,name=SkillMain_Config_items,json=SkillMainConfigItems,proto3" json:"SkillMain_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SkillValue_ConfigItems   map[uint32]*SkillValue_Config   `protobuf:"bytes,2,rep,name=SkillValue_Config_items,json=SkillValueConfigItems,proto3" json:"SkillValue_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SkillItem_ConfigItems    map[uint32]*SkillItem_Config    `protobuf:"bytes,3,rep,name=SkillItem_Config_items,json=SkillItemConfigItems,proto3" json:"SkillItem_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SkillEntity_ConfigItems  map[uint32]*SkillEntity_Config  `protobuf:"bytes,4,rep,name=SkillEntity_Config_items,json=SkillEntityConfigItems,proto3" json:"SkillEntity_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	SkillLevelUp_ConfigItems map[uint32]*SkillLevelUp_Config `protobuf:"bytes,5,rep,name=SkillLevelUp_Config_items,json=SkillLevelUpConfigItems,proto3" json:"SkillLevelUp_Config_items,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Skill_Config_Data) Reset()         { *m = Skill_Config_Data{} }
func (m *Skill_Config_Data) String() string { return proto.CompactTextString(m) }
func (*Skill_Config_Data) ProtoMessage()    {}
func (*Skill_Config_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_14e955951e56950c, []int{5}
}
func (m *Skill_Config_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Skill_Config_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Skill_Config_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Skill_Config_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Skill_Config_Data.Merge(m, src)
}
func (m *Skill_Config_Data) XXX_Size() int {
	return m.Size()
}
func (m *Skill_Config_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Skill_Config_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Skill_Config_Data proto.InternalMessageInfo

func (m *Skill_Config_Data) GetSkillMain_ConfigItems() map[uint32]*SkillMain_Config {
	if m != nil {
		return m.SkillMain_ConfigItems
	}
	return nil
}

func (m *Skill_Config_Data) GetSkillValue_ConfigItems() map[uint32]*SkillValue_Config {
	if m != nil {
		return m.SkillValue_ConfigItems
	}
	return nil
}

func (m *Skill_Config_Data) GetSkillItem_ConfigItems() map[uint32]*SkillItem_Config {
	if m != nil {
		return m.SkillItem_ConfigItems
	}
	return nil
}

func (m *Skill_Config_Data) GetSkillEntity_ConfigItems() map[uint32]*SkillEntity_Config {
	if m != nil {
		return m.SkillEntity_ConfigItems
	}
	return nil
}

func (m *Skill_Config_Data) GetSkillLevelUp_ConfigItems() map[uint32]*SkillLevelUp_Config {
	if m != nil {
		return m.SkillLevelUp_ConfigItems
	}
	return nil
}

func init() {
	proto.RegisterType((*SkillMain_Config)(nil), "DataTables.SkillMain_Config")
	proto.RegisterType((*SkillValue_Config)(nil), "DataTables.SkillValue_Config")
	proto.RegisterType((*SkillItem_Config)(nil), "DataTables.SkillItem_Config")
	proto.RegisterType((*SkillEntity_Config)(nil), "DataTables.SkillEntity_Config")
	proto.RegisterType((*SkillLevelUp_Config)(nil), "DataTables.SkillLevelUp_Config")
	proto.RegisterType((*Skill_Config_Data)(nil), "DataTables.Skill_Config_Data")
	proto.RegisterMapType((map[uint32]*SkillEntity_Config)(nil), "DataTables.Skill_Config_Data.SkillEntityConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*SkillItem_Config)(nil), "DataTables.Skill_Config_Data.SkillItemConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*SkillLevelUp_Config)(nil), "DataTables.Skill_Config_Data.SkillLevelUpConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*SkillMain_Config)(nil), "DataTables.Skill_Config_Data.SkillMainConfigItemsEntry")
	proto.RegisterMapType((map[uint32]*SkillValue_Config)(nil), "DataTables.Skill_Config_Data.SkillValueConfigItemsEntry")
}

func init() { proto.RegisterFile("Skill_Config.proto", fileDescriptor_14e955951e56950c) }

var fileDescriptor_14e955951e56950c = []byte{
	// 1035 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xc7, 0xd7, 0x49, 0xd3, 0x26, 0x93, 0xa6, 0x9b, 0x9d, 0xfe, 0xd8, 0xd9, 0x52, 0x42, 0x14,
	0x21, 0x14, 0xed, 0x21, 0xa0, 0xee, 0x02, 0x4b, 0xc5, 0x25, 0x8d, 0x4b, 0xb1, 0x68, 0x4b, 0xe5,
	0x4d, 0xb9, 0x56, 0xd3, 0x78, 0x9a, 0x1d, 0xc5, 0xf6, 0x18, 0x7b, 0xd2, 0x36, 0x37, 0xfe, 0x04,
	0x4e, 0xfc, 0x4d, 0x88, 0xd3, 0x1e, 0xb9, 0x20, 0x50, 0xfb, 0x8f, 0xa0, 0x79, 0x9e, 0x24, 0x76,
	0xec, 0xac, 0x0a, 0xb7, 0xbc, 0xef, 0x7b, 0xcf, 0x9f, 0x99, 0xf7, 0xde, 0xcc, 0x04, 0xe1, 0xb7,
	0x23, 0xee, 0xba, 0x97, 0x3d, 0xe1, 0x5f, 0xf3, 0x61, 0x27, 0x08, 0x85, 0x14, 0x18, 0x99, 0x54,
	0xd2, 0x3e, 0xbd, 0x72, 0x59, 0xd4, 0xfa, 0x63, 0x05, 0xd5, 0x21, 0xe4, 0x94, 0x72, 0x5f, 0x87,
	0xe1, 0x0d, 0x54, 0xb0, 0x4c, 0x62, 0x34, 0x8d, 0x76, 0xcd, 0x2e, 0x58, 0x26, 0xc6, 0x68, 0xe5,
	0x8c, 0x7a, 0x8c, 0x14, 0x9a, 0x46, 0xbb, 0x62, 0xc3, 0x6f, 0xbc, 0x87, 0x2a, 0x90, 0xf7, 0x03,
	0xf7, 0x1d, 0x52, 0x82, 0xd0, 0xb9, 0x80, 0x09, 0x5a, 0x3b, 0x57, 0x2c, 0xcb, 0x24, 0xab, 0xe0,
	0x9b, 0x9a, 0xca, 0x73, 0x38, 0xe6, 0xae, 0x63, 0x99, 0x64, 0x2d, 0xf6, 0x68, 0x13, 0x37, 0x10,
	0x82, 0x0f, 0x9c, 0xd0, 0x2b, 0xe6, 0x92, 0x72, 0xb3, 0xd8, 0xae, 0xd9, 0x09, 0x05, 0xb7, 0xd1,
	0xd3, 0x53, 0xee, 0xf7, 0x68, 0x24, 0x4d, 0x1e, 0x49, 0xea, 0x0f, 0x18, 0xa9, 0x34, 0x8d, 0x76,
	0xc1, 0x5e, 0x94, 0x21, 0x92, 0xde, 0xa5, 0x22, 0x91, 0x8e, 0x4c, 0xcb, 0x8a, 0xd9, 0x67, 0x5e,
	0xe0, 0x52, 0xc9, 0x2c, 0x93, 0x54, 0x61, 0x41, 0x09, 0x05, 0xb7, 0xd0, 0xfa, 0xd4, 0xea, 0x86,
	0xc3, 0x88, 0xac, 0x43, 0x05, 0x52, 0x9a, 0xda, 0x51, 0x8f, 0xfa, 0x26, 0x8d, 0xde, 0x91, 0x5a,
	0xd3, 0x68, 0x97, 0xed, 0xa9, 0x89, 0x77, 0xd0, 0xea, 0x29, 0x8d, 0x22, 0xcb, 0x24, 0x1b, 0xf0,
	0x65, 0x6d, 0x01, 0x95, 0x86, 0x43, 0x26, 0x0f, 0xc7, 0xd7, 0xd7, 0xe4, 0xa9, 0xa6, 0xce, 0x14,
	0xf5, 0xc5, 0x1f, 0x6f, 0x7d, 0x70, 0xd6, 0xe3, 0x1a, 0x69, 0x13, 0xef, 0xa2, 0x72, 0x9f, 0x7b,
	0xcc, 0xe5, 0x3e, 0x23, 0xcf, 0x60, 0x2d, 0x33, 0x1b, 0xbf, 0x44, 0xf5, 0xef, 0xb9, 0xec, 0x3a,
	0xce, 0x61, 0xc8, 0xe8, 0xe8, 0x27, 0xea, 0x8e, 0x19, 0xc1, 0x4d, 0xa3, 0x5d, 0xb2, 0x33, 0x3a,
	0x7e, 0x8d, 0xb6, 0xb5, 0xe6, 0x8a, 0xc1, 0x28, 0x91, 0xb0, 0x09, 0x09, 0xf9, 0x4e, 0xb5, 0xee,
	0x9e, 0xcb, 0x68, 0x78, 0x1c, 0x8a, 0x71, 0x40, 0xb6, 0xe2, 0x0e, 0xcd, 0x95, 0xd6, 0x5f, 0x45,
	0xf4, 0x0c, 0x1a, 0x06, 0xe1, 0xcb, 0xa6, 0x89, 0xa0, 0x35, 0x08, 0xb2, 0x4c, 0x18, 0xa8, 0x9a,
	0x3d, 0x35, 0xf1, 0x16, 0x2a, 0x9d, 0xb0, 0x1b, 0xe6, 0x92, 0x22, 0xe8, 0xb1, 0xa1, 0xe2, 0x7f,
	0x1e, 0x53, 0x97, 0xcb, 0x09, 0x59, 0x89, 0xe3, 0xb5, 0xa9, 0xaa, 0xd1, 0x13, 0xc2, 0x35, 0xc5,
	0xad, 0xaf, 0x47, 0x70, 0x66, 0xe3, 0x6f, 0xd1, 0x0b, 0xd5, 0xe9, 0xae, 0xe3, 0x5c, 0xb8, 0x92,
	0x7b, 0x54, 0x32, 0xa0, 0x9c, 0x8b, 0x5b, 0x16, 0xc2, 0x4c, 0x96, 0xec, 0xe5, 0x01, 0xf8, 0x00,
	0x91, 0xb8, 0x04, 0x39, 0xc9, 0x6b, 0x90, 0xbc, 0xd4, 0xaf, 0x66, 0xe6, 0x4c, 0x84, 0x1e, 0x75,
	0xbb, 0x52, 0xd2, 0xc1, 0x88, 0x94, 0x9b, 0x46, 0xdb, 0xb0, 0x53, 0x9a, 0xaa, 0xe4, 0x77, 0x3c,
	0x64, 0x3a, 0xa2, 0x02, 0x11, 0x09, 0x05, 0x2a, 0x2d, 0x5c, 0x47, 0xfb, 0x51, 0xec, 0x9f, 0x2b,
	0x8a, 0x71, 0x2e, 0x78, 0x24, 0x7c, 0x1d, 0x51, 0x8d, 0x19, 0x49, 0x4d, 0x9d, 0x82, 0x13, 0x3e,
	0x7c, 0x27, 0x7d, 0xee, 0x0f, 0x75, 0xd8, 0x3a, 0x84, 0x2d, 0xca, 0xf8, 0x33, 0xb4, 0xd1, 0x0f,
	0xf9, 0x70, 0xc8, 0xc2, 0xee, 0x40, 0x72, 0xe1, 0x47, 0x30, 0xc8, 0x15, 0x7b, 0x41, 0x6d, 0xfd,
	0x52, 0xd0, 0x97, 0x85, 0x25, 0x99, 0xf7, 0xdf, 0xdb, 0x0b, 0xc7, 0xe1, 0xee, 0x6c, 0xec, 0xe9,
	0xfe, 0x6a, 0x4b, 0x6d, 0xf6, 0x94, 0xde, 0x9d, 0x73, 0x97, 0x29, 0x5f, 0xdc, 0xe3, 0x84, 0x82,
	0xbf, 0x40, 0x9b, 0xc7, 0xfc, 0x5a, 0x1e, 0x0b, 0xd9, 0x13, 0x9e, 0x47, 0x7d, 0x87, 0x85, 0x47,
	0x77, 0x81, 0xbe, 0x3e, 0xf2, 0x5c, 0xf8, 0x2b, 0xb4, 0xa3, 0xe5, 0xb7, 0x01, 0x1b, 0x70, 0xea,
	0x76, 0x87, 0xcc, 0x97, 0x2a, 0xa9, 0x0c, 0x49, 0x4b, 0xbc, 0xb8, 0x89, 0xaa, 0xda, 0x73, 0x2c,
	0x5c, 0x07, 0xfa, 0x52, 0xb3, 0x93, 0x52, 0xeb, 0xb7, 0x82, 0xbe, 0x52, 0x8f, 0x7c, 0xc9, 0xe5,
	0x64, 0x59, 0x11, 0x5e, 0xa2, 0x7a, 0xf2, 0xdb, 0xfd, 0x49, 0xa0, 0x6e, 0x4f, 0x75, 0x5e, 0x32,
	0xba, 0xaa, 0x7e, 0x52, 0xb3, 0x4c, 0x52, 0x84, 0xc8, 0x05, 0x15, 0x7f, 0x8a, 0x6a, 0x7d, 0x11,
	0xc4, 0x17, 0x22, 0x9c, 0x92, 0xb8, 0x52, 0x69, 0x51, 0x9d, 0x89, 0x8b, 0x40, 0xf5, 0xc7, 0x32,
	0xa7, 0x67, 0x62, 0x6a, 0xab, 0x3b, 0x3b, 0xfe, 0xad, 0xea, 0xbc, 0x0a, 0x90, 0xb9, 0xa0, 0xda,
	0x70, 0x11, 0xf4, 0x04, 0xf7, 0x61, 0xb5, 0x71, 0x75, 0x13, 0x4a, 0x9c, 0xad, 0x2c, 0x95, 0x5d,
	0x9e, 0x66, 0x6b, 0xa1, 0xb5, 0x8d, 0x36, 0xe7, 0xab, 0xb8, 0x08, 0x74, 0x61, 0x5a, 0x7f, 0x97,
	0xf5, 0x95, 0xa0, 0x85, 0x4b, 0xf5, 0xf6, 0x60, 0x0f, 0xed, 0x2c, 0x3e, 0x3a, 0x97, 0x5c, 0x32,
	0x2f, 0x22, 0x46, 0xb3, 0xd8, 0xae, 0xee, 0x7f, 0xdd, 0x99, 0x3f, 0x51, 0x9d, 0x4c, 0x7a, 0x67,
	0x96, 0x1b, 0x8b, 0x6a, 0x03, 0xd1, 0x91, 0x2f, 0xc3, 0x89, 0xbd, 0x95, 0xe7, 0xc2, 0x01, 0x7a,
	0x9e, 0xb9, 0x96, 0x34, 0xaf, 0x00, 0xbc, 0x37, 0x8f, 0xe0, 0x41, 0x72, 0x06, 0xb8, 0x9d, 0xeb,
	0x9b, 0x6d, 0x30, 0x71, 0x50, 0x34, 0xb0, 0xf8, 0xe8, 0x0d, 0xaa, 0xdc, 0x25, 0x1b, 0x5c, 0x70,
	0xe1, 0x08, 0x91, 0xec, 0x50, 0x6a, 0xe0, 0x0a, 0x00, 0xbf, 0x79, 0x04, 0x30, 0xce, 0xce, 0x20,
	0x77, 0xf2, 0x9d, 0xf8, 0x06, 0xbd, 0xc8, 0xe9, 0xb8, 0xa6, 0x96, 0x80, 0x7a, 0xf0, 0x08, 0xaa,
	0x4e, 0xcf, 0x60, 0x9f, 0x2f, 0xf1, 0xee, 0x32, 0xcd, 0xcd, 0x1b, 0x00, 0x5c, 0x47, 0xc5, 0x11,
	0x9b, 0xe8, 0x93, 0xa8, 0x7e, 0xe2, 0x7d, 0x54, 0xba, 0x81, 0xa7, 0x4d, 0xdd, 0x46, 0xd5, 0xfd,
	0xbd, 0xcc, 0x92, 0x12, 0x43, 0x68, 0xc7, 0xa1, 0x07, 0x85, 0x37, 0xc6, 0xee, 0x10, 0xed, 0x2e,
	0xef, 0x7b, 0x0e, 0xe7, 0x55, 0x9a, 0xf3, 0x71, 0x86, 0x93, 0x9c, 0xbe, 0x24, 0x68, 0xba, 0x9f,
	0xbc, 0x7e, 0xff, 0x9f, 0xfd, 0x24, 0x66, 0x2e, 0x89, 0xe1, 0xe8, 0xa3, 0x0f, 0x74, 0x39, 0x07,
	0xf4, 0x3a, 0x0d, 0x6a, 0x64, 0x40, 0xa9, 0x69, 0x4b, 0xa2, 0x46, 0x68, 0xef, 0x43, 0xad, 0xcd,
	0x61, 0x7d, 0x99, 0x66, 0x7d, 0x92, 0x61, 0xa5, 0x87, 0x2c, 0x01, 0x3b, 0xfc, 0xfc, 0xf7, 0xfb,
	0x86, 0xf1, 0xfe, 0xbe, 0x61, 0xfc, 0x73, 0xdf, 0x30, 0x7e, 0x7d, 0x68, 0x3c, 0x79, 0xff, 0xd0,
	0x78, 0xf2, 0xe7, 0x43, 0xe3, 0x09, 0xda, 0x1e, 0x08, 0xaf, 0x63, 0x52, 0x1e, 0x4d, 0x3a, 0x11,
	0x0b, 0x6f, 0x58, 0xd8, 0x71, 0xa8, 0xa4, 0x57, 0xab, 0xf0, 0x2f, 0xf8, 0xd5, 0xbf, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xd0, 0xa7, 0x12, 0x68, 0x1b, 0x0b, 0x00, 0x00,
}

func (m *SkillMain_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillMain_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillMain_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClearGroup) > 0 {
		dAtA2 := make([]byte, len(m.ClearGroup)*10)
		var j1 int
		for _, num := range m.ClearGroup {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.HitAddBlockBreakValue != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.HitAddBlockBreakValue))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.HitAddBreakValue != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.HitAddBreakValue))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.Timeline) > 0 {
		i -= len(m.Timeline)
		copy(dAtA[i:], m.Timeline)
		i = encodeVarintSkill_Config(dAtA, i, uint64(len(m.Timeline)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OwnBuff != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.OwnBuff))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TargetBuff != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.TargetBuff))
		i--
		dAtA[i] = 0x78
	}
	if m.MassID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.MassID))
		i--
		dAtA[i] = 0x70
	}
	if m.CanDash {
		i--
		if m.CanDash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.TemplateArgs) > 0 {
		i -= len(m.TemplateArgs)
		copy(dAtA[i:], m.TemplateArgs)
		i = encodeVarintSkill_Config(dAtA, i, uint64(len(m.TemplateArgs)))
		i--
		dAtA[i] = 0x62
	}
	if m.TemplateID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.TemplateID))
		i--
		dAtA[i] = 0x58
	}
	if m.MaxCastDistance != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MaxCastDistance))))
		i--
		dAtA[i] = 0x55
	}
	if m.MinCastDistance != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MinCastDistance))))
		i--
		dAtA[i] = 0x4d
	}
	if len(m.SkillLabel) > 0 {
		dAtA4 := make([]byte, len(m.SkillLabel)*10)
		var j3 int
		for _, num := range m.SkillLabel {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if m.BuildID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.BuildID))
		i--
		dAtA[i] = 0x38
	}
	if m.ProtoID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.ProtoID))
		i--
		dAtA[i] = 0x30
	}
	if m.SkillKind != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.SkillKind))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSkill_Config(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillValue_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillValue_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillValue_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TriggerActions) > 0 {
		i -= len(m.TriggerActions)
		copy(dAtA[i:], m.TriggerActions)
		i = encodeVarintSkill_Config(dAtA, i, uint64(len(m.TriggerActions)))
		i--
		dAtA[i] = 0x6a
	}
	if m.LightningAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LightningAttack))))
		i--
		dAtA[i] = 0x61
	}
	if m.PoisonAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PoisonAttack))))
		i--
		dAtA[i] = 0x59
	}
	if m.ColdAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ColdAttack))))
		i--
		dAtA[i] = 0x51
	}
	if m.FireAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FireAttack))))
		i--
		dAtA[i] = 0x49
	}
	if m.NormalAttack != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NormalAttack))))
		i--
		dAtA[i] = 0x41
	}
	if m.HitAddUltimateSkillPower != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.HitAddUltimateSkillPower))
		i--
		dAtA[i] = 0x38
	}
	if m.CastAddUltimateSkillPower != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.CastAddUltimateSkillPower))
		i--
		dAtA[i] = 0x30
	}
	if m.CoolDown != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.CoolDown))
		i--
		dAtA[i] = 0x28
	}
	if m.Quality != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.Quality))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.SkillID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.SkillID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillItem_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillItem_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillItem_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GiftGotGold != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.GiftGotGold))
		i--
		dAtA[i] = 0x48
	}
	if m.GiftGotSpecialAgentExp != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.GiftGotSpecialAgentExp))
		i--
		dAtA[i] = 0x40
	}
	if m.GiftGotCommanderExp != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.GiftGotCommanderExp))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxPileNum != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.MaxPileNum))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxNum != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.MaxNum))
		i--
		dAtA[i] = 0x18
	}
	if m.SkillID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.SkillID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillEntity_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillEntity_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillEntity_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpCoinNum) > 0 {
		dAtA6 := make([]byte, len(m.UpCoinNum)*10)
		var j5 int
		for _, num := range m.UpCoinNum {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x42
	}
	if m.UpCoinType != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.UpCoinType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.UpItemNum) > 0 {
		dAtA8 := make([]byte, len(m.UpItemNum)*10)
		var j7 int
		for _, num := range m.UpItemNum {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x32
	}
	if m.UpItemID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.UpItemID))
		i--
		dAtA[i] = 0x28
	}
	if m.TopSkillLevel != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.TopSkillLevel))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SpecialAgentID) > 0 {
		dAtA10 := make([]byte, len(m.SpecialAgentID)*10)
		var j9 int
		for _, num := range m.SpecialAgentID {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SpecialAgentType) > 0 {
		dAtA12 := make([]byte, len(m.SpecialAgentType)*10)
		var j11 int
		for _, num := range m.SpecialAgentType {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintSkill_Config(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintSkill_Config(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillLevelUp_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillLevelUp_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillLevelUp_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Skill_Config_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Skill_Config_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Skill_Config_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SkillLevelUp_ConfigItems) > 0 {
		for k := range m.SkillLevelUp_ConfigItems {
			v := m.SkillLevelUp_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSkill_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSkill_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSkill_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SkillEntity_ConfigItems) > 0 {
		for k := range m.SkillEntity_ConfigItems {
			v := m.SkillEntity_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSkill_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSkill_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSkill_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SkillItem_ConfigItems) > 0 {
		for k := range m.SkillItem_ConfigItems {
			v := m.SkillItem_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSkill_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSkill_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSkill_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SkillValue_ConfigItems) > 0 {
		for k := range m.SkillValue_ConfigItems {
			v := m.SkillValue_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSkill_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSkill_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSkill_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SkillMain_ConfigItems) > 0 {
		for k := range m.SkillMain_ConfigItems {
			v := m.SkillMain_ConfigItems[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSkill_Config(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSkill_Config(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSkill_Config(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintSkill_Config(dAtA []byte, offset int, v uint64) int {
	offset -= sovSkill_Config(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SkillMain_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSkill_Config(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSkill_Config(uint64(l))
	}
	if m.SkillKind != 0 {
		n += 1 + sovSkill_Config(uint64(m.SkillKind))
	}
	if m.ProtoID != 0 {
		n += 1 + sovSkill_Config(uint64(m.ProtoID))
	}
	if m.BuildID != 0 {
		n += 1 + sovSkill_Config(uint64(m.BuildID))
	}
	if len(m.SkillLabel) > 0 {
		l = 0
		for _, e := range m.SkillLabel {
			l += sovSkill_Config(uint64(e))
		}
		n += 1 + sovSkill_Config(uint64(l)) + l
	}
	if m.MinCastDistance != 0 {
		n += 5
	}
	if m.MaxCastDistance != 0 {
		n += 5
	}
	if m.TemplateID != 0 {
		n += 1 + sovSkill_Config(uint64(m.TemplateID))
	}
	l = len(m.TemplateArgs)
	if l > 0 {
		n += 1 + l + sovSkill_Config(uint64(l))
	}
	if m.CanDash {
		n += 2
	}
	if m.MassID != 0 {
		n += 1 + sovSkill_Config(uint64(m.MassID))
	}
	if m.TargetBuff != 0 {
		n += 1 + sovSkill_Config(uint64(m.TargetBuff))
	}
	if m.OwnBuff != 0 {
		n += 2 + sovSkill_Config(uint64(m.OwnBuff))
	}
	l = len(m.Timeline)
	if l > 0 {
		n += 2 + l + sovSkill_Config(uint64(l))
	}
	if m.HitAddBreakValue != 0 {
		n += 2 + sovSkill_Config(uint64(m.HitAddBreakValue))
	}
	if m.HitAddBlockBreakValue != 0 {
		n += 2 + sovSkill_Config(uint64(m.HitAddBlockBreakValue))
	}
	if len(m.ClearGroup) > 0 {
		l = 0
		for _, e := range m.ClearGroup {
			l += sovSkill_Config(uint64(e))
		}
		n += 2 + sovSkill_Config(uint64(l)) + l
	}
	return n
}

func (m *SkillValue_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSkill_Config(uint64(m.ID))
	}
	if m.SkillID != 0 {
		n += 1 + sovSkill_Config(uint64(m.SkillID))
	}
	if m.Level != 0 {
		n += 1 + sovSkill_Config(uint64(m.Level))
	}
	if m.Quality != 0 {
		n += 1 + sovSkill_Config(uint64(m.Quality))
	}
	if m.CoolDown != 0 {
		n += 1 + sovSkill_Config(uint64(m.CoolDown))
	}
	if m.CastAddUltimateSkillPower != 0 {
		n += 1 + sovSkill_Config(uint64(m.CastAddUltimateSkillPower))
	}
	if m.HitAddUltimateSkillPower != 0 {
		n += 1 + sovSkill_Config(uint64(m.HitAddUltimateSkillPower))
	}
	if m.NormalAttack != 0 {
		n += 9
	}
	if m.FireAttack != 0 {
		n += 9
	}
	if m.ColdAttack != 0 {
		n += 9
	}
	if m.PoisonAttack != 0 {
		n += 9
	}
	if m.LightningAttack != 0 {
		n += 9
	}
	l = len(m.TriggerActions)
	if l > 0 {
		n += 1 + l + sovSkill_Config(uint64(l))
	}
	return n
}

func (m *SkillItem_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSkill_Config(uint64(m.ID))
	}
	if m.SkillID != 0 {
		n += 1 + sovSkill_Config(uint64(m.SkillID))
	}
	if m.MaxNum != 0 {
		n += 1 + sovSkill_Config(uint64(m.MaxNum))
	}
	if m.MaxPileNum != 0 {
		n += 1 + sovSkill_Config(uint64(m.MaxPileNum))
	}
	if m.GiftGotCommanderExp != 0 {
		n += 1 + sovSkill_Config(uint64(m.GiftGotCommanderExp))
	}
	if m.GiftGotSpecialAgentExp != 0 {
		n += 1 + sovSkill_Config(uint64(m.GiftGotSpecialAgentExp))
	}
	if m.GiftGotGold != 0 {
		n += 1 + sovSkill_Config(uint64(m.GiftGotGold))
	}
	return n
}

func (m *SkillEntity_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSkill_Config(uint64(m.ID))
	}
	if len(m.SpecialAgentType) > 0 {
		l = 0
		for _, e := range m.SpecialAgentType {
			l += sovSkill_Config(uint64(e))
		}
		n += 1 + sovSkill_Config(uint64(l)) + l
	}
	if len(m.SpecialAgentID) > 0 {
		l = 0
		for _, e := range m.SpecialAgentID {
			l += sovSkill_Config(uint64(e))
		}
		n += 1 + sovSkill_Config(uint64(l)) + l
	}
	if m.TopSkillLevel != 0 {
		n += 1 + sovSkill_Config(uint64(m.TopSkillLevel))
	}
	if m.UpItemID != 0 {
		n += 1 + sovSkill_Config(uint64(m.UpItemID))
	}
	if len(m.UpItemNum) > 0 {
		l = 0
		for _, e := range m.UpItemNum {
			l += sovSkill_Config(uint64(e))
		}
		n += 1 + sovSkill_Config(uint64(l)) + l
	}
	if m.UpCoinType != 0 {
		n += 1 + sovSkill_Config(uint64(m.UpCoinType))
	}
	if len(m.UpCoinNum) > 0 {
		l = 0
		for _, e := range m.UpCoinNum {
			l += sovSkill_Config(uint64(e))
		}
		n += 1 + sovSkill_Config(uint64(l)) + l
	}
	return n
}

func (m *SkillLevelUp_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Skill_Config_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SkillMain_ConfigItems) > 0 {
		for k, v := range m.SkillMain_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSkill_Config(uint64(l))
			}
			mapEntrySize := 1 + sovSkill_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovSkill_Config(uint64(mapEntrySize))
		}
	}
	if len(m.SkillValue_ConfigItems) > 0 {
		for k, v := range m.SkillValue_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSkill_Config(uint64(l))
			}
			mapEntrySize := 1 + sovSkill_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovSkill_Config(uint64(mapEntrySize))
		}
	}
	if len(m.SkillItem_ConfigItems) > 0 {
		for k, v := range m.SkillItem_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSkill_Config(uint64(l))
			}
			mapEntrySize := 1 + sovSkill_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovSkill_Config(uint64(mapEntrySize))
		}
	}
	if len(m.SkillEntity_ConfigItems) > 0 {
		for k, v := range m.SkillEntity_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSkill_Config(uint64(l))
			}
			mapEntrySize := 1 + sovSkill_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovSkill_Config(uint64(mapEntrySize))
		}
	}
	if len(m.SkillLevelUp_ConfigItems) > 0 {
		for k, v := range m.SkillLevelUp_ConfigItems {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSkill_Config(uint64(l))
			}
			mapEntrySize := 1 + sovSkill_Config(uint64(k)) + l
			n += mapEntrySize + 1 + sovSkill_Config(uint64(mapEntrySize))
		}
	}
	return n
}

func sovSkill_Config(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSkill_Config(x uint64) (n int) {
	return sovSkill_Config(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SkillMain_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillMain_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillMain_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillKind", wireType)
			}
			m.SkillKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillKind |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoID", wireType)
			}
			m.ProtoID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtoID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildID", wireType)
			}
			m.BuildID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkillLabel = append(m.SkillLabel, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkillLabel) == 0 {
					m.SkillLabel = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkillLabel = append(m.SkillLabel, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLabel", wireType)
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCastDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MinCastDistance = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCastDistance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MaxCastDistance = float32(math.Float32frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateID", wireType)
			}
			m.TemplateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemplateID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateArgs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanDash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanDash = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MassID", wireType)
			}
			m.MassID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MassID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBuff", wireType)
			}
			m.TargetBuff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBuff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnBuff", wireType)
			}
			m.OwnBuff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnBuff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timeline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitAddBreakValue", wireType)
			}
			m.HitAddBreakValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitAddBreakValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitAddBlockBreakValue", wireType)
			}
			m.HitAddBlockBreakValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitAddBlockBreakValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClearGroup = append(m.ClearGroup, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ClearGroup) == 0 {
					m.ClearGroup = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClearGroup = append(m.ClearGroup, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearGroup", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillValue_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillValue_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillValue_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoolDown", wireType)
			}
			m.CoolDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoolDown |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastAddUltimateSkillPower", wireType)
			}
			m.CastAddUltimateSkillPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CastAddUltimateSkillPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HitAddUltimateSkillPower", wireType)
			}
			m.HitAddUltimateSkillPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HitAddUltimateSkillPower |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NormalAttack = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FireAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FireAttack = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColdAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ColdAttack = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoisonAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PoisonAttack = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightningAttack", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LightningAttack = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerActions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerActions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillItem_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillItem_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillItem_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNum", wireType)
			}
			m.MaxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPileNum", wireType)
			}
			m.MaxPileNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPileNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGotCommanderExp", wireType)
			}
			m.GiftGotCommanderExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGotCommanderExp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGotSpecialAgentExp", wireType)
			}
			m.GiftGotSpecialAgentExp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGotSpecialAgentExp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftGotGold", wireType)
			}
			m.GiftGotGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftGotGold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillEntity_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillEntity_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillEntity_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpecialAgentType = append(m.SpecialAgentType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SpecialAgentType) == 0 {
					m.SpecialAgentType = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpecialAgentType = append(m.SpecialAgentType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialAgentType", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SpecialAgentID = append(m.SpecialAgentID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SpecialAgentID) == 0 {
					m.SpecialAgentID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SpecialAgentID = append(m.SpecialAgentID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialAgentID", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopSkillLevel", wireType)
			}
			m.TopSkillLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopSkillLevel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpItemID", wireType)
			}
			m.UpItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpItemID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpItemNum = append(m.UpItemNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpItemNum) == 0 {
					m.UpItemNum = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpItemNum = append(m.UpItemNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpItemNum", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpCoinType", wireType)
			}
			m.UpCoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpCoinType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpCoinNum = append(m.UpCoinNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSkill_Config
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSkill_Config
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UpCoinNum) == 0 {
					m.UpCoinNum = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpCoinNum = append(m.UpCoinNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpCoinNum", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillLevelUp_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillLevelUp_Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillLevelUp_Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Skill_Config_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Skill_Config_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Skill_Config_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillMain_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillMain_ConfigItems == nil {
				m.SkillMain_ConfigItems = make(map[uint32]*SkillMain_Config)
			}
			var mapkey uint32
			var mapvalue *SkillMain_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSkill_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillMain_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSkill_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillMain_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillValue_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillValue_ConfigItems == nil {
				m.SkillValue_ConfigItems = make(map[uint32]*SkillValue_Config)
			}
			var mapkey uint32
			var mapvalue *SkillValue_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSkill_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillValue_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSkill_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillValue_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillItem_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillItem_ConfigItems == nil {
				m.SkillItem_ConfigItems = make(map[uint32]*SkillItem_Config)
			}
			var mapkey uint32
			var mapvalue *SkillItem_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSkill_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillItem_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSkill_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillItem_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillEntity_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillEntity_ConfigItems == nil {
				m.SkillEntity_ConfigItems = make(map[uint32]*SkillEntity_Config)
			}
			var mapkey uint32
			var mapvalue *SkillEntity_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSkill_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillEntity_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSkill_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillEntity_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillLevelUp_ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSkill_Config
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkillLevelUp_ConfigItems == nil {
				m.SkillLevelUp_ConfigItems = make(map[uint32]*SkillLevelUp_Config)
			}
			var mapkey uint32
			var mapvalue *SkillLevelUp_Config
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSkill_Config
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSkill_Config
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSkill_Config
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SkillLevelUp_Config{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSkill_Config(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSkill_Config
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SkillLevelUp_ConfigItems[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSkill_Config(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSkill_Config
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSkill_Config(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSkill_Config
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSkill_Config
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSkill_Config
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSkill_Config
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSkill_Config
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSkill_Config        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSkill_Config          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSkill_Config = fmt.Errorf("proto: unexpected end of group")
)
